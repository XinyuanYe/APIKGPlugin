{"node_name": "AccessibilityEventMonitor()", "type": "constructor", "idx": 5, "Desc": ""}{"node_name": "AccessibilityListenerList()", "type": "constructor", "idx": 12, "Desc": ""}{"node_name": "AWTEventMonitor()", "type": "constructor", "idx": 25, "Desc": ""}{"node_name": "EventID()", "type": "constructor", "idx": 101, "Desc": ""}{"node_name": "EventQueueMonitor()", "type": "constructor", "idx": 103, "Desc": "create a new eventqueuemonitor instance . normally , this will be called only by the awt toolkit during initialization time . assistive technologies should not create instances of eventqueuemonitor by themselves . instead , they should either refer to it directly via the static methods in this class , e.g. , getcurrentmouseposition() or obtain the instance by asking the toolkit , e.g. , toolkit.getsystemeventqueue() ."}{"node_name": "SwingEventMonitor()", "type": "constructor", "idx": 125, "Desc": ""}{"node_name": "Translator()", "type": "constructor", "idx": 205, "Desc": "create a new translator . you must call the setsource method to set the object to be translated after calling <init>() ."}{"node_name": "Translator(java.lang.Object)", "type": "constructor", "idx": 206, "Desc": "create a new translator with the source object o ."}{"node_name": "AbsentInformationException()", "type": "constructor", "idx": 279, "Desc": ""}{"node_name": "AbsentInformationException(java.lang.String)", "type": "constructor", "idx": 280, "Desc": ""}{"node_name": "Bootstrap()", "type": "constructor", "idx": 318, "Desc": ""}{"node_name": "ClassNotLoadedException(java.lang.String)", "type": "constructor", "idx": 336, "Desc": ""}{"node_name": "ClassNotLoadedException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 337, "Desc": ""}{"node_name": "ClassNotPreparedException()", "type": "constructor", "idx": 340, "Desc": ""}{"node_name": "ClassNotPreparedException(java.lang.String)", "type": "constructor", "idx": 341, "Desc": ""}{"node_name": "IllegalConnectorArgumentsException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 402, "Desc": "construct an illegalconnectorargumentsexception with the specified detail message and the name of the argument which is invalid or inconsistent ."}{"node_name": "IllegalConnectorArgumentsException(java.lang.String,java.util.List)", "type": "constructor", "idx": 405, "Desc": "construct an illegalconnectorargumentsexception with the specified detail message and a list of names of arguments which are invalid or inconsistent ."}{"node_name": "ClosedConnectionException()", "type": "constructor", "idx": 418, "Desc": "constructs a closedconnectionexception with no detail message ."}{"node_name": "ClosedConnectionException(java.lang.String)", "type": "constructor", "idx": 419, "Desc": "constructs a closedconnectionexception with the specified detail message ."}{"node_name": "Connection()", "type": "constructor", "idx": 422, "Desc": ""}{"node_name": "Capabilities()", "type": "constructor", "idx": 429, "Desc": ""}{"node_name": "TransportService()", "type": "constructor", "idx": 435, "Desc": ""}{"node_name": "ListenKey()", "type": "constructor", "idx": 453, "Desc": ""}{"node_name": "TransportTimeoutException()", "type": "constructor", "idx": 458, "Desc": "constructs a transporttimeoutexception with no detail message ."}{"node_name": "TransportTimeoutException(java.lang.String)", "type": "constructor", "idx": 459, "Desc": "constructs a transporttimeoutexception with the specified detail message ."}{"node_name": "VMStartException(java.lang.Process)", "type": "constructor", "idx": 462, "Desc": ""}{"node_name": "VMStartException(java.lang.String,java.lang.Process)", "type": "constructor", "idx": 463, "Desc": ""}{"node_name": "IncompatibleThreadStateException()", "type": "constructor", "idx": 546, "Desc": ""}{"node_name": "IncompatibleThreadStateException(java.lang.String)", "type": "constructor", "idx": 547, "Desc": ""}{"node_name": "InconsistentDebugInfoException()", "type": "constructor", "idx": 549, "Desc": ""}{"node_name": "InconsistentDebugInfoException(java.lang.String)", "type": "constructor", "idx": 550, "Desc": ""}{"node_name": "InternalException()", "type": "constructor", "idx": 567, "Desc": ""}{"node_name": "InternalException(java.lang.String)", "type": "constructor", "idx": 568, "Desc": ""}{"node_name": "InternalException(int)", "type": "constructor", "idx": 569, "Desc": ""}{"node_name": "InternalException(java.lang.String,int)", "type": "constructor", "idx": 570, "Desc": ""}{"node_name": "InvalidModuleException()", "type": "constructor", "idx": 575, "Desc": "constructs an invalidmoduleexception with no detail message ."}{"node_name": "InvalidModuleException(java.lang.String)", "type": "constructor", "idx": 576, "Desc": "constructs an invalidmoduleexception with the given detail message ."}{"node_name": "InvalidStackFrameException()", "type": "constructor", "idx": 579, "Desc": ""}{"node_name": "InvalidStackFrameException(java.lang.String)", "type": "constructor", "idx": 580, "Desc": ""}{"node_name": "InvalidTypeException()", "type": "constructor", "idx": 582, "Desc": ""}{"node_name": "InvalidTypeException(java.lang.String)", "type": "constructor", "idx": 583, "Desc": ""}{"node_name": "InvocationException(com.sun.jdi.ObjectReference)", "type": "constructor", "idx": 585, "Desc": ""}{"node_name": "JDIPermission(java.lang.String)", "type": "constructor", "idx": 588, "Desc": "the jdipermission class represents access rights to the virtualmachinemanager"}{"node_name": "JDIPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 590, "Desc": "constructs a new jdipermission object ."}{"node_name": "NativeMethodException()", "type": "constructor", "idx": 673, "Desc": ""}{"node_name": "NativeMethodException(java.lang.String)", "type": "constructor", "idx": 674, "Desc": ""}{"node_name": "ObjectCollectedException()", "type": "constructor", "idx": 676, "Desc": ""}{"node_name": "ObjectCollectedException(java.lang.String)", "type": "constructor", "idx": 677, "Desc": ""}{"node_name": "DuplicateRequestException()", "type": "constructor", "idx": 800, "Desc": ""}{"node_name": "DuplicateRequestException(java.lang.String)", "type": "constructor", "idx": 801, "Desc": ""}{"node_name": "InvalidRequestStateException()", "type": "constructor", "idx": 880, "Desc": ""}{"node_name": "InvalidRequestStateException(java.lang.String)", "type": "constructor", "idx": 881, "Desc": ""}{"node_name": "VMCannotBeModifiedException()", "type": "constructor", "idx": 1152, "Desc": ""}{"node_name": "VMCannotBeModifiedException(java.lang.String)", "type": "constructor", "idx": 1153, "Desc": ""}{"node_name": "VMDisconnectedException()", "type": "constructor", "idx": 1155, "Desc": ""}{"node_name": "VMDisconnectedException(java.lang.String)", "type": "constructor", "idx": 1156, "Desc": ""}{"node_name": "VMMismatchException()", "type": "constructor", "idx": 1158, "Desc": ""}{"node_name": "VMMismatchException(java.lang.String)", "type": "constructor", "idx": 1159, "Desc": ""}{"node_name": "VMOutOfMemoryException()", "type": "constructor", "idx": 1161, "Desc": ""}{"node_name": "VMOutOfMemoryException(java.lang.String)", "type": "constructor", "idx": 1162, "Desc": ""}{"node_name": "GarbageCollectionNotificationInfo(java.lang.String,java.lang.String,java.lang.String,com.sun.management.GcInfo)", "type": "constructor", "idx": 1171, "Desc": "constructs a garbagecollectionnotificationinfo object ."}{"node_name": "VMOption(java.lang.String,java.lang.String,boolean,com.sun.management.VMOption.Origin)", "type": "constructor", "idx": 1229, "Desc": "constructs a vmoption ."}{"node_name": "Failure(int)", "type": "constructor", "idx": 1245, "Desc": ""}{"node_name": "Authenticator()", "type": "constructor", "idx": 1248, "Desc": ""}{"node_name": "Result()", "type": "constructor", "idx": 1251, "Desc": ""}{"node_name": "Retry(int)", "type": "constructor", "idx": 1253, "Desc": ""}{"node_name": "Success(com.sun.net.httpserver.HttpPrincipal)", "type": "constructor", "idx": 1256, "Desc": ""}{"node_name": "BasicAuthenticator(java.lang.String)", "type": "constructor", "idx": 1260, "Desc": "creates a basicauthenticator for the given http realm"}{"node_name": "Chain(java.util.List,com.sun.net.httpserver.HttpHandler)", "type": "constructor", "idx": 1267, "Desc": ""}{"node_name": "Filter()", "type": "constructor", "idx": 1271, "Desc": ""}{"node_name": "Headers()", "type": "constructor", "idx": 1277, "Desc": ""}{"node_name": "HttpContext()", "type": "constructor", "idx": 1287, "Desc": ""}{"node_name": "HttpExchange()", "type": "constructor", "idx": 1299, "Desc": ""}{"node_name": "HttpPrincipal(java.lang.String,java.lang.String)", "type": "constructor", "idx": 1328, "Desc": "creates a httpprincipal from the given username and realm"}{"node_name": "HttpsConfigurator(javax.net.ssl.SSLContext)", "type": "constructor", "idx": 1339, "Desc": "creates an https configuration , with the given sslcontext ."}{"node_name": "HttpServer()", "type": "constructor", "idx": 1345, "Desc": ""}{"node_name": "HttpsExchange()", "type": "constructor", "idx": 1370, "Desc": ""}{"node_name": "HttpsParameters()", "type": "constructor", "idx": 1373, "Desc": ""}{"node_name": "HttpsServer()", "type": "constructor", "idx": 1391, "Desc": ""}{"node_name": "HttpServerProvider()", "type": "constructor", "idx": 1400, "Desc": "initializes a new instance of this class ."}{"node_name": "AbstractNotificationHandler()", "type": "constructor", "idx": 1409, "Desc": "initializes a new instance of this class ."}{"node_name": "Association(int,int,int)", "type": "constructor", "idx": 1426, "Desc": "initializes a new instance of this class ."}{"node_name": "AssociationChangeNotification()", "type": "constructor", "idx": 1438, "Desc": "initializes a new instance of this class ."}{"node_name": "IllegalReceiveException()", "type": "constructor", "idx": 1446, "Desc": "constructs an instance of this class ."}{"node_name": "IllegalReceiveException(java.lang.String)", "type": "constructor", "idx": 1447, "Desc": "constructs an instance of this class with the specified message ."}{"node_name": "IllegalUnbindException()", "type": "constructor", "idx": 1450, "Desc": "constructs an instance of this class ."}{"node_name": "IllegalUnbindException(java.lang.String)", "type": "constructor", "idx": 1451, "Desc": "constructs an instance of this class with the specified detailed message ."}{"node_name": "InvalidStreamException()", "type": "constructor", "idx": 1454, "Desc": "constructs an instance of this class ."}{"node_name": "InvalidStreamException(java.lang.String)", "type": "constructor", "idx": 1455, "Desc": "constructs an instance of this class with the specified detailed message ."}{"node_name": "MessageInfo()", "type": "constructor", "idx": 1458, "Desc": "initializes a new instance of this class ."}{"node_name": "PeerAddressChangeNotification()", "type": "constructor", "idx": 1495, "Desc": "initializes a new instance of this class ."}{"node_name": "SctpChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 1500, "Desc": "initializes a new instance of this class ."}{"node_name": "SctpMultiChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 1540, "Desc": "initializes a new instance of this class ."}{"node_name": "SctpServerChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 1577, "Desc": "initializes a new instance of this class ."}{"node_name": "SendFailedNotification()", "type": "constructor", "idx": 1621, "Desc": "initializes a new instance of this class ."}{"node_name": "ShutdownNotification()", "type": "constructor", "idx": 1628, "Desc": "initializes a new instance of this class ."}{"node_name": "TextCallbackHandler()", "type": "constructor", "idx": 1631, "Desc": "creates a callback handler that prompts and reads from the command line for answers to authentication questions . this can be used by jaas applications to instantiate a callbackhandler ."}{"node_name": "LdapPrincipal(java.lang.String)", "type": "constructor", "idx": 1635, "Desc": "creates an ldap principal ."}{"node_name": "ConfigFile()", "type": "constructor", "idx": 1643, "Desc": "create a new configuration object ."}{"node_name": "ConfigFile(java.net.URI)", "type": "constructor", "idx": 1644, "Desc": "create a new configuration object from the specified uri ."}{"node_name": "JndiLoginModule()", "type": "constructor", "idx": 1652, "Desc": ""}{"node_name": "KeyStoreLoginModule()", "type": "constructor", "idx": 1663, "Desc": ""}{"node_name": "Krb5LoginModule()", "type": "constructor", "idx": 1674, "Desc": ""}{"node_name": "LdapLoginModule()", "type": "constructor", "idx": 1685, "Desc": ""}{"node_name": "NTLoginModule()", "type": "constructor", "idx": 1696, "Desc": ""}{"node_name": "NTSystem()", "type": "constructor", "idx": 1707, "Desc": "instantiate an ntsystem and load the native library to access the underlying system information ."}{"node_name": "UnixLoginModule()", "type": "constructor", "idx": 1716, "Desc": ""}{"node_name": "UnixSystem()", "type": "constructor", "idx": 1731, "Desc": "instantiate a unixsystem and load the native library to access the underlying system information ."}{"node_name": "NTDomainPrincipal(java.lang.String)", "type": "constructor", "idx": 1737, "Desc": "create an ntdomainprincipal with a windows nt domain name ."}{"node_name": "NTNumericCredential(long)", "type": "constructor", "idx": 1745, "Desc": "create an ntnumericcredential with an integer value ."}{"node_name": "NTSid(java.lang.String)", "type": "constructor", "idx": 1753, "Desc": "create an ntsid with a windows nt sid ."}{"node_name": "NTSidDomainPrincipal(java.lang.String)", "type": "constructor", "idx": 1761, "Desc": "create an ntsiddomainprincipal with a windows nt sid ."}{"node_name": "NTSidGroupPrincipal(java.lang.String)", "type": "constructor", "idx": 1767, "Desc": "create an ntsidgroupprincipal with a windows nt group name ."}{"node_name": "NTSidPrimaryGroupPrincipal(java.lang.String)", "type": "constructor", "idx": 1773, "Desc": "create an ntsidprimarygroupprincipal with a windows nt group sid ."}{"node_name": "NTSidUserPrincipal(java.lang.String)", "type": "constructor", "idx": 1779, "Desc": "create an ntsiduserprincipal with a windows nt sid ."}{"node_name": "NTUserPrincipal(java.lang.String)", "type": "constructor", "idx": 1785, "Desc": "create an ntuserprincipal with a windows nt username ."}{"node_name": "UnixNumericGroupPrincipal(java.lang.String,boolean)", "type": "constructor", "idx": 1795, "Desc": "create a unixnumericgroupprincipal using a string representation of the user's group identification number ( gid ) ."}{"node_name": "UnixNumericGroupPrincipal(long,boolean)", "type": "constructor", "idx": 1798, "Desc": "create a unixnumericgroupprincipal using a long representation of the user's group identification number ( gid ) ."}{"node_name": "UnixNumericUserPrincipal(java.lang.String)", "type": "constructor", "idx": 1809, "Desc": "create a unixnumericuserprincipal using a string representation of the user's identification number ( uid ) ."}{"node_name": "UnixNumericUserPrincipal(long)", "type": "constructor", "idx": 1811, "Desc": "create a unixnumericuserprincipal using a long representation of the user's identification number ( uid ) ."}{"node_name": "UnixPrincipal(java.lang.String)", "type": "constructor", "idx": 1820, "Desc": "create a unixprincipal with a unix username ."}{"node_name": "UserPrincipal(java.lang.String)", "type": "constructor", "idx": 1828, "Desc": "creates a principal ."}{"node_name": "AuthorizationDataEntry(int,byte[])", "type": "constructor", "idx": 1836, "Desc": "create an authorizationdataentry object ."}{"node_name": "GSSUtil()", "type": "constructor", "idx": 1851, "Desc": ""}{"node_name": "InquireSecContextPermission(java.lang.String)", "type": "constructor", "idx": 1856, "Desc": "constructs a new inquireseccontextpermission object with the specified name . the name is the symbolic name of the inquiretype allowed ."}{"node_name": "DocTreePath(com.sun.source.util.TreePath,com.sun.source.doctree.DocCommentTree)", "type": "constructor", "idx": 2611, "Desc": "creates a doctreepath for a root node ."}{"node_name": "DocTreePath(com.sun.source.util.DocTreePath,com.sun.source.doctree.DocTree)", "type": "constructor", "idx": 2614, "Desc": "creates a doctreepath for a child node ."}{"node_name": "DocTreePathScanner()", "type": "constructor", "idx": 2629, "Desc": ""}{"node_name": "DocTrees()", "type": "constructor", "idx": 2638, "Desc": ""}{"node_name": "DocTreeScanner()", "type": "constructor", "idx": 2671, "Desc": ""}{"node_name": "JavacTask()", "type": "constructor", "idx": 2790, "Desc": ""}{"node_name": "SimpleDocTreeVisitor()", "type": "constructor", "idx": 2818, "Desc": "creates a visitor , with a default_value of null ."}{"node_name": "SimpleDocTreeVisitor(java.lang.Object)", "type": "constructor", "idx": 2819, "Desc": "creates a visitor , with a specified default_value ."}{"node_name": "SimpleTreeVisitor()", "type": "constructor", "idx": 2940, "Desc": "creates a visitor , with a default_value of null ."}{"node_name": "SimpleTreeVisitor(java.lang.Object)", "type": "constructor", "idx": 2941, "Desc": "creates a visitor , with a specified default_value ."}{"node_name": "TaskEvent(com.sun.source.util.TaskEvent.Kind)", "type": "constructor", "idx": 3119, "Desc": "creates a task event for a given kind . the source file , compilation unit and type element are all set to null ."}{"node_name": "TaskEvent(com.sun.source.util.TaskEvent.Kind,javax.tools.JavaFileObject)", "type": "constructor", "idx": 3121, "Desc": "creates a task event for a given kind and source file . the compilation unit and type element are both set to null ."}{"node_name": "TaskEvent(com.sun.source.util.TaskEvent.Kind,com.sun.source.tree.CompilationUnitTree)", "type": "constructor", "idx": 3124, "Desc": "creates a task event for a given kind and compilation unit . the source file is set from the compilation unit , and the type element is set to null ."}{"node_name": "TaskEvent(com.sun.source.util.TaskEvent.Kind,com.sun.source.tree.CompilationUnitTree,javax.lang.model.element.TypeElement)", "type": "constructor", "idx": 3127, "Desc": "creates a task event for a given kind , compilation unit and type element . the source file is set from the compilation unit ."}{"node_name": "TreePath(com.sun.source.tree.CompilationUnitTree)", "type": "constructor", "idx": 3145, "Desc": "creates a treepath for a root node ."}{"node_name": "TreePath(com.sun.source.util.TreePath,com.sun.source.tree.Tree)", "type": "constructor", "idx": 3147, "Desc": "creates a treepath for a child node ."}{"node_name": "TreePathScanner()", "type": "constructor", "idx": 3161, "Desc": ""}{"node_name": "Trees()", "type": "constructor", "idx": 3170, "Desc": ""}{"node_name": "TreeScanner()", "type": "constructor", "idx": 3226, "Desc": ""}{"node_name": "AgentInitializationException()", "type": "constructor", "idx": 3399, "Desc": "constructs an agentinitializationexception with no detail message ."}{"node_name": "AgentInitializationException(java.lang.String)", "type": "constructor", "idx": 3400, "Desc": "constructs an agentinitializationexception with the specified detail message ."}{"node_name": "AgentInitializationException(java.lang.String,int)", "type": "constructor", "idx": 3402, "Desc": "constructs an agentinitializationexception with the specified detail message and the return value from the execution of the agent's agent_onattach function ."}{"node_name": "AgentLoadException()", "type": "constructor", "idx": 3407, "Desc": "constructs an agentloadexception with no detail message ."}{"node_name": "AgentLoadException(java.lang.String)", "type": "constructor", "idx": 3408, "Desc": "constructs an agentloadexception with the specified detail message ."}{"node_name": "AttachNotSupportedException()", "type": "constructor", "idx": 3411, "Desc": "constructs an attachnotsupportedexception with no detail message ."}{"node_name": "AttachNotSupportedException(java.lang.String)", "type": "constructor", "idx": 3412, "Desc": "constructs an attachnotsupportedexception with the specified detail message ."}{"node_name": "AttachOperationFailedException(java.lang.String)", "type": "constructor", "idx": 3415, "Desc": "constructs an attachoperationfailedexception with the specified detail message ."}{"node_name": "AttachPermission(java.lang.String)", "type": "constructor", "idx": 3418, "Desc": "constructs a new attachpermission object ."}{"node_name": "AttachPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 3420, "Desc": "constructs a new attachpermission object ."}{"node_name": "AttachProvider()", "type": "constructor", "idx": 3424, "Desc": "initializes a new instance of this class ."}{"node_name": "VirtualMachine(com.sun.tools.attach.spi.AttachProvider,java.lang.String)", "type": "constructor", "idx": 3434, "Desc": "initializes a new instance of this class ."}{"node_name": "VirtualMachineDescriptor(com.sun.tools.attach.spi.AttachProvider,java.lang.String,java.lang.String)", "type": "constructor", "idx": 3470, "Desc": "creates a virtual machine descriptor from the given components ."}{"node_name": "VirtualMachineDescriptor(com.sun.tools.attach.spi.AttachProvider,java.lang.String)", "type": "constructor", "idx": 3474, "Desc": "creates a virtual machine descriptor from the given components . this convenience constructor works as if by invoking the three-argument constructor as follows : new virtualmachinedescriptor ( provider , id , id ); that is , it creates a virtual machine descriptor such that the display name is the same as the virtual machine identifier ."}{"node_name": "Main()", "type": "constructor", "idx": 3485, "Desc": ""}{"node_name": "JConsolePlugin()", "type": "constructor", "idx": 3506, "Desc": "constructor ."}{"node_name": "AccessibleApplet()", "type": "constructor", "idx": 3518, "Desc": ""}{"node_name": "AWTError(java.lang.String)", "type": "constructor", "idx": 3598, "Desc": "constructs an instance of awterror with the specified detail message ."}{"node_name": "AWTEvent(java.lang.Object,int)", "type": "constructor", "idx": 3623, "Desc": "constructs an awtevent object with the specified source object and type ."}{"node_name": "AWTEventMulticaster(java.util.EventListener,java.util.EventListener)", "type": "constructor", "idx": 3636, "Desc": "creates an event multicaster instance which chains listener-a with listener-b . input parameters a and b should not be null , though implementations may vary in choosing whether or not to throw nullpointerexception in that case ."}{"node_name": "AWTException(java.lang.String)", "type": "constructor", "idx": 3834, "Desc": "constructs an instance of awtexception with the specified detail message . a detail message is an instance of string that describes this particular exception ."}{"node_name": "AWTKeyStroke()", "type": "constructor", "idx": 3837, "Desc": "constructs an awtkeystroke with default values . the default values used are : awtkeystroke default values property default value key char keyevent.char_undefined key code keyevent.vk_undefined modifiers none on key release ? false awtkeystrokes should not be constructed by client code . use a variant of getawtkeystroke instead ."}{"node_name": "AWTKeyStroke(char,int,int,boolean)", "type": "constructor", "idx": 3838, "Desc": "constructs an awtkeystroke with the specified values . awtkeystrokes should not be constructed by client code . use a variant of getawtkeystroke instead ."}{"node_name": "AWTPermission(java.lang.String)", "type": "constructor", "idx": 3870, "Desc": "creates a new awtpermission with the specified name . the name is the symbolic name of the awtpermission , such as \" toplevelwindow \" , \" systemclipboard \" , etc . an asterisk may be used to indicate all awt permissions ."}{"node_name": "AWTPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 3872, "Desc": "creates a new awtpermission object with the specified name . the name is the symbolic name of the awtpermission , and the actions string is currently unused and should be null ."}{"node_name": "BasicStroke(float,int,int,float,float[],float)", "type": "constructor", "idx": 3882, "Desc": "constructs a new basicstroke with the specified attributes ."}{"node_name": "BasicStroke(float,int,int,float)", "type": "constructor", "idx": 3889, "Desc": "constructs a solid basicstroke with the specified attributes ."}{"node_name": "BasicStroke(float,int,int)", "type": "constructor", "idx": 3894, "Desc": "constructs a solid basicstroke with the specified attributes . the miterlimit parameter is unnecessary in cases where the default is allowable or the line joins are not specified as join_miter ."}{"node_name": "BasicStroke(float)", "type": "constructor", "idx": 3898, "Desc": "constructs a solid basicstroke with the specified line width and with default values for the cap and join styles ."}{"node_name": "BasicStroke()", "type": "constructor", "idx": 3900, "Desc": "constructs a new basicstroke with defaults for all attributes . the default attributes are a solid line of width 1.0 , cap_square , join_miter , a miter limit of 10.0 ."}{"node_name": "BorderLayout()", "type": "constructor", "idx": 3926, "Desc": "constructs a new border layout with no gaps between components ."}{"node_name": "BorderLayout(int,int)", "type": "constructor", "idx": 3927, "Desc": "constructs a border layout with the specified gaps between components . the horizontal gap is specified by hgap and the vertical gap is specified by vgap ."}{"node_name": "BufferCapabilities(java.awt.ImageCapabilities,java.awt.ImageCapabilities,java.awt.BufferCapabilities.FlipContents)", "type": "constructor", "idx": 3971, "Desc": "creates a new object for specifying buffering capabilities"}{"node_name": "AccessibleAWTButton()", "type": "constructor", "idx": 3983, "Desc": ""}{"node_name": "Button()", "type": "constructor", "idx": 3999, "Desc": "constructs a button with an empty string for its label ."}{"node_name": "Button(java.lang.String)", "type": "constructor", "idx": 4000, "Desc": "constructs a button with the specified label ."}{"node_name": "AccessibleAWTCanvas()", "type": "constructor", "idx": 4023, "Desc": ""}{"node_name": "Canvas()", "type": "constructor", "idx": 4026, "Desc": "constructs a new canvas ."}{"node_name": "Canvas(java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 4027, "Desc": "constructs a new canvas given a graphicsconfiguration object . if null is passed , then the default graphicsconfiguration will be used ."}{"node_name": "CardLayout()", "type": "constructor", "idx": 4042, "Desc": "creates a new card layout with gaps of size zero ."}{"node_name": "CardLayout(int,int)", "type": "constructor", "idx": 4043, "Desc": "creates a new card layout with the specified horizontal and vertical gaps . the horizontal gaps are placed at the left and right edges . the vertical gaps are placed at the top and bottom edges ."}{"node_name": "AccessibleAWTCheckbox()", "type": "constructor", "idx": 4084, "Desc": "constructor for accessibleawtcheckbox"}{"node_name": "Checkbox()", "type": "constructor", "idx": 4102, "Desc": "creates a check box with an empty string for its label . the state of this check box is set to \" off , \" and it is not part of any check box group ."}{"node_name": "Checkbox(java.lang.String)", "type": "constructor", "idx": 4103, "Desc": "creates a check box with the specified label . the state of this check box is set to \" off , \" and it is not part of any check box group ."}{"node_name": "Checkbox(java.lang.String,boolean)", "type": "constructor", "idx": 4105, "Desc": "creates a check box with the specified label and sets the specified state . this check box is not part of any check box group ."}{"node_name": "Checkbox(java.lang.String,boolean,java.awt.CheckboxGroup)", "type": "constructor", "idx": 4108, "Desc": "constructs a checkbox with the specified label , set to the specified state , and in the specified check box group ."}{"node_name": "Checkbox(java.lang.String,java.awt.CheckboxGroup,boolean)", "type": "constructor", "idx": 4112, "Desc": "creates a check box with the specified label , in the specified check box group , and set to the specified state ."}{"node_name": "CheckboxGroup()", "type": "constructor", "idx": 4141, "Desc": "creates a new instance of checkboxgroup ."}{"node_name": "AccessibleAWTCheckboxMenuItem()", "type": "constructor", "idx": 4147, "Desc": ""}{"node_name": "CheckboxMenuItem()", "type": "constructor", "idx": 4162, "Desc": "create a check box menu item with an empty label . the item's state is initially set to \" off . \""}{"node_name": "CheckboxMenuItem(java.lang.String)", "type": "constructor", "idx": 4163, "Desc": "create a check box menu item with the specified label . the item's state is initially set to \" off . \""}{"node_name": "CheckboxMenuItem(java.lang.String,boolean)", "type": "constructor", "idx": 4165, "Desc": "create a check box menu item with the specified label and state ."}{"node_name": "AccessibleAWTChoice()", "type": "constructor", "idx": 4187, "Desc": "constructor for accessibleawtchoice"}{"node_name": "Choice()", "type": "constructor", "idx": 4196, "Desc": "creates a new choice menu . the menu initially has no items in it . by default , the first item added to the choice menu becomes the selected item , until a different selection is made by the user by calling one of the select methods ."}{"node_name": "CMMException(java.lang.String)", "type": "constructor", "idx": 4234, "Desc": "constructs a cmmexception with the specified detail message ."}{"node_name": "ColorSpace(int,int)", "type": "constructor", "idx": 4267, "Desc": "constructs a colorspace object given a color space type and the number of components ."}{"node_name": "ICC_ColorSpace(java.awt.color.ICC_Profile)", "type": "constructor", "idx": 4290, "Desc": "constructs a new icc_colorspace from an icc_profile object ."}{"node_name": "Color(int,int,int)", "type": "constructor", "idx": 4491, "Desc": "creates an opaque srgb color with the specified red , green , and blue values in the range ( 0 - 255 ) . the actual color used in rendering depends on finding the best match given the color space available for a given output device . alpha is defaulted to 255 ."}{"node_name": "Color(int,int,int,int)", "type": "constructor", "idx": 4495, "Desc": "creates an srgb color with the specified red , green , blue , and alpha values in the range ( 0 - 255 ) ."}{"node_name": "Color(int)", "type": "constructor", "idx": 4500, "Desc": "creates an opaque srgb color with the specified combined rgb value consisting of the red component in bits 16-23 , the green component in bits 8-15 , and the blue component in bits 0-7 . the actual color used in rendering depends on finding the best match given the color space available for a particular output device . alpha is defaulted to 255 ."}{"node_name": "Color(int,boolean)", "type": "constructor", "idx": 4502, "Desc": "creates an srgb color with the specified combined rgba value consisting of the alpha component in bits 24-31 , the red component in bits 16-23 , the green component in bits 8-15 , and the blue component in bits 0-7 . if the hasalpha argument is false , alpha is defaulted to 255 ."}{"node_name": "Color(float,float,float)", "type": "constructor", "idx": 4505, "Desc": "creates an opaque srgb color with the specified red , green , and blue values in the range ( 0.0 - 1.0 ) . alpha is defaulted to 1.0 . the actual color used in rendering depends on finding the best match given the color space available for a particular output device ."}{"node_name": "Color(float,float,float,float)", "type": "constructor", "idx": 4509, "Desc": "creates an srgb color with the specified red , green , blue , and alpha values in the range ( 0.0 - 1.0 ) . the actual color used in rendering depends on finding the best match given the color space available for a particular output device ."}{"node_name": "Color(java.awt.color.ColorSpace,float[],float)", "type": "constructor", "idx": 4514, "Desc": "creates a color in the specified colorspace with the color components specified in the float array and the specified alpha . the number of components is determined by the type of the colorspace . for example , rgb requires 3 components , but cmyk requires 4 components ."}{"node_name": "ProfileDataException(java.lang.String)", "type": "constructor", "idx": 4575, "Desc": "constructs a profiledataexception with the specified detail message ."}{"node_name": "AccessibleAWTComponentHandler()", "type": "constructor", "idx": 4578, "Desc": ""}{"node_name": "AccessibleAWTFocusHandler()", "type": "constructor", "idx": 4580, "Desc": ""}{"node_name": "AccessibleAWTComponent()", "type": "constructor", "idx": 4584, "Desc": "though the class is abstract , this should be called by all sub-classes ."}{"node_name": "BltBufferStrategy(int,java.awt.BufferCapabilities)", "type": "constructor", "idx": 4651, "Desc": "creates a new blt buffer strategy around a component"}{"node_name": "FlipBufferStrategy(int,java.awt.BufferCapabilities)", "type": "constructor", "idx": 4669, "Desc": "creates a new flipping buffer strategy for this component . the component must be a canvas or window or applet ."}{"node_name": "Component()", "type": "constructor", "idx": 4693, "Desc": "constructs a new component . class component can be extended directly to create a lightweight component that does not utilize an opaque native window . a lightweight component must be hosted by a native container somewhere higher up in the component tree ( for example , by a frame object ) ."}{"node_name": "AccessibleContainerHandler()", "type": "constructor", "idx": 5075, "Desc": ""}{"node_name": "AccessibleAWTContainer()", "type": "constructor", "idx": 5078, "Desc": ""}{"node_name": "Container()", "type": "constructor", "idx": 5089, "Desc": "constructs a new container . containers can be extended directly , but are lightweight in this case and must be contained by a parent somewhere higher up in the component tree that is native . ( such as frame for example ) ."}{"node_name": "ContainerOrderFocusTraversalPolicy()", "type": "constructor", "idx": 5211, "Desc": ""}{"node_name": "Cursor(int)", "type": "constructor", "idx": 5246, "Desc": "creates a new cursor object with the specified type ."}{"node_name": "Cursor(java.lang.String)", "type": "constructor", "idx": 5248, "Desc": "creates a new custom cursor object with the specified name . note : <init>(java.lang.String) should only be used by awt implementations as part of their support for custom cursors . applications should use toolkit.createcustomcursor() ."}{"node_name": "Clipboard(java.lang.String)", "type": "constructor", "idx": 5261, "Desc": "creates a clipboard object ."}{"node_name": "DataFlavor()", "type": "constructor", "idx": 5293, "Desc": "constructs a new dataflavor . <init>() is provided only for the purpose of supporting the externalizable interface . it is not intended for public ( client ) use ."}{"node_name": "DataFlavor(java.lang.Class,java.lang.String)", "type": "constructor", "idx": 5294, "Desc": "constructs a dataflavor that represents a java class . the returned dataflavor will have the following characteristics : representationclass = representationclass mimetype = application / x-java-serialized-object"}{"node_name": "DataFlavor(java.lang.String,java.lang.String)", "type": "constructor", "idx": 5297, "Desc": "constructs a dataflavor that represents a mimetype . the returned dataflavor will have the following characteristics : if the mimetype is \" application / x-java-serialized-object ; class= < representation class > \" , the result is the same as calling new dataflavor ( class.forname ( < representation class > ) . otherwise : representationclass = inputstream mimetype = mimetype"}{"node_name": "DataFlavor(java.lang.String,java.lang.String,java.lang.ClassLoader)", "type": "constructor", "idx": 5300, "Desc": "constructs a dataflavor that represents a mimetype . the returned dataflavor will have the following characteristics : if the mimetype is \" application / x-java-serialized-object ; class= < representation class > \" , the result is the same as calling new dataflavor ( class.forname ( < representation class > ) . otherwise : representationclass = inputstream mimetype = mimetype"}{"node_name": "DataFlavor(java.lang.String)", "type": "constructor", "idx": 5304, "Desc": "constructs a dataflavor from a mimetype string . the string can specify a \" class= < fully specified java class name > \" parameter to create a dataflavor with the desired representation class . if the string does not contain \" class= \" parameter , java.io.inputstream is used as default ."}{"node_name": "FlavorEvent(java.awt.datatransfer.Clipboard)", "type": "constructor", "idx": 5354, "Desc": "constructs a flavorevent object ."}{"node_name": "MimeTypeParseException()", "type": "constructor", "idx": 5370, "Desc": "constructs a mimetypeparseexception with no specified detail message ."}{"node_name": "MimeTypeParseException(java.lang.String)", "type": "constructor", "idx": 5371, "Desc": "constructs a mimetypeparseexception with the specified detail message ."}{"node_name": "StringSelection(java.lang.String)", "type": "constructor", "idx": 5374, "Desc": "creates a transferable capable of transferring the specified string ."}{"node_name": "UnsupportedFlavorException(java.awt.datatransfer.DataFlavor)", "type": "constructor", "idx": 5420, "Desc": "constructs an unsupportedflavorexception ."}{"node_name": "DefaultFocusTraversalPolicy()", "type": "constructor", "idx": 5423, "Desc": ""}{"node_name": "DefaultKeyboardFocusManager()", "type": "constructor", "idx": 5427, "Desc": ""}{"node_name": "AboutEvent()", "type": "constructor", "idx": 5454, "Desc": "constructs an aboutevent ."}{"node_name": "AppForegroundEvent()", "type": "constructor", "idx": 5464, "Desc": "constructs an appforegroundevent ."}{"node_name": "AppHiddenEvent()", "type": "constructor", "idx": 5471, "Desc": "constructs an apphiddenevent ."}{"node_name": "AppReopenedEvent()", "type": "constructor", "idx": 5478, "Desc": "constructs an appreopenedevent ."}{"node_name": "OpenFilesEvent(java.util.List,java.lang.String)", "type": "constructor", "idx": 5530, "Desc": "constructs an openfilesevent ."}{"node_name": "OpenURIEvent(java.net.URI)", "type": "constructor", "idx": 5538, "Desc": "constructs an openurievent ."}{"node_name": "PreferencesEvent()", "type": "constructor", "idx": 5545, "Desc": "constructs a preferencesevent ."}{"node_name": "PrintFilesEvent(java.util.List)", "type": "constructor", "idx": 5550, "Desc": "constructs a printfilesevent ."}{"node_name": "QuitEvent()", "type": "constructor", "idx": 5556, "Desc": "constructs a quitevent ."}{"node_name": "ScreenSleepEvent()", "type": "constructor", "idx": 5569, "Desc": "constructs a screensleepevent ."}{"node_name": "SystemSleepEvent()", "type": "constructor", "idx": 5577, "Desc": "constructs a systemsleepevent ."}{"node_name": "UserSessionEvent(java.awt.desktop.UserSessionEvent.Reason)", "type": "constructor", "idx": 5584, "Desc": "constructs a usersessionevent ."}{"node_name": "AccessibleAWTDialog()", "type": "constructor", "idx": 5597, "Desc": ""}{"node_name": "Dialog(java.awt.Frame)", "type": "constructor", "idx": 5602, "Desc": "constructs an initially invisible , modeless dialog with the specified owner frame and an empty title ."}{"node_name": "Dialog(java.awt.Frame,boolean)", "type": "constructor", "idx": 5604, "Desc": "constructs an initially invisible dialog with the specified owner frame and modality and an empty title ."}{"node_name": "Dialog(java.awt.Frame,java.lang.String)", "type": "constructor", "idx": 5607, "Desc": "constructs an initially invisible , modeless dialog with the specified owner frame and title ."}{"node_name": "Dialog(java.awt.Frame,java.lang.String,boolean)", "type": "constructor", "idx": 5610, "Desc": "constructs an initially invisible dialog with the specified owner frame , title and modality ."}{"node_name": "Dialog(java.awt.Frame,java.lang.String,boolean,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 5614, "Desc": "constructs an initially invisible dialog with the specified owner frame , title , modality , and graphicsconfiguration ."}{"node_name": "Dialog(java.awt.Dialog)", "type": "constructor", "idx": 5619, "Desc": "constructs an initially invisible , modeless dialog with the specified owner dialog and an empty title ."}{"node_name": "Dialog(java.awt.Dialog,java.lang.String)", "type": "constructor", "idx": 5621, "Desc": "constructs an initially invisible , modeless dialog with the specified owner dialog and title ."}{"node_name": "Dialog(java.awt.Dialog,java.lang.String,boolean)", "type": "constructor", "idx": 5624, "Desc": "constructs an initially invisible dialog with the specified owner dialog , title , and modality ."}{"node_name": "Dialog(java.awt.Dialog,java.lang.String,boolean,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 5628, "Desc": "constructs an initially invisible dialog with the specified owner dialog , title , modality and graphicsconfiguration ."}{"node_name": "Dialog(java.awt.Window)", "type": "constructor", "idx": 5633, "Desc": "constructs an initially invisible , modeless dialog with the specified owner window and an empty title ."}{"node_name": "Dialog(java.awt.Window,java.lang.String)", "type": "constructor", "idx": 5635, "Desc": "constructs an initially invisible , modeless dialog with the specified owner window and title ."}{"node_name": "Dialog(java.awt.Window,java.awt.Dialog.ModalityType)", "type": "constructor", "idx": 5638, "Desc": "constructs an initially invisible dialog with the specified owner window and modality and an empty title ."}{"node_name": "Dialog(java.awt.Window,java.lang.String,java.awt.Dialog.ModalityType)", "type": "constructor", "idx": 5641, "Desc": "constructs an initially invisible dialog with the specified owner window , title and modality ."}{"node_name": "Dialog(java.awt.Window,java.lang.String,java.awt.Dialog.ModalityType,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 5645, "Desc": "constructs an initially invisible dialog with the specified owner window , title , modality and graphicsconfiguration ."}{"node_name": "Dimension()", "type": "constructor", "idx": 5682, "Desc": "creates an instance of dimension with a width of zero and a height of zero ."}{"node_name": "Dimension(java.awt.Dimension)", "type": "constructor", "idx": 5683, "Desc": "creates an instance of dimension whose width and height are the same as for the specified dimension ."}{"node_name": "Dimension(int,int)", "type": "constructor", "idx": 5685, "Desc": "constructs a dimension and initializes it to the specified width and specified height ."}{"node_name": "DisplayMode(int,int,int,int)", "type": "constructor", "idx": 5706, "Desc": "create a new display mode object with the supplied parameters ."}{"node_name": "DragGestureEvent(java.awt.dnd.DragGestureRecognizer,int,java.awt.Point,java.util.List)", "type": "constructor", "idx": 5729, "Desc": "constructs a draggestureevent object given by the draggesturerecognizer instance firing this event , an act parameter representing the user's preferred action , an ori parameter indicating the origin of the drag , and a list of events that comprise the gesture ( evs parameter ) ."}{"node_name": "DragGestureRecognizer(java.awt.dnd.DragSource,java.awt.Component,int,java.awt.dnd.DragGestureListener)", "type": "constructor", "idx": 5766, "Desc": "construct a new draggesturerecognizer given the dragsource to be used in this drag and drop operation , the component this draggesturerecognizer should \" observe \" for drag initiating gestures , the action ( s ) supported for this drag and drop operation , and the draggesturelistener to notify once a drag initiating gesture has been detected ."}{"node_name": "DragGestureRecognizer(java.awt.dnd.DragSource,java.awt.Component,int)", "type": "constructor", "idx": 5771, "Desc": "construct a new draggesturerecognizer given the dragsource to be used in this drag and drop operation , the component this draggesturerecognizer should \" observe \" for drag initiating gestures , and the action ( s ) supported for this drag and drop operation ."}{"node_name": "DragGestureRecognizer(java.awt.dnd.DragSource,java.awt.Component)", "type": "constructor", "idx": 5775, "Desc": "construct a new draggesturerecognizer given the dragsource to be used in this drag and drop operation , and the component this draggesturerecognizer should \" observe \" for drag initiating gestures ."}{"node_name": "DragGestureRecognizer(java.awt.dnd.DragSource)", "type": "constructor", "idx": 5778, "Desc": "construct a new draggesturerecognizer given the dragsource to be used in this drag and drop operation ."}{"node_name": "DragSource()", "type": "constructor", "idx": 5807, "Desc": "creates a new dragsource ."}{"node_name": "DragSourceAdapter()", "type": "constructor", "idx": 5867, "Desc": ""}{"node_name": "DragSourceContext(java.awt.dnd.DragGestureEvent,java.awt.Cursor,java.awt.Image,java.awt.Point,java.awt.datatransfer.Transferable,java.awt.dnd.DragSourceListener)", "type": "constructor", "idx": 5885, "Desc": "called from dragsource , <init>(java.awt.dnd.DragGestureEvent,java.awt.Cursor,java.awt.Image,java.awt.Point,java.awt.datatransfer.Transferable,java.awt.dnd.DragSourceListener) creates a new dragsourcecontext given the dragsourcecontextpeer for this drag , the draggestureevent that triggered the drag , the initial cursor to use for the drag , an ( optional ) image to display while the drag is taking place , the offset of the image origin from the hotspot at the instant of the triggering event , the transferable subject data , and the dragsourcelistener to use during the drag and drop operation . if dragsourcecontextpeer is null nullpointerexception is thrown . if draggestureevent is null nullpointerexception is thrown . if cursor is null no exception is thrown and the default drag cursor behavior is activated for this drag operation . if image is null no exception is thrown . if image is not null and the offset is null nullpointerexception is thrown . if transferable is null nullpointerexception is thrown . if dragsourcelistener is null no exception is thrown ."}{"node_name": "DragSourceDragEvent(java.awt.dnd.DragSourceContext,int,int,int)", "type": "constructor", "idx": 5922, "Desc": "constructs a dragsourcedragevent . this class is typically instantiated by the dragsourcecontextpeer rather than directly by client code . the coordinates for this dragsourcedragevent are not specified , so getlocation will return null for this event . the arguments dropaction and action should be one of dndconstants that represents a single action . the argument modifiers should be either a bitwise mask of old java.awt.event.inputevent . *_mask constants or a bitwise mask of extended java.awt.event.inputevent . *_down_mask constants . <init>(java.awt.dnd.DragSourceContext,int,int,int) does not throw any exception for invalid dropaction , action and modifiers ."}{"node_name": "DragSourceDragEvent(java.awt.dnd.DragSourceContext,int,int,int,int,int)", "type": "constructor", "idx": 5927, "Desc": "constructs a dragsourcedragevent given the specified dragsourcecontext , user drop action , target drop action , modifiers and coordinates . the arguments dropaction and action should be one of dndconstants that represents a single action . the argument modifiers should be either a bitwise mask of old java.awt.event.inputevent . *_mask constants or a bitwise mask of extended java.awt.event.inputevent . *_down_mask constants . <init>(java.awt.dnd.DragSourceContext,int,int,int,int,int) does not throw any exception for invalid dropaction , action and modifiers ."}{"node_name": "DragSourceDropEvent(java.awt.dnd.DragSourceContext,int,boolean)", "type": "constructor", "idx": 5940, "Desc": "construct a dragsourcedropevent for a drop , given the dragsourcecontext , the drop action , and a boolean indicating if the drop was successful . the coordinates for this dragsourcedropevent are not specified , so getlocation will return null for this event . the argument action should be one of dndconstants that represents a single action . <init>(java.awt.dnd.DragSourceContext,int,boolean) does not throw any exception for invalid action ."}{"node_name": "DragSourceDropEvent(java.awt.dnd.DragSourceContext,int,boolean,int,int)", "type": "constructor", "idx": 5944, "Desc": "construct a dragsourcedropevent for a drop , given the dragsourcecontext , the drop action , a boolean indicating if the drop was successful , and coordinates . the argument action should be one of dndconstants that represents a single action . <init>(java.awt.dnd.DragSourceContext,int,boolean,int,int) does not throw any exception for invalid action ."}{"node_name": "DragSourceDropEvent(java.awt.dnd.DragSourceContext)", "type": "constructor", "idx": 5950, "Desc": "construct a dragsourcedropevent for a drag that does not result in a drop . the coordinates for this dragsourcedropevent are not specified , so getlocation will return null for this event ."}{"node_name": "DragSourceEvent(java.awt.dnd.DragSourceContext)", "type": "constructor", "idx": 5955, "Desc": "construct a dragsourceevent given a specified dragsourcecontext . the coordinates for this dragsourceevent are not specified , so getlocation will return null for this event ."}{"node_name": "DragSourceEvent(java.awt.dnd.DragSourceContext,int,int)", "type": "constructor", "idx": 5957, "Desc": "construct a dragsourceevent given a specified dragsourcecontext , and coordinates of the cursor location ."}{"node_name": "DropTargetAutoScroller(java.awt.Component,java.awt.Point)", "type": "constructor", "idx": 5980, "Desc": "construct a droptargetautoscroller"}{"node_name": "DropTarget(java.awt.Component,int,java.awt.dnd.DropTargetListener,boolean,java.awt.datatransfer.FlavorMap)", "type": "constructor", "idx": 5989, "Desc": "creates a new droptarget given the component to associate itself with , an int representing the default acceptable action ( s ) to support , a droptargetlistener to handle event processing , a boolean indicating if the droptarget is currently accepting drops , and a flavormap to use ( or null for the default flavormap ) . the component will receive drops only if it is enabled ."}{"node_name": "DropTarget(java.awt.Component,int,java.awt.dnd.DropTargetListener,boolean)", "type": "constructor", "idx": 5995, "Desc": "creates a droptarget given the component to associate itself with , an int representing the default acceptable action ( s ) to support , a droptargetlistener to handle event processing , and a boolean indicating if the droptarget is currently accepting drops . the component will receive drops only if it is enabled ."}{"node_name": "DropTarget()", "type": "constructor", "idx": 6000, "Desc": "creates a droptarget ."}{"node_name": "DropTarget(java.awt.Component,java.awt.dnd.DropTargetListener)", "type": "constructor", "idx": 6001, "Desc": "creates a droptarget given the component to associate itself with , and the droptargetlistener to handle event processing . the component will receive drops only if it is enabled ."}{"node_name": "DropTarget(java.awt.Component,int,java.awt.dnd.DropTargetListener)", "type": "constructor", "idx": 6004, "Desc": "creates a droptarget given the component to associate itself with , an int representing the default acceptable action ( s ) to support , and a droptargetlistener to handle event processing . the component will receive drops only if it is enabled ."}{"node_name": "DropTargetAdapter()", "type": "constructor", "idx": 6047, "Desc": ""}{"node_name": "DropTargetDragEvent(java.awt.dnd.DropTargetContext,java.awt.Point,int,int)", "type": "constructor", "idx": 6087, "Desc": "construct a droptargetdragevent given the droptargetcontext for this operation , the location of the \" drag \" cursor's hotspot in the component's coordinates , the user drop action , and the source drop actions ."}{"node_name": "DropTargetDropEvent(java.awt.dnd.DropTargetContext,java.awt.Point,int,int)", "type": "constructor", "idx": 6104, "Desc": "construct a droptargetdropevent given the droptargetcontext for this operation , the location of the drag cursor's hotspot in the component's coordinates , the currently selected user drop action , and the current set of actions supported by the source . by default , <init>(java.awt.dnd.DropTargetContext,java.awt.Point,int,int) assumes that the target is not in the same virtual machine as the source ; that is , islocaltransfer() will return false ."}{"node_name": "DropTargetDropEvent(java.awt.dnd.DropTargetContext,java.awt.Point,int,int,boolean)", "type": "constructor", "idx": 6109, "Desc": "construct a droptargetevent given the droptargetcontext for this operation , the location of the drag cursor's hotspot in the component's coordinates , the currently selected user drop action , the current set of actions supported by the source , and a boolean indicating if the source is in the same jvm as the target ."}{"node_name": "DropTargetEvent(java.awt.dnd.DropTargetContext)", "type": "constructor", "idx": 6131, "Desc": "construct a droptargetevent object with the specified droptargetcontext ."}{"node_name": "InvalidDnDOperationException()", "type": "constructor", "idx": 6146, "Desc": "create a default exception"}{"node_name": "InvalidDnDOperationException(java.lang.String)", "type": "constructor", "idx": 6147, "Desc": "create an exception with its own descriptive message"}{"node_name": "MouseDragGestureRecognizer(java.awt.dnd.DragSource,java.awt.Component,int,java.awt.dnd.DragGestureListener)", "type": "constructor", "idx": 6150, "Desc": "construct a new mousedraggesturerecognizer given the dragsource for the component c , the component to observe , the action ( s ) permitted for this drag operation , and the draggesturelistener to notify when a drag gesture is detected ."}{"node_name": "MouseDragGestureRecognizer(java.awt.dnd.DragSource,java.awt.Component,int)", "type": "constructor", "idx": 6155, "Desc": "construct a new mousedraggesturerecognizer given the dragsource for the component c , the component to observe , and the action ( s ) permitted for this drag operation ."}{"node_name": "MouseDragGestureRecognizer(java.awt.dnd.DragSource,java.awt.Component)", "type": "constructor", "idx": 6159, "Desc": "construct a new mousedraggesturerecognizer given the dragsource for the component c , and the component to observe ."}{"node_name": "MouseDragGestureRecognizer(java.awt.dnd.DragSource)", "type": "constructor", "idx": 6162, "Desc": "construct a new mousedraggesturerecognizer given the dragsource for the component ."}{"node_name": "ActionEvent(java.lang.Object,int,java.lang.String)", "type": "constructor", "idx": 6188, "Desc": "constructs an actionevent object . this method throws an illegalargumentexception if source is null . a null command string is legal , but not recommended ."}{"node_name": "ActionEvent(java.lang.Object,int,java.lang.String,int)", "type": "constructor", "idx": 6192, "Desc": "constructs an actionevent object with modifier keys . this method throws an illegalargumentexception if source is null . a null command string is legal , but not recommended ."}{"node_name": "ActionEvent(java.lang.Object,int,java.lang.String,long,int)", "type": "constructor", "idx": 6197, "Desc": "constructs an actionevent object with the specified modifier keys and timestamp . this method throws an illegalargumentexception if source is null . a null command string is legal , but not recommended ."}{"node_name": "AdjustmentEvent(java.awt.Adjustable,int,int,int)", "type": "constructor", "idx": 6219, "Desc": "constructs an adjustmentevent object with the specified adjustable source , event type , adjustment type , and value . this method throws an illegalargumentexception if source is null ."}{"node_name": "AdjustmentEvent(java.awt.Adjustable,int,int,int,boolean)", "type": "constructor", "idx": 6224, "Desc": "constructs an adjustmentevent object with the specified adjustable source , event type , adjustment type , and value . this method throws an illegalargumentexception if source is null ."}{"node_name": "AWTEventListenerProxy(long,java.awt.event.AWTEventListener)", "type": "constructor", "idx": 6241, "Desc": "constructor which binds the awteventlistener to a specific event mask ."}{"node_name": "ComponentAdapter()", "type": "constructor", "idx": 6248, "Desc": ""}{"node_name": "ComponentEvent(java.awt.Component,int)", "type": "constructor", "idx": 6264, "Desc": "constructs a componentevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "ContainerAdapter()", "type": "constructor", "idx": 6279, "Desc": ""}{"node_name": "ContainerEvent(java.awt.Component,int,java.awt.Component)", "type": "constructor", "idx": 6289, "Desc": "constructs a containerevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "FocusAdapter()", "type": "constructor", "idx": 6302, "Desc": ""}{"node_name": "FocusEvent(java.awt.Component,int,boolean,java.awt.Component)", "type": "constructor", "idx": 6316, "Desc": "constructs a focusevent object with the specified temporary state , opposite component and the cause.unknown cause . the opposite component is the other component involved in this focus change . for a focus_gained event , this is the component that lost focus . for a focus_lost event , this is the component that gained focus . if this focus change occurs with a native application , with a java application in a different vm , or with no other component , then the opposite component is null . this method throws an illegalargumentexception if source is null ."}{"node_name": "FocusEvent(java.awt.Component,int,boolean,java.awt.Component,java.awt.event.FocusEvent.Cause)", "type": "constructor", "idx": 6321, "Desc": "constructs a focusevent object with the specified temporary state , opposite component and the cause . the opposite component is the other component involved in this focus change . for a focus_gained event , this is the component that lost focus . for a focus_lost event , this is the component that gained focus . if this focus change occurs with a native application , with a java application in a different vm , or with no other component , then the opposite component is null . this method throws an illegalargumentexception if source or cause is null ."}{"node_name": "FocusEvent(java.awt.Component,int,boolean)", "type": "constructor", "idx": 6327, "Desc": "constructs a focusevent object and identifies whether or not the change is temporary . this method throws an illegalargumentexception if source is null ."}{"node_name": "FocusEvent(java.awt.Component,int)", "type": "constructor", "idx": 6331, "Desc": "constructs a focusevent object and identifies it as a permanent change in focus . this method throws an illegalargumentexception if source is null ."}{"node_name": "HierarchyBoundsAdapter()", "type": "constructor", "idx": 6344, "Desc": ""}{"node_name": "HierarchyEvent(java.awt.Component,int,java.awt.Component,java.awt.Container)", "type": "constructor", "idx": 6363, "Desc": "constructs an hierarchyevent object to identify a change in the component hierarchy . this method throws an illegalargumentexception if source is null ."}{"node_name": "HierarchyEvent(java.awt.Component,int,java.awt.Component,java.awt.Container,long)", "type": "constructor", "idx": 6368, "Desc": "constructs an hierarchyevent object to identify a change in the component hierarchy . this method throws an illegalargumentexception if source is null ."}{"node_name": "InputMethodEvent(java.awt.Component,int,long,java.text.AttributedCharacterIterator,int,java.awt.font.TextHitInfo,java.awt.font.TextHitInfo)", "type": "constructor", "idx": 6409, "Desc": "constructs an inputmethodevent with the specified source component , type , time , text , caret , and visibleposition . the offsets of caret and visibleposition are relative to the current composed text ; that is , the composed text within text if this is an input_method_text_changed event , the composed text within the text of the preceding input_method_text_changed event otherwise . note that passing in an invalid id results in unspecified behavior . this method throws an illegalargumentexception if source is null ."}{"node_name": "InputMethodEvent(java.awt.Component,int,java.text.AttributedCharacterIterator,int,java.awt.font.TextHitInfo,java.awt.font.TextHitInfo)", "type": "constructor", "idx": 6417, "Desc": "constructs an inputmethodevent with the specified source component , type , text , caret , and visibleposition . the offsets of caret and visibleposition are relative to the current composed text ; that is , the composed text within text if this is an input_method_text_changed event , the composed text within the text of the preceding input_method_text_changed event otherwise . the time stamp for this event is initialized by invoking eventqueue.getmostrecenteventtime() . note that passing in an invalid id results in unspecified behavior . this method throws an illegalargumentexception if source is null ."}{"node_name": "InputMethodEvent(java.awt.Component,int,java.awt.font.TextHitInfo,java.awt.font.TextHitInfo)", "type": "constructor", "idx": 6424, "Desc": "constructs an inputmethodevent with the specified source component , type , caret , and visibleposition . the text is set to null , committedcharactercount to 0 . the offsets of caret and visibleposition are relative to the current composed text ; that is , the composed text within the text of the preceding input_method_text_changed event if the event being constructed as a caret_position_changed event . for an input_method_text_changed event without text , caret and visibleposition must be null . the time stamp for this event is initialized by invoking eventqueue.getmostrecenteventtime() . note that passing in an invalid id results in unspecified behavior . this method throws an illegalargumentexception if source is null ."}{"node_name": "InvocationEvent(java.lang.Object,java.lang.Runnable)", "type": "constructor", "idx": 6449, "Desc": "constructs an invocationevent with the specified source which will execute the runnable's run() method when dispatched . this is a convenience constructor . an invocation of the form invocationevent ( source , runnable ) behaves in exactly the same way as the invocation of invocationevent ( source , runnable , null , false ) . this method throws an illegalargumentexception if source is null ."}{"node_name": "InvocationEvent(java.lang.Object,java.lang.Runnable,java.lang.Object,boolean)", "type": "constructor", "idx": 6452, "Desc": "constructs an invocationevent with the specified source which will execute the runnable's run() method when dispatched . if notifier is non-null , notifyall() will be called on it immediately after run() has returned or thrown an exception . an invocation of the form invocationevent ( source , runnable , notifier , catchthrowables ) behaves in exactly the same way as the invocation of invocationevent ( source , invocationevent.invocation_default , runnable , notifier , catchthrowables ) . this method throws an illegalargumentexception if source is null ."}{"node_name": "InvocationEvent(java.lang.Object,java.lang.Runnable,java.lang.Runnable,boolean)", "type": "constructor", "idx": 6457, "Desc": "constructs an invocationevent with the specified source which will execute the runnable's run() method when dispatched . if listener is non-null , listener.run() will be called immediately after run has returned , thrown an exception or the event was disposed . this method throws an illegalargumentexception if source is null ."}{"node_name": "InvocationEvent(java.lang.Object,int,java.lang.Runnable,java.lang.Object,boolean)", "type": "constructor", "idx": 6462, "Desc": "constructs an invocationevent with the specified source and id which will execute the runnable's run() method when dispatched . if notifier is non-null , notifyall() will be called on it immediately after run() has returned or thrown an exception . this method throws an illegalargumentexception if source is null ."}{"node_name": "ItemEvent(java.awt.ItemSelectable,int,java.lang.Object,int)", "type": "constructor", "idx": 6480, "Desc": "constructs an itemevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "KeyAdapter()", "type": "constructor", "idx": 6494, "Desc": ""}{"node_name": "KeyEvent(java.awt.Component,int,long,int,int,char,int)", "type": "constructor", "idx": 6702, "Desc": "constructs a keyevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "KeyEvent(java.awt.Component,int,long,int,int,char)", "type": "constructor", "idx": 6710, "Desc": "constructs a keyevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "MouseAdapter()", "type": "constructor", "idx": 6739, "Desc": ""}{"node_name": "MouseEvent(java.awt.Component,int,long,int,int,int,int,boolean,int)", "type": "constructor", "idx": 6761, "Desc": "constructs a mouseevent object with the specified source component , type , time , modifiers , coordinates , click count , popuptrigger flag , and button number . creating an invalid event ( such as by using more than one of the old _masks , or modifier / button values which don't match ) results in unspecified behavior . an invocation of the form mouseevent ( source , id , when , modifiers , x , y , clickcount , popuptrigger , button ) behaves in exactly the same way as the invocation mouseevent ( source , id , when , modifiers , x , y , xabs , yabs , clickcount , popuptrigger , button ) where xabs and yabs defines as source's location on screen plus relative coordinates x and y . xabs and yabs are set to zero if the source is not showing . this method throws an illegalargumentexception if source is null ."}{"node_name": "MouseEvent(java.awt.Component,int,long,int,int,int,int,boolean)", "type": "constructor", "idx": 6771, "Desc": "constructs a mouseevent object with the specified source component , type , modifiers , coordinates , click count , and popuptrigger flag . an invocation of the form mouseevent ( source , id , when , modifiers , x , y , clickcount , popuptrigger ) behaves in exactly the same way as the invocation mouseevent ( source , id , when , modifiers , x , y , xabs , yabs , clickcount , popuptrigger , mouseevent.nobutton ) where xabs and yabs defines as source's location on screen plus relative coordinates x and y . xabs and yabs are set to zero if the source is not showing . this method throws an illegalargumentexception if source is null ."}{"node_name": "MouseEvent(java.awt.Component,int,long,int,int,int,int,int,int,boolean,int)", "type": "constructor", "idx": 6780, "Desc": "constructs a mouseevent object with the specified source component , type , time , modifiers , coordinates , absolute coordinates , click count , popuptrigger flag , and button number . creating an invalid event ( such as by using more than one of the old _masks , or modifier / button values which don't match ) results in unspecified behavior . even if inconsistent values for relative and absolute coordinates are passed to <init>(java.awt.Component,int,long,int,int,int,int,int,int,boolean,int) , the mouse event instance is still created and no exception is thrown . this method throws an illegalargumentexception if source is null ."}{"node_name": "MouseMotionAdapter()", "type": "constructor", "idx": 6819, "Desc": ""}{"node_name": "MouseWheelEvent(java.awt.Component,int,long,int,int,int,int,boolean,int,int,int)", "type": "constructor", "idx": 6832, "Desc": "constructs a mousewheelevent object with the specified source component , type , modifiers , coordinates , scroll type , scroll amount , and wheel rotation . absolute coordinates xabs and yabs are set to source's location on screen plus relative coordinates x and y . xabs and yabs are set to zero if the source is not showing . note that passing in an invalid id results in unspecified behavior . this method throws an illegalargumentexception if source is null ."}{"node_name": "MouseWheelEvent(java.awt.Component,int,long,int,int,int,int,int,int,boolean,int,int,int)", "type": "constructor", "idx": 6844, "Desc": "constructs a mousewheelevent object with the specified source component , type , modifiers , coordinates , absolute coordinates , scroll type , scroll amount , and wheel rotation . note that passing in an invalid id results in unspecified behavior . this method throws an illegalargumentexception if source is null . even if inconsistent values for relative and absolute coordinates are passed to <init>(java.awt.Component,int,long,int,int,int,int,int,int,boolean,int,int,int) , the mousewheelevent instance is still created and no exception is thrown ."}{"node_name": "MouseWheelEvent(java.awt.Component,int,long,int,int,int,int,int,int,boolean,int,int,int,double)", "type": "constructor", "idx": 6858, "Desc": "constructs a mousewheelevent object with the specified source component , type , modifiers , coordinates , absolute coordinates , scroll type , scroll amount , and wheel rotation . note that passing in an invalid id parameter results in unspecified behavior . this method throws an illegalargumentexception if source equals null . even if inconsistent values for relative and absolute coordinates are passed to <init>(java.awt.Component,int,long,int,int,int,int,int,int,boolean,int,int,int,double) , a mousewheelevent instance is still created and no exception is thrown ."}{"node_name": "PaintEvent(java.awt.Component,int,java.awt.Rectangle)", "type": "constructor", "idx": 6887, "Desc": "constructs a paintevent object with the specified source component and type . this method throws an illegalargumentexception if source is null ."}{"node_name": "TextEvent(java.lang.Object,int)", "type": "constructor", "idx": 6898, "Desc": "constructs a textevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "WindowAdapter()", "type": "constructor", "idx": 6906, "Desc": ""}{"node_name": "WindowEvent(java.awt.Window,int,java.awt.Window,int,int)", "type": "constructor", "idx": 6940, "Desc": "constructs a windowevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "WindowEvent(java.awt.Window,int,java.awt.Window)", "type": "constructor", "idx": 6946, "Desc": "constructs a windowevent object with the specified opposite window . the opposite window is the other window involved in this focus or activation change . for a window_activated or window_gained_focus event , this is the window that lost activation or focus . for a window_deactivated or window_lost_focus event , this is the window that gained activation or focus . if this focus change occurs with a native application , with a java application in a different vm , or with no other window , then the opposite window is null . this method throws an illegalargumentexception if source is null ."}{"node_name": "WindowEvent(java.awt.Window,int,int,int)", "type": "constructor", "idx": 6950, "Desc": "constructs a windowevent object with the specified previous and new window states . this method throws an illegalargumentexception if source is null ."}{"node_name": "WindowEvent(java.awt.Window,int)", "type": "constructor", "idx": 6955, "Desc": "constructs a windowevent object . this method throws an illegalargumentexception if source is null ."}{"node_name": "EventQueue()", "type": "constructor", "idx": 6987, "Desc": "initializes a new instance of eventqueue ."}{"node_name": "FileDialog(java.awt.Frame)", "type": "constructor", "idx": 7010, "Desc": "creates a file dialog for loading a file . the title of the file dialog is initially empty . this is a convenience method for filedialog ( parent , \"\" , load ) . note : some platforms may not support showing the user-specified title in a file dialog . in this situation , either no title will be displayed in the file dialog's title bar or , on some systems , the file dialog's title bar will not be displayed ."}{"node_name": "FileDialog(java.awt.Frame,java.lang.String)", "type": "constructor", "idx": 7012, "Desc": "creates a file dialog window with the specified title for loading a file . the files shown are those in the current directory . this is a convenience method for filedialog ( parent , title , load ) . note : some platforms may not support showing the user-specified title in a file dialog . in this situation , either no title will be displayed in the file dialog's title bar or , on some systems , the file dialog's title bar will not be displayed ."}{"node_name": "FileDialog(java.awt.Frame,java.lang.String,int)", "type": "constructor", "idx": 7015, "Desc": "creates a file dialog window with the specified title for loading or saving a file . if the value of mode is load , then the file dialog is finding a file to read , and the files shown are those in the current directory . if the value of mode is save , the file dialog is finding a place to write a file . note : some platforms may not support showing the user-specified title in a file dialog . in this situation , either no title will be displayed in the file dialog's title bar or , on some systems , the file dialog's title bar will not be displayed ."}{"node_name": "FileDialog(java.awt.Dialog)", "type": "constructor", "idx": 7019, "Desc": "creates a file dialog for loading a file . the title of the file dialog is initially empty . this is a convenience method for filedialog ( parent , \"\" , load ) . note : some platforms may not support showing the user-specified title in a file dialog . in this situation , either no title will be displayed in the file dialog's title bar or , on some systems , the file dialog's title bar will not be displayed ."}{"node_name": "FileDialog(java.awt.Dialog,java.lang.String)", "type": "constructor", "idx": 7021, "Desc": "creates a file dialog window with the specified title for loading a file . the files shown are those in the current directory . this is a convenience method for filedialog ( parent , title , load ) . note : some platforms may not support showing the user-specified title in a file dialog . in this situation , either no title will be displayed in the file dialog's title bar or , on some systems , the file dialog's title bar will not be displayed ."}{"node_name": "FileDialog(java.awt.Dialog,java.lang.String,int)", "type": "constructor", "idx": 7024, "Desc": "creates a file dialog window with the specified title for loading or saving a file . if the value of mode is load , then the file dialog is finding a file to read , and the files shown are those in the current directory . if the value of mode is save , the file dialog is finding a place to write a file . note : some platforms may not support showing the user-specified title in a file dialog . in this situation , either no title will be displayed in the file dialog's title bar or , on some systems , the file dialog's title bar will not be displayed ."}{"node_name": "FlowLayout()", "type": "constructor", "idx": 7054, "Desc": "constructs a new flowlayout with a centered alignment and a default 5-unit horizontal and vertical gap ."}{"node_name": "FlowLayout(int)", "type": "constructor", "idx": 7055, "Desc": "constructs a new flowlayout with the specified alignment and a default 5-unit horizontal and vertical gap . the value of the alignment argument must be one of flowlayout.left , flowlayout.right , flowlayout.center , flowlayout.leading , or flowlayout.trailing ."}{"node_name": "FlowLayout(int,int,int)", "type": "constructor", "idx": 7057, "Desc": "creates a new flow layout manager with the indicated alignment and the indicated horizontal and vertical gaps . the value of the alignment argument must be one of flowlayout.left , flowlayout.right , flowlayout.center , flowlayout.leading , or flowlayout.trailing ."}{"node_name": "FocusTraversalPolicy()", "type": "constructor", "idx": 7086, "Desc": ""}{"node_name": "FontRenderContext()", "type": "constructor", "idx": 7102, "Desc": "constructs a new fontrendercontext object ."}{"node_name": "FontRenderContext(java.awt.geom.AffineTransform,boolean,boolean)", "type": "constructor", "idx": 7103, "Desc": "constructs a fontrendercontext object from an optional affinetransform and two boolean values that determine if the newly constructed object has anti-aliasing or fractional metrics . in each case the boolean values true and false correspond to the rendering hint values on and off respectively . to specify other hint values , use <init>(java.awt.geom.AffineTransform,boolean,boolean) which specifies the rendering hint values as parameters : fontrendercontext ( affinetransform , object , object ) ."}{"node_name": "FontRenderContext(java.awt.geom.AffineTransform,java.lang.Object,java.lang.Object)", "type": "constructor", "idx": 7107, "Desc": "constructs a fontrendercontext object from an optional affinetransform and two object values that determine if the newly constructed object has anti-aliasing or fractional metrics ."}{"node_name": "GlyphJustificationInfo(float,boolean,int,float,float,boolean,int,float,float)", "type": "constructor", "idx": 7137, "Desc": "constructs information about the justification properties of a glyph ."}{"node_name": "GlyphMetrics(float,java.awt.geom.Rectangle2D,byte)", "type": "constructor", "idx": 7153, "Desc": "constructs a glyphmetrics object ."}{"node_name": "GlyphMetrics(boolean,float,float,java.awt.geom.Rectangle2D,byte)", "type": "constructor", "idx": 7157, "Desc": "constructs a glyphmetrics object ."}{"node_name": "GlyphVector()", "type": "constructor", "idx": 7181, "Desc": ""}{"node_name": "GraphicAttribute(int)", "type": "constructor", "idx": 7250, "Desc": "constructs a graphicattribute . subclasses use this to define the alignment of the graphic ."}{"node_name": "ImageGraphicAttribute(java.awt.Image,int)", "type": "constructor", "idx": 7265, "Desc": "constructs an imagegraphicattribute from the specified image . the origin is at ( 0 , 0 ) ."}{"node_name": "ImageGraphicAttribute(java.awt.Image,int,float,float)", "type": "constructor", "idx": 7268, "Desc": "constructs an imagegraphicattribute from the specified image . the point ( originx , originy ) in the image appears at the origin of the imagegraphicattribute within the text ."}{"node_name": "Font(java.lang.String,int,int)", "type": "constructor", "idx": 7304, "Desc": "creates a new font from the specified name , style and point size . the font name can be a font face name or a font family name . it is used together with the style to find an appropriate font face . when a font family name is specified , the style argument is used to select the most appropriate face from the family . when a font face name is specified , the face's style and the style argument are merged to locate the best matching font from the same family . for example if face name \" arial bold \" is specified with style font.italic , the font system looks for a face in the \" arial \" family that is bold and italic , and may associate the font instance with the physical font face \" arial bold italic \" . the style argument is merged with the specified face's style , not added or subtracted . this means , specifying a bold face and a bold style does not double-embolden the font , and specifying a bold face and a plain style does not lighten the font . if no face for the requested style can be found , the font system may apply algorithmic styling to achieve the desired style . for example , if italic is requested , but no italic face is available , glyphs from the plain face may be algorithmically obliqued ( slanted ) . font name lookup is case insensitive , using the case folding rules of the us locale . if the name parameter represents something other than a logical font , i.e. is interpreted as a physical font face or family , and this cannot be mapped by the implementation to a physical font or a compatible alternative , then the font system will map the font instance to \" dialog \" , such that for example , the family as reported by getfamily will be \" dialog \" ."}{"node_name": "Font(java.util.Map)", "type": "constructor", "idx": 7308, "Desc": "creates a new font with the specified attributes . only keys defined in textattribute are recognized . in addition the font attribute is not recognized by <init>(java.util.Map) ( see getavailableattributes() ) . only attributes that have values of valid types will affect the new font . if attributes is null , a new font is initialized with default values ."}{"node_name": "Font(java.awt.Font)", "type": "constructor", "idx": 7310, "Desc": "creates a new font from the specified font . <init>(java.awt.Font) is intended for use by subclasses ."}{"node_name": "LayoutPath()", "type": "constructor", "idx": 7449, "Desc": ""}{"node_name": "LineBreakMeasurer(java.text.AttributedCharacterIterator,java.awt.font.FontRenderContext)", "type": "constructor", "idx": 7458, "Desc": "constructs a linebreakmeasurer for the specified text ."}{"node_name": "LineBreakMeasurer(java.text.AttributedCharacterIterator,java.text.BreakIterator,java.awt.font.FontRenderContext)", "type": "constructor", "idx": 7461, "Desc": "constructs a linebreakmeasurer for the specified text ."}{"node_name": "LineMetrics()", "type": "constructor", "idx": 7487, "Desc": ""}{"node_name": "ShapeGraphicAttribute(java.awt.Shape,int,boolean)", "type": "constructor", "idx": 7644, "Desc": "constructs a shapegraphicattribute for the specified shape ."}{"node_name": "TextAttribute(java.lang.String)", "type": "constructor", "idx": 7719, "Desc": "constructs a textattribute with the specified name ."}{"node_name": "CaretPolicy()", "type": "constructor", "idx": 7744, "Desc": "constructs a caretpolicy ."}{"node_name": "TextLayout(java.lang.String,java.awt.Font,java.awt.font.FontRenderContext)", "type": "constructor", "idx": 7751, "Desc": "constructs a textlayout from a string and a font . all the text is styled using the specified font . the string must specify a single paragraph of text , because an entire paragraph is required for the bidirectional algorithm ."}{"node_name": "TextLayout(java.lang.String,java.util.Map,java.awt.font.FontRenderContext)", "type": "constructor", "idx": 7755, "Desc": "constructs a textlayout from a string and an attribute set . all the text is styled using the provided attributes . string must specify a single paragraph of text because an entire paragraph is required for the bidirectional algorithm ."}{"node_name": "TextLayout(java.text.AttributedCharacterIterator,java.awt.font.FontRenderContext)", "type": "constructor", "idx": 7759, "Desc": "constructs a textlayout from an iterator over styled text . the iterator must specify a single paragraph of text because an entire paragraph is required for the bidirectional algorithm ."}{"node_name": "TextMeasurer(java.text.AttributedCharacterIterator,java.awt.font.FontRenderContext)", "type": "constructor", "idx": 7860, "Desc": "constructs a textmeasurer from the source text . the source text should be a single entire paragraph ."}{"node_name": "TransformAttribute(java.awt.geom.AffineTransform)", "type": "constructor", "idx": 7880, "Desc": "wraps the specified transform . the transform is cloned and a reference to the clone is kept . the original transform is unchanged . if null is passed as the argument , <init>(java.awt.geom.AffineTransform) behaves as though it were the identity transform . ( note that it is preferable to use identity in this case . )"}{"node_name": "FontFormatException(java.lang.String)", "type": "constructor", "idx": 7888, "Desc": "report a fontformatexception for the reason specified ."}{"node_name": "FontMetrics(java.awt.Font)", "type": "constructor", "idx": 7892, "Desc": "creates a new fontmetrics object for finding out height and width information about the specified font and specific character glyphs in that font ."}{"node_name": "AccessibleAWTFrame()", "type": "constructor", "idx": 7959, "Desc": ""}{"node_name": "Frame()", "type": "constructor", "idx": 7968, "Desc": "constructs a new instance of frame that is initially invisible . the title of the frame is empty ."}{"node_name": "Frame(java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 7969, "Desc": "constructs a new , initially invisible frame with the specified graphicsconfiguration ."}{"node_name": "Frame(java.lang.String)", "type": "constructor", "idx": 7971, "Desc": "constructs a new , initially invisible frame object with the specified title ."}{"node_name": "Frame(java.lang.String,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 7973, "Desc": "constructs a new , initially invisible frame object with the specified title and a graphicsconfiguration ."}{"node_name": "AffineTransform()", "type": "constructor", "idx": 8016, "Desc": "constructs a new affinetransform representing the identity transformation ."}{"node_name": "AffineTransform(java.awt.geom.AffineTransform)", "type": "constructor", "idx": 8017, "Desc": "constructs a new affinetransform that is a copy of the specified affinetransform object ."}{"node_name": "AffineTransform(float,float,float,float,float,float)", "type": "constructor", "idx": 8019, "Desc": "constructs a new affinetransform from 6 floating point values representing the 6 specifiable entries of the 3x3 transformation matrix ."}{"node_name": "AffineTransform(float[])", "type": "constructor", "idx": 8026, "Desc": "constructs a new affinetransform from an array of floating point values representing either the 4 non-translation entries or the 6 specifiable entries of the 3x3 transformation matrix . the values are retrieved from the array as { m00 m10 m01 m11 [ m02 m12 ] } ."}{"node_name": "AffineTransform(double,double,double,double,double,double)", "type": "constructor", "idx": 8028, "Desc": "constructs a new affinetransform from 6 double precision values representing the 6 specifiable entries of the 3x3 transformation matrix ."}{"node_name": "AffineTransform(double[])", "type": "constructor", "idx": 8035, "Desc": "constructs a new affinetransform from an array of double precision values representing either the 4 non-translation entries or the 6 specifiable entries of the 3x3 transformation matrix . the values are retrieved from the array as { m00 m10 m01 m11 [ m02 m12 ] } ."}{"node_name": "Double()", "type": "constructor", "idx": 8216, "Desc": "constructs a new open arc , initialized to location ( 0 , 0 ) , size ( 0 , 0 ) , angular extents ( start = 0 , extent = 0 ) ."}{"node_name": "Double(int)", "type": "constructor", "idx": 8217, "Desc": "constructs a new arc , initialized to location ( 0 , 0 ) , size ( 0 , 0 ) , angular extents ( start = 0 , extent = 0 ) , and the specified closure type ."}{"node_name": "Double(double,double,double,double,double,double,int)", "type": "constructor", "idx": 8219, "Desc": "constructs a new arc , initialized to the specified location , size , angular extents , and closure type ."}{"node_name": "Double(java.awt.geom.Rectangle2D,double,double,int)", "type": "constructor", "idx": 8227, "Desc": "constructs a new arc , initialized to the specified location , size , angular extents , and closure type ."}{"node_name": "Float()", "type": "constructor", "idx": 8263, "Desc": "constructs a new open arc , initialized to location ( 0 , 0 ) , size ( 0 , 0 ) , angular extents ( start = 0 , extent = 0 ) ."}{"node_name": "Float(int)", "type": "constructor", "idx": 8264, "Desc": "constructs a new arc , initialized to location ( 0 , 0 ) , size ( 0 , 0 ) , angular extents ( start = 0 , extent = 0 ) , and the specified closure type ."}{"node_name": "Float(float,float,float,float,float,float,int)", "type": "constructor", "idx": 8266, "Desc": "constructs a new arc , initialized to the specified location , size , angular extents , and closure type ."}{"node_name": "Float(java.awt.geom.Rectangle2D,float,float,int)", "type": "constructor", "idx": 8274, "Desc": "constructs a new arc , initialized to the specified location , size , angular extents , and closure type ."}{"node_name": "Arc2D()", "type": "constructor", "idx": 8307, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below . <init>() creates an object with a default closure type of open . it is provided only to enable serialization of subclasses ."}{"node_name": "Arc2D(int)", "type": "constructor", "idx": 8308, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "Area()", "type": "constructor", "idx": 8398, "Desc": "default constructor which creates an empty area ."}{"node_name": "Area(java.awt.Shape)", "type": "constructor", "idx": 8399, "Desc": "the area class creates an area geometry from the specified shape object . the geometry is explicitly closed , if the shape is not already closed . the fill rule ( even-odd or winding ) specified by the geometry of the shape is used to determine the resulting enclosed area ."}{"node_name": "Double()", "type": "constructor", "idx": 8456, "Desc": "constructs and initializes a cubiccurve with coordinates ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ."}{"node_name": "Double(double,double,double,double,double,double,double,double)", "type": "constructor", "idx": 8457, "Desc": "constructs and initializes a cubiccurve2d from the specified double coordinates ."}{"node_name": "Float()", "type": "constructor", "idx": 8497, "Desc": "constructs and initializes a cubiccurve with coordinates ( 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ) ."}{"node_name": "Float(float,float,float,float,float,float,float,float)", "type": "constructor", "idx": 8498, "Desc": "constructs and initializes a cubiccurve2d from the specified float coordinates ."}{"node_name": "CubicCurve2D()", "type": "constructor", "idx": 8539, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "Dimension2D()", "type": "constructor", "idx": 8646, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "Double()", "type": "constructor", "idx": 8660, "Desc": "constructs a new ellipse2d , initialized to location ( 0 , 0 ) and size ( 0 , 0 ) ."}{"node_name": "Double(double,double,double,double)", "type": "constructor", "idx": 8661, "Desc": "constructs and initializes an ellipse2d from the specified coordinates ."}{"node_name": "Float()", "type": "constructor", "idx": 8682, "Desc": "constructs a new ellipse2d , initialized to location ( 0 , 0 ) and size ( 0 , 0 ) ."}{"node_name": "Float(float,float,float,float)", "type": "constructor", "idx": 8683, "Desc": "constructs and initializes an ellipse2d from the specified coordinates ."}{"node_name": "Ellipse2D()", "type": "constructor", "idx": 8705, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "FlatteningPathIterator(java.awt.geom.PathIterator,double)", "type": "constructor", "idx": 8725, "Desc": "constructs a new flatteningpathiterator object that flattens a path as it iterates over it . the iterator does not subdivide any curve read from the source iterator to more than 10 levels of subdivision which yields a maximum of 1024 line segments per curve ."}{"node_name": "FlatteningPathIterator(java.awt.geom.PathIterator,double,int)", "type": "constructor", "idx": 8728, "Desc": "constructs a new flatteningpathiterator object that flattens a path as it iterates over it . the limit parameter allows you to control the maximum number of recursive subdivisions that the iterator can make before it assumes that the curve is flat enough without measuring against the flatness parameter . the flattened iteration therefore never generates more than a maximum of ( 2^limit ) line segments per curve ."}{"node_name": "GeneralPath()", "type": "constructor", "idx": 8742, "Desc": "constructs a new empty single precision generalpath object with a default winding rule of path2d.wind_non_zero ."}{"node_name": "GeneralPath(int)", "type": "constructor", "idx": 8743, "Desc": "constructs a new generalpath object with the specified winding rule to control operations that require the interior of the path to be defined ."}{"node_name": "GeneralPath(int,int)", "type": "constructor", "idx": 8745, "Desc": "constructs a new generalpath object with the specified winding rule and the specified initial capacity to store path coordinates . this number is an initial guess as to how many path segments will be added to the path , but the storage is expanded as needed to store whatever path segments are added ."}{"node_name": "GeneralPath(java.awt.Shape)", "type": "constructor", "idx": 8748, "Desc": "constructs a new generalpath object from an arbitrary shape object . all of the initial geometry and the winding rule for this path are taken from the specified shape object ."}{"node_name": "IllegalPathStateException()", "type": "constructor", "idx": 8751, "Desc": "constructs an illegalpathstateexception with no detail message ."}{"node_name": "IllegalPathStateException(java.lang.String)", "type": "constructor", "idx": 8752, "Desc": "constructs an illegalpathstateexception with the specified detail message ."}{"node_name": "Double()", "type": "constructor", "idx": 8759, "Desc": "constructs and initializes a line with coordinates ( 0 , 0 ) \u2192 ( 0 , 0 ) ."}{"node_name": "Double(double,double,double,double)", "type": "constructor", "idx": 8760, "Desc": "constructs and initializes a line2d from the specified coordinates ."}{"node_name": "Double(java.awt.geom.Point2D,java.awt.geom.Point2D)", "type": "constructor", "idx": 8765, "Desc": "constructs and initializes a line2d from the specified point2d objects ."}{"node_name": "Float()", "type": "constructor", "idx": 8785, "Desc": "constructs and initializes a line with coordinates ( 0 , 0 ) \u2192 ( 0 , 0 ) ."}{"node_name": "Float(float,float,float,float)", "type": "constructor", "idx": 8786, "Desc": "constructs and initializes a line from the specified coordinates ."}{"node_name": "Float(java.awt.geom.Point2D,java.awt.geom.Point2D)", "type": "constructor", "idx": 8791, "Desc": "constructs and initializes a line2d from the specified point2d objects ."}{"node_name": "Line2D()", "type": "constructor", "idx": 8812, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessory methods below ."}{"node_name": "NoninvertibleTransformException(java.lang.String)", "type": "constructor", "idx": 8932, "Desc": "constructs an instance of noninvertibletransformexception with the specified detail message ."}{"node_name": "Double()", "type": "constructor", "idx": 8935, "Desc": "constructs a new empty double precision path2d object with a default winding rule of path2d.wind_non_zero ."}{"node_name": "Double(int)", "type": "constructor", "idx": 8936, "Desc": "constructs a new empty double precision path2d object with the specified winding rule to control operations that require the interior of the path to be defined ."}{"node_name": "Double(int,int)", "type": "constructor", "idx": 8938, "Desc": "constructs a new empty double precision path2d object with the specified winding rule and the specified initial capacity to store path segments . this number is an initial guess as to how many path segments are in the path , but the storage is expanded as needed to store whatever path segments are added to this path ."}{"node_name": "Double(java.awt.Shape)", "type": "constructor", "idx": 8941, "Desc": "constructs a new double precision path2d object from an arbitrary shape object . all of the initial geometry and the winding rule for this path are taken from the specified shape object ."}{"node_name": "Double(java.awt.Shape,java.awt.geom.AffineTransform)", "type": "constructor", "idx": 8943, "Desc": "constructs a new double precision path2d object from an arbitrary shape object , transformed by an affinetransform object . all of the initial geometry and the winding rule for this path are taken from the specified shape object and transformed by the specified affinetransform object ."}{"node_name": "Float()", "type": "constructor", "idx": 8974, "Desc": "constructs a new empty single precision path2d object with a default winding rule of path2d.wind_non_zero ."}{"node_name": "Float(int)", "type": "constructor", "idx": 8975, "Desc": "constructs a new empty single precision path2d object with the specified winding rule to control operations that require the interior of the path to be defined ."}{"node_name": "Float(int,int)", "type": "constructor", "idx": 8977, "Desc": "constructs a new empty single precision path2d object with the specified winding rule and the specified initial capacity to store path segments . this number is an initial guess as to how many path segments will be added to the path , but the storage is expanded as needed to store whatever path segments are added ."}{"node_name": "Float(java.awt.Shape)", "type": "constructor", "idx": 8980, "Desc": "constructs a new single precision path2d object from an arbitrary shape object . all of the initial geometry and the winding rule for this path are taken from the specified shape object ."}{"node_name": "Float(java.awt.Shape,java.awt.geom.AffineTransform)", "type": "constructor", "idx": 8982, "Desc": "constructs a new single precision path2d object from an arbitrary shape object , transformed by an affinetransform object . all of the initial geometry and the winding rule for this path are taken from the specified shape object and transformed by the specified affinetransform object ."}{"node_name": "Double()", "type": "constructor", "idx": 9135, "Desc": "constructs and initializes a point2d with coordinates ( 0 , 0 ) ."}{"node_name": "Double(double,double)", "type": "constructor", "idx": 9136, "Desc": "constructs and initializes a point2d with the specified coordinates ."}{"node_name": "Float()", "type": "constructor", "idx": 9148, "Desc": "constructs and initializes a point2d with coordinates ( 0 , 0 ) ."}{"node_name": "Float(float,float)", "type": "constructor", "idx": 9149, "Desc": "constructs and initializes a point2d with the specified coordinates ."}{"node_name": "Point2D()", "type": "constructor", "idx": 9162, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "Double()", "type": "constructor", "idx": 9201, "Desc": "constructs and initializes a quadcurve2d with coordinates ( 0 , 0 , 0 , 0 , 0 , 0 ) ."}{"node_name": "Double(double,double,double,double,double,double)", "type": "constructor", "idx": 9202, "Desc": "constructs and initializes a quadcurve2d from the specified double coordinates ."}{"node_name": "Float()", "type": "constructor", "idx": 9233, "Desc": "constructs and initializes a quadcurve2d with coordinates ( 0 , 0 , 0 , 0 , 0 , 0 ) ."}{"node_name": "Float(float,float,float,float,float,float)", "type": "constructor", "idx": 9234, "Desc": "constructs and initializes a quadcurve2d from the specified float coordinates ."}{"node_name": "QuadCurve2D()", "type": "constructor", "idx": 9266, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "Double()", "type": "constructor", "idx": 9367, "Desc": "constructs a new rectangle2d , initialized to location ( 0 , 0 ) and size ( 0 , 0 ) ."}{"node_name": "Double(double,double,double,double)", "type": "constructor", "idx": 9368, "Desc": "constructs and initializes a rectangle2d from the specified double coordinates ."}{"node_name": "Float()", "type": "constructor", "idx": 9399, "Desc": "constructs a new rectangle2d , initialized to location ( 0.0 , 0.0 ) and size ( 0.0 , 0.0 ) ."}{"node_name": "Float(float,float,float,float)", "type": "constructor", "idx": 9400, "Desc": "constructs and initializes a rectangle2d from the specified float coordinates ."}{"node_name": "Rectangle2D()", "type": "constructor", "idx": 9436, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "RectangularShape()", "type": "constructor", "idx": 9503, "Desc": "this is an abstract class that cannot be instantiated directly ."}{"node_name": "Double()", "type": "constructor", "idx": 9560, "Desc": "constructs a new roundrectangle2d , initialized to location ( 0.0 , 0.0 ) , size ( 0.0 , 0.0 ) , and corner arcs of radius 0.0 ."}{"node_name": "Double(double,double,double,double,double,double)", "type": "constructor", "idx": 9561, "Desc": "constructs and initializes a roundrectangle2d from the specified double coordinates ."}{"node_name": "Float()", "type": "constructor", "idx": 9592, "Desc": "constructs a new roundrectangle2d , initialized to location ( 0.0 , 0.0 ) , size ( 0.0 , 0.0 ) , and corner arcs of radius 0.0 ."}{"node_name": "Float(float,float,float,float,float,float)", "type": "constructor", "idx": 9593, "Desc": "constructs and initializes a roundrectangle2d from the specified float coordinates ."}{"node_name": "RoundRectangle2D()", "type": "constructor", "idx": 9625, "Desc": "this is an abstract class that cannot be instantiated directly . type-specific implementation subclasses are available for instantiation and provide a number of formats for storing the information necessary to satisfy the various accessor methods below ."}{"node_name": "GradientPaint(float,float,java.awt.Color,float,float,java.awt.Color)", "type": "constructor", "idx": 9661, "Desc": "constructs a simple acyclic gradientpaint object ."}{"node_name": "GradientPaint(java.awt.geom.Point2D,java.awt.Color,java.awt.geom.Point2D,java.awt.Color)", "type": "constructor", "idx": 9668, "Desc": "constructs a simple acyclic gradientpaint object ."}{"node_name": "GradientPaint(float,float,java.awt.Color,float,float,java.awt.Color,boolean)", "type": "constructor", "idx": 9673, "Desc": "constructs either a cyclic or acyclic gradientpaint object depending on the boolean parameter ."}{"node_name": "GradientPaint(java.awt.geom.Point2D,java.awt.Color,java.awt.geom.Point2D,java.awt.Color,boolean)", "type": "constructor", "idx": 9681, "Desc": "constructs either a cyclic or acyclic gradientpaint object depending on the boolean parameter ."}{"node_name": "Graphics()", "type": "constructor", "idx": 9700, "Desc": "constructs a new graphics object . <init>() is the default constructor for a graphics context . since graphics is an abstract class , applications cannot call <init>() directly . graphics contexts are obtained from other graphics contexts or are created by calling getgraphics on a component ."}{"node_name": "Graphics2D()", "type": "constructor", "idx": 9908, "Desc": "constructs a new graphics2d object . since graphics2d is an abstract class , and since it must be customized by subclasses for different output devices , graphics2d objects cannot be created directly . instead , graphics2d objects must be obtained from another graphics2d object , created by a component , or obtained from images such as bufferedimage objects ."}{"node_name": "GraphicsConfigTemplate()", "type": "constructor", "idx": 10017, "Desc": "this class is an abstract class so only subclasses can be instantiated ."}{"node_name": "GraphicsConfiguration()", "type": "constructor", "idx": 10023, "Desc": "this is an abstract class that cannot be instantiated directly . instances must be obtained from a suitable factory or query method ."}{"node_name": "GraphicsDevice()", "type": "constructor", "idx": 10061, "Desc": "this is an abstract class that cannot be instantiated directly . instances must be obtained from a suitable factory or query method ."}{"node_name": "GraphicsEnvironment()", "type": "constructor", "idx": 10085, "Desc": "this is an abstract class and cannot be instantiated directly . instances must be obtained from a suitable factory or query method ."}{"node_name": "GridBagConstraints()", "type": "constructor", "idx": 10147, "Desc": "creates a gridbagconstraint object with all of its fields set to their default value ."}{"node_name": "GridBagConstraints(int,int,int,int,double,double,int,int,java.awt.Insets,int,int)", "type": "constructor", "idx": 10148, "Desc": "creates a gridbagconstraints object with all of its fields set to the passed-in arguments . note : because the use of <init>(int,int,int,int,double,double,int,int,java.awt.Insets,int,int) hinders readability of source code , <init>(int,int,int,int,double,double,int,int,java.awt.Insets,int,int) should only be used by automatic source code generation tools ."}{"node_name": "GridBagLayout()", "type": "constructor", "idx": 10172, "Desc": "creates a grid bag layout manager ."}{"node_name": "GridLayout()", "type": "constructor", "idx": 10233, "Desc": "creates a grid layout with a default of one column per component , in a single row ."}{"node_name": "GridLayout(int,int)", "type": "constructor", "idx": 10234, "Desc": "creates a grid layout with the specified number of rows and columns . all components in the layout are given equal size . one , but not both , of rows and cols can be zero , which means that any number of objects can be placed in a row or in a column ."}{"node_name": "GridLayout(int,int,int,int)", "type": "constructor", "idx": 10237, "Desc": "creates a grid layout with the specified number of rows and columns . all components in the layout are given equal size . in addition , the horizontal and vertical gaps are set to the specified values . horizontal gaps are placed between each of the columns . vertical gaps are placed between each of the rows . one , but not both , of rows and cols can be zero , which means that any number of objects can be placed in a row or in a column . all gridlayout constructors defer to this one ."}{"node_name": "HeadlessException()", "type": "constructor", "idx": 10267, "Desc": "constructs new headlessexception with empty message . for such headlessexception the default headless error message may be auto-generated for some platforms . the text of the default headless message may depend on whether the graphicsenvironment is in fact headless . that is , the default headless message is both system and environmentally dependent ."}{"node_name": "HeadlessException(java.lang.String)", "type": "constructor", "idx": 10268, "Desc": "create a new instance with the specified detailed error message . for some platforms the default headless error message may be added at the end of the specified message . the text of the default headless message may depend on whether the graphicsenvironment is in fact headless . that is , the default headless message is both system and environmentally dependent ."}{"node_name": "IllegalComponentStateException()", "type": "constructor", "idx": 10272, "Desc": "constructs an illegalcomponentstateexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "IllegalComponentStateException(java.lang.String)", "type": "constructor", "idx": 10273, "Desc": "constructs an illegalcomponentstateexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InputContext()", "type": "constructor", "idx": 10276, "Desc": "constructs an inputcontext . this method is protected so clients cannot instantiate inputcontext directly . input contexts are obtained by calling getinstance() ."}{"node_name": "InputMethodHighlight(boolean,int)", "type": "constructor", "idx": 10301, "Desc": "constructs an input method highlight record . the variation is set to 0 , the style to null ."}{"node_name": "InputMethodHighlight(boolean,int,int)", "type": "constructor", "idx": 10304, "Desc": "constructs an input method highlight record . the style is set to null ."}{"node_name": "InputMethodHighlight(boolean,int,int,java.util.Map)", "type": "constructor", "idx": 10308, "Desc": "constructs an input method highlight record . the style attributes map provided must be unmodifiable ."}{"node_name": "AbstractMultiResolutionImage()", "type": "constructor", "idx": 10393, "Desc": ""}{"node_name": "AffineTransformOp(java.awt.geom.AffineTransform,java.awt.RenderingHints)", "type": "constructor", "idx": 10408, "Desc": "constructs an affinetransformop given an affine transform . the interpolation type is determined from the renderinghints object . if the interpolation hint is defined , it will be used . otherwise , if the rendering quality hint is defined , the interpolation type is determined from its value . if no hints are specified ( hints is null ) , the interpolation type is type_nearest_neighbor ."}{"node_name": "AffineTransformOp(java.awt.geom.AffineTransform,int)", "type": "constructor", "idx": 10411, "Desc": "constructs an affinetransformop given an affine transform and the interpolation type ."}{"node_name": "AreaAveragingScaleFilter(int,int)", "type": "constructor", "idx": 10436, "Desc": "constructs an areaaveragingscalefilter that scales the pixels from its source image as specified by the width and height parameters ."}{"node_name": "BandCombineOp(float[][],java.awt.RenderingHints)", "type": "constructor", "idx": 10460, "Desc": "constructs a bandcombineop with the specified matrix . the width of the matrix must be equal to the number of bands in the source raster , optionally plus one . if there is one more column in the matrix than the number of bands , there is an implied 1 at the end of the vector of band samples representing a pixel . the height of the matrix must be equal to the number of bands in the destination . the first subscript is the row index and the second is the column index . this operation uses none of the currently defined rendering hints ; the renderinghints argument can be null ."}{"node_name": "BandedSampleModel(int,int,int,int)", "type": "constructor", "idx": 10476, "Desc": "constructs a bandedsamplemodel with the specified parameters . the pixel stride will be one data element . the scanline stride will be the same as the width . each band will be stored in a separate bank and all band offsets will be zero ."}{"node_name": "BandedSampleModel(int,int,int,int,int[],int[])", "type": "constructor", "idx": 10481, "Desc": "constructs a bandedsamplemodel with the specified parameters . the number of bands will be inferred from the lengths of the bandoffsets bankindices arrays , which must be equal . the pixel stride will be one data element ."}{"node_name": "BaseMultiResolutionImage(java.awt.Image...)", "type": "constructor", "idx": 10578, "Desc": "creates a multi-resolution image with the given resolution variants . the first resolution variant is used as the base image ."}{"node_name": "BaseMultiResolutionImage(int,java.awt.Image...)", "type": "constructor", "idx": 10580, "Desc": "creates a multi-resolution image with the given base image index and resolution variants ."}{"node_name": "BufferedImage(int,int,int)", "type": "constructor", "idx": 10598, "Desc": "constructs a bufferedimage of one of the predefined image types . the colorspace for the image is the default srgb space ."}{"node_name": "BufferedImage(int,int,int,java.awt.image.IndexColorModel)", "type": "constructor", "idx": 10602, "Desc": "constructs a bufferedimage of one of the predefined image types : type_byte_binary or type_byte_indexed . if the image type is type_byte_binary , the number of entries in the color model is used to determine whether the image should have 1 , 2 , or 4 bits per pixel . if the color model has 1 or 2 entries , the image will have 1 bit per pixel . if it has 3 or 4 entries , the image with have 2 bits per pixel . if it has between 5 and 16 entries , the image will have 4 bits per pixel . otherwise , an illegalargumentexception will be thrown ."}{"node_name": "BufferedImage(java.awt.image.ColorModel,java.awt.image.WritableRaster,boolean,java.util.Hashtable)", "type": "constructor", "idx": 10607, "Desc": "constructs a new bufferedimage with a specified colormodel and raster . if the number and types of bands in the samplemodel of the raster do not match the number and types required by the colormodel to represent its color and alpha components , a rasterformatexception is thrown . this method can multiply or divide the color raster data by alpha to match the alphapremultiplied state in the colormodel . properties for this bufferedimage can be established by passing in a hashtable of string / object pairs ."}{"node_name": "BufferedImageFilter(java.awt.image.BufferedImageOp)", "type": "constructor", "idx": 10702, "Desc": "constructs a bufferedimagefilter with the specified single-source / single-destination operator ."}{"node_name": "BufferStrategy()", "type": "constructor", "idx": 10744, "Desc": ""}{"node_name": "ByteLookupTable(int,byte[][])", "type": "constructor", "idx": 10752, "Desc": "constructs a bytelookuptable object from an array of byte arrays representing a lookup table for each band . the offset will be subtracted from input values before indexing into the arrays . the number of bands is the length of the data argument . the data array for each band is stored as a reference ."}{"node_name": "ByteLookupTable(int,byte[])", "type": "constructor", "idx": 10755, "Desc": "constructs a bytelookuptable object from an array of bytes representing a lookup table to be applied to all bands . the offset will be subtracted from input values before indexing into the array . the data array is stored as a reference ."}{"node_name": "ColorConvertOp(java.awt.RenderingHints)", "type": "constructor", "idx": 10766, "Desc": "constructs a new colorconvertop which will convert from a source color space to a destination color space . the renderinghints argument may be null . this op can be used only with bufferedimages , and will convert directly from the colorspace of the source image to that of the destination . the destination argument of the filter method cannot be specified as null ."}{"node_name": "ColorConvertOp(java.awt.color.ColorSpace,java.awt.RenderingHints)", "type": "constructor", "idx": 10768, "Desc": "constructs a new colorconvertop from a colorspace object . the renderinghints argument may be null . this op can be used only with bufferedimages , and is primarily useful when the filter method is invoked with a destination argument of null . in that case , the colorspace defines the destination color space for the destination created by the filter method . otherwise , the colorspace defines an intermediate space to which the source is converted before being converted to the destination space ."}{"node_name": "ColorConvertOp(java.awt.color.ColorSpace,java.awt.color.ColorSpace,java.awt.RenderingHints)", "type": "constructor", "idx": 10771, "Desc": "constructs a new colorconvertop from two colorspace objects . the renderinghints argument may be null . this op is primarily useful for calling the filter method on rasters , in which case the two colorspaces define the operation to be performed on the rasters . in that case , the number of bands in the source raster must match the number of components in srccspace , and the number of bands in the destination raster must match the number of components in dstcspace . for bufferedimages , the two colorspaces define intermediate spaces through which the source is converted before being converted to the destination space ."}{"node_name": "ColorConvertOp(java.awt.color.ICC_Profile[],java.awt.RenderingHints)", "type": "constructor", "idx": 10775, "Desc": "constructs a new colorconvertop from an array of icc_profiles . the renderinghints argument may be null . the sequence of profiles may include profiles that represent color spaces , profiles that represent effects , etc . if the whole sequence does not represent a well-defined color conversion , an exception is thrown . for bufferedimages , if the colorspace of the source bufferedimage does not match the requirements of the first profile in the array , the first conversion is to an appropriate colorspace . if the requirements of the last profile in the array are not met by the colorspace of the destination bufferedimage , the last conversion is to the destination's colorspace . for rasters , the number of bands in the source raster must match the requirements of the first profile in the array , and the number of bands in the destination raster must match the requirements of the last profile in the array . the array must have at least two elements or calling the filter method for rasters will throw an illegalargumentexception ."}{"node_name": "ColorModel(int)", "type": "constructor", "idx": 10801, "Desc": "constructs a colormodel that translates pixels of the specified number of bits to color / alpha components . the color space is the default rgb colorspace , which is srgb . pixel values are assumed to include alpha information . if color and alpha information are represented in the pixel value as separate spatial bands , the color bands are assumed not to be premultiplied with the alpha value . the transparency type is java.awt.transparency.translucent . the transfer type will be the smallest of databuffer.type_byte , databuffer.type_ushort , or databuffer.type_int that can hold a single pixel ( or databuffer.type_undefined if bits is greater than 32 ) . since <init>(int) has no information about the number of bits per color and alpha component , any subclass calling <init>(int) should override any method that requires this information ."}{"node_name": "ColorModel(int,int[],java.awt.color.ColorSpace,boolean,boolean,int,int)", "type": "constructor", "idx": 10803, "Desc": "constructs a colormodel that translates pixel values to color / alpha components . color components will be in the specified colorspace . pixel_bits is the number of bits in the pixel values . the bits array specifies the number of significant bits per color and alpha component . its length should be the number of components in the colorspace if there is no alpha information in the pixel values , or one more than this number if there is alpha information . hasalpha indicates whether or not alpha information is present . the boolean isalphapremultiplied specifies how to interpret pixel values in which color and alpha information are represented as separate spatial bands . if the boolean is true , color samples are assumed to have been multiplied by the alpha sample . the transparency specifies what alpha values can be represented by this color model . the transfer type is the type of primitive array used to represent pixel values . note that the bits array contains the number of significant bits per color / alpha component after the translation from pixel values . for example , for an indexcolormodel with pixel_bits equal to 16 , the bits array might have four elements with each element set to 8 ."}{"node_name": "ComponentColorModel(java.awt.color.ColorSpace,int[],boolean,boolean,int,int)", "type": "constructor", "idx": 10902, "Desc": "constructs a componentcolormodel from the specified parameters . color components will be in the specified colorspace . the supported transfer types are databuffer.type_byte , databuffer.type_ushort , databuffer.type_int , databuffer.type_short , databuffer.type_float , and databuffer.type_double . if not null , the bits array specifies the number of significant bits per color and alpha component and its length should be at least the number of components in the colorspace if there is no alpha information in the pixel values , or one more than this number if there is alpha information . when the transfertype is databuffer.type_short , databuffer.type_float , or databuffer.type_double the bits array argument is ignored . hasalpha indicates whether alpha information is present . if hasalpha is true , then the boolean isalphapremultiplied specifies how to interpret color and alpha samples in pixel values . if the boolean is true , color samples are assumed to have been multiplied by the alpha sample . the transparency specifies what alpha values can be represented by this color model . the acceptable transparency values are opaque , bitmask or translucent . the transfertype is the type of primitive array used to represent pixel values ."}{"node_name": "ComponentColorModel(java.awt.color.ColorSpace,boolean,boolean,int,int)", "type": "constructor", "idx": 10909, "Desc": "constructs a componentcolormodel from the specified parameters . color components will be in the specified colorspace . the supported transfer types are databuffer.type_byte , databuffer.type_ushort , databuffer.type_int , databuffer.type_short , databuffer.type_float , and databuffer.type_double . the number of significant bits per color and alpha component will be 8 , 16 , 32 , 16 , 32 , or 64 , respectively . the number of color components will be the number of components in the colorspace . there will be an alpha component if hasalpha is true . if hasalpha is true , then the boolean isalphapremultiplied specifies how to interpret color and alpha samples in pixel values . if the boolean is true , color samples are assumed to have been multiplied by the alpha sample . the transparency specifies what alpha values can be represented by this color model . the acceptable transparency values are opaque , bitmask or translucent . the transfertype is the type of primitive array used to represent pixel values ."}{"node_name": "ComponentSampleModel(int,int,int,int,int,int[])", "type": "constructor", "idx": 10999, "Desc": "constructs a componentsamplemodel with the specified parameters . the number of bands will be given by the length of the bandoffsets array . all bands will be stored in the first bank of the databuffer ."}{"node_name": "ComponentSampleModel(int,int,int,int,int,int[],int[])", "type": "constructor", "idx": 11006, "Desc": "constructs a componentsamplemodel with the specified parameters . the number of bands will be given by the length of the bandoffsets array . different bands may be stored in different banks of the databuffer ."}{"node_name": "ConvolveOp(java.awt.image.Kernel,int,java.awt.RenderingHints)", "type": "constructor", "idx": 11121, "Desc": "constructs a convolveop given a kernel , an edge condition , and a renderinghints object ( which may be null ) ."}{"node_name": "ConvolveOp(java.awt.image.Kernel)", "type": "constructor", "idx": 11125, "Desc": "constructs a convolveop given a kernel . the edge condition will be edge_zero_fill ."}{"node_name": "CropImageFilter(int,int,int,int)", "type": "constructor", "idx": 11149, "Desc": "constructs a cropimagefilter that extracts the absolute rectangular region of pixels from its source image as specified by the x , y , w , and h parameters ."}{"node_name": "DataBuffer(int,int)", "type": "constructor", "idx": 11190, "Desc": "constructs a databuffer containing one bank of the specified data type and size ."}{"node_name": "DataBuffer(int,int,int)", "type": "constructor", "idx": 11193, "Desc": "constructs a databuffer containing the specified number of banks . each bank has the specified size and an offset of 0 ."}{"node_name": "DataBuffer(int,int,int,int)", "type": "constructor", "idx": 11197, "Desc": "constructs a databuffer that contains the specified number of banks . each bank has the specified datatype , size and offset ."}{"node_name": "DataBuffer(int,int,int,int[])", "type": "constructor", "idx": 11202, "Desc": "constructs a databuffer which contains the specified number of banks . each bank has the specified datatype and size . the offset for each bank is specified by its respective entry in the offsets array ."}{"node_name": "DataBufferByte(int)", "type": "constructor", "idx": 11251, "Desc": "constructs a byte-based databuffer with a single bank and the specified size ."}{"node_name": "DataBufferByte(int,int)", "type": "constructor", "idx": 11253, "Desc": "constructs a byte based databuffer with the specified number of banks all of which are the specified size ."}{"node_name": "DataBufferByte(byte[],int)", "type": "constructor", "idx": 11256, "Desc": "constructs a byte-based databuffer with a single bank using the specified array . only the first size elements should be used by accessors of this databuffer . dataarray must be large enough to hold size elements . note that databuffer objects created by <init>(byte[],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferByte(byte[],int,int)", "type": "constructor", "idx": 11259, "Desc": "constructs a byte-based databuffer with a single bank using the specified array , size , and offset . dataarray must have at least offset + size elements . only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(byte[],int,int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferByte(byte[][],int)", "type": "constructor", "idx": 11263, "Desc": "constructs a byte-based databuffer with the specified arrays . the number of banks is equal to dataarray.length . only the first size elements of each array should be used by accessors of this databuffer . note that databuffer objects created by <init>(byte[][],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferByte(byte[][],int,int[])", "type": "constructor", "idx": 11266, "Desc": "constructs a byte-based databuffer with the specified arrays , size , and offsets . the number of banks is equal to dataarray.length . each array must be at least as large as size + the corresponding offset . there must be an entry in the offset array for each dataarray entry . for each bank , only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(byte[][],int,int[]) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferDouble(int)", "type": "constructor", "idx": 11287, "Desc": "constructs a double-based databuffer with a specified size ."}{"node_name": "DataBufferDouble(int,int)", "type": "constructor", "idx": 11289, "Desc": "constructs a double-based databuffer with a specified number of banks , all of which are of a specified size ."}{"node_name": "DataBufferDouble(double[],int)", "type": "constructor", "idx": 11292, "Desc": "constructs a double-based databuffer with the specified data array . only the first size elements are available for use by this databuffer . the array must be large enough to hold size elements . note that databuffer objects created by <init>(double[],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferDouble(double[],int,int)", "type": "constructor", "idx": 11295, "Desc": "constructs a double-based databuffer with the specified data array . only the elements between offset and offset + size - 1 are available for use by this databuffer . the array must be large enough to hold offset + size elements . note that databuffer objects created by <init>(double[],int,int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferDouble(double[][],int)", "type": "constructor", "idx": 11299, "Desc": "constructs a double-based databuffer with the specified data arrays . only the first size elements of each array are available for use by this databuffer . the number of banks will be equal to dataarray.length . note that databuffer objects created by <init>(double[][],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferDouble(double[][],int,int[])", "type": "constructor", "idx": 11302, "Desc": "constructs a double-based databuffer with the specified data arrays , size , and per-bank offsets . the number of banks is equal to dataarray.length . each array must be at least as large as size plus the corresponding offset . there must be an entry in the offsets array for each data array . note that databuffer objects created by <init>(double[][],int,int[]) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferFloat(int)", "type": "constructor", "idx": 11347, "Desc": "constructs a float-based databuffer with a specified size ."}{"node_name": "DataBufferFloat(int,int)", "type": "constructor", "idx": 11349, "Desc": "constructs a float-based databuffer with a specified number of banks , all of which are of a specified size ."}{"node_name": "DataBufferFloat(float[],int)", "type": "constructor", "idx": 11352, "Desc": "constructs a float-based databuffer with the specified data array . only the first size elements are available for use by this databuffer . the array must be large enough to hold size elements . note that databuffer objects created by <init>(float[],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferFloat(float[],int,int)", "type": "constructor", "idx": 11355, "Desc": "constructs a float-based databuffer with the specified data array . only the elements between offset and offset + size - 1 are available for use by this databuffer . the array must be large enough to hold offset + size elements . note that databuffer objects created by <init>(float[],int,int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferFloat(float[][],int)", "type": "constructor", "idx": 11359, "Desc": "constructs a float-based databuffer with the specified data arrays . only the first size elements of each array are available for use by this databuffer . the number of banks will be equal to dataarray.length . note that databuffer objects created by <init>(float[][],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferFloat(float[][],int,int[])", "type": "constructor", "idx": 11362, "Desc": "constructs a float-based databuffer with the specified data arrays , size , and per-bank offsets . the number of banks is equal to dataarray.length . each array must be at least as large as size plus the corresponding offset . there must be an entry in the offsets array for each data array . note that databuffer objects created by <init>(float[][],int,int[]) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferInt(int)", "type": "constructor", "idx": 11407, "Desc": "constructs an integer-based databuffer with a single bank and the specified size ."}{"node_name": "DataBufferInt(int,int)", "type": "constructor", "idx": 11409, "Desc": "constructs an integer-based databuffer with the specified number of banks , all of which are the specified size ."}{"node_name": "DataBufferInt(int[],int)", "type": "constructor", "idx": 11412, "Desc": "constructs an integer-based databuffer with a single bank using the specified array . only the first size elements should be used by accessors of this databuffer . dataarray must be large enough to hold size elements . note that databuffer objects created by <init>(int[],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferInt(int[],int,int)", "type": "constructor", "idx": 11415, "Desc": "constructs an integer-based databuffer with a single bank using the specified array , size , and offset . dataarray must have at least offset + size elements . only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(int[],int,int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferInt(int[][],int)", "type": "constructor", "idx": 11419, "Desc": "constructs an integer-based databuffer with the specified arrays . the number of banks will be equal to dataarray.length . only the first size elements of each array should be used by accessors of this databuffer . note that databuffer objects created by <init>(int[][],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferInt(int[][],int,int[])", "type": "constructor", "idx": 11422, "Desc": "constructs an integer-based databuffer with the specified arrays , size , and offsets . the number of banks is equal to dataarray.length . each array must be at least as large as size + the corresponding offset . there must be an entry in the offset array for each dataarray entry . for each bank , only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(int[][],int,int[]) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferShort(int)", "type": "constructor", "idx": 11443, "Desc": "constructs a short-based databuffer with a single bank and the specified size ."}{"node_name": "DataBufferShort(int,int)", "type": "constructor", "idx": 11445, "Desc": "constructs a short-based databuffer with the specified number of banks all of which are the specified size ."}{"node_name": "DataBufferShort(short[],int)", "type": "constructor", "idx": 11448, "Desc": "constructs a short-based databuffer with a single bank using the specified array . only the first size elements should be used by accessors of this databuffer . dataarray must be large enough to hold size elements . note that databuffer objects created by <init>(short[],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferShort(short[],int,int)", "type": "constructor", "idx": 11451, "Desc": "constructs a short-based databuffer with a single bank using the specified array , size , and offset . dataarray must have at least offset + size elements . only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(short[],int,int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferShort(short[][],int)", "type": "constructor", "idx": 11455, "Desc": "constructs a short-based databuffer with the specified arrays . the number of banks will be equal to dataarray.length . only the first size elements of each array should be used by accessors of this databuffer . note that databuffer objects created by <init>(short[][],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferShort(short[][],int,int[])", "type": "constructor", "idx": 11458, "Desc": "constructs a short-based databuffer with the specified arrays , size , and offsets . the number of banks is equal to dataarray.length . each array must be at least as large as size + the corresponding offset . there must be an entry in the offset array for each dataarray entry . for each bank , only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(short[][],int,int[]) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferUShort(int)", "type": "constructor", "idx": 11479, "Desc": "constructs an unsigned-short based databuffer with a single bank and the specified size ."}{"node_name": "DataBufferUShort(int,int)", "type": "constructor", "idx": 11481, "Desc": "constructs an unsigned-short based databuffer with the specified number of banks , all of which are the specified size ."}{"node_name": "DataBufferUShort(short[],int)", "type": "constructor", "idx": 11484, "Desc": "constructs an unsigned-short based databuffer with a single bank using the specified array . only the first size elements should be used by accessors of this databuffer . dataarray must be large enough to hold size elements . note that databuffer objects created by <init>(short[],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferUShort(short[],int,int)", "type": "constructor", "idx": 11487, "Desc": "constructs an unsigned-short based databuffer with a single bank using the specified array , size , and offset . dataarray must have at least offset + size elements . only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(short[],int,int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferUShort(short[][],int)", "type": "constructor", "idx": 11491, "Desc": "constructs an unsigned-short based databuffer with the specified arrays . the number of banks will be equal to dataarray.length . only the first size elements of each array should be used by accessors of this databuffer . note that databuffer objects created by <init>(short[][],int) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DataBufferUShort(short[][],int,int[])", "type": "constructor", "idx": 11494, "Desc": "constructs an unsigned-short based databuffer with specified arrays , size , and offsets . the number of banks is equal to dataarray.length . each array must be at least as large as size + the corresponding offset . there must be an entry in the offset array for each dataarray entry . for each bank , only elements offset through offset + size - 1 should be used by accessors of this databuffer . note that databuffer objects created by <init>(short[][],int,int[]) may be incompatible with performance optimizations used by some implementations ( such as caching an associated image in video memory ) ."}{"node_name": "DirectColorModel(int,int,int,int)", "type": "constructor", "idx": 11515, "Desc": "constructs a directcolormodel from the specified masks that indicate which bits in an int pixel representation contain the red , green and blue color samples . as pixel values do not contain alpha information , all pixels are treated as opaque , which means that alpha = 1.0 . all of the bits in each mask must be contiguous and fit in the specified number of least significant bits of an int pixel representation . the colorspace is the default srgb space . the transparency value is transparency.opaque . the transfer type is the smallest of databuffer.type_byte , databuffer.type_ushort , or databuffer.type_int that can hold a single pixel ."}{"node_name": "DirectColorModel(int,int,int,int,int)", "type": "constructor", "idx": 11520, "Desc": "constructs a directcolormodel from the specified masks that indicate which bits in an int pixel representation contain the red , green and blue color samples and the alpha sample , if present . if amask is 0 , pixel values do not contain alpha information and all pixels are treated as opaque , which means that alpha = 1.0 . all of the bits in each mask must be contiguous and fit in the specified number of least significant bits of an int pixel representation . alpha , if present , is not premultiplied . the colorspace is the default srgb space . the transparency value is transparency.opaque if no alpha is present , or transparency.translucent otherwise . the transfer type is the smallest of databuffer.type_byte , databuffer.type_ushort , or databuffer.type_int that can hold a single pixel ."}{"node_name": "DirectColorModel(java.awt.color.ColorSpace,int,int,int,int,int,boolean,int)", "type": "constructor", "idx": 11526, "Desc": "constructs a directcolormodel from the specified parameters . color components are in the specified colorspace , which must be of type colorspace.type_rgb and have minimum normalized component values which are all 0.0 and maximum values which are all 1.0 . the masks specify which bits in an int pixel representation contain the red , green and blue color samples and the alpha sample , if present . if amask is 0 , pixel values do not contain alpha information and all pixels are treated as opaque , which means that alpha = 1.0 . all of the bits in each mask must be contiguous and fit in the specified number of least significant bits of an int pixel representation . if there is alpha , the boolean isalphapremultiplied specifies how to interpret color and alpha samples in pixel values . if the boolean is true , color samples are assumed to have been multiplied by the alpha sample . the transparency value is transparency.opaque , if no alpha is present , or transparency.translucent otherwise . the transfer type is the type of primitive array used to represent pixel values and must be one of databuffer.type_byte , databuffer.type_ushort , or databuffer.type_int ."}{"node_name": "FilteredImageSource(java.awt.image.ImageProducer,java.awt.image.ImageFilter)", "type": "constructor", "idx": 11587, "Desc": "constructs an imageproducer object from an existing imageproducer and a filter object ."}{"node_name": "ImageFilter()", "type": "constructor", "idx": 11641, "Desc": ""}{"node_name": "ImagingOpException(java.lang.String)", "type": "constructor", "idx": 11704, "Desc": "constructs an imagingopexception object with the specified message ."}{"node_name": "IndexColorModel(int,int,byte[],byte[],byte[])", "type": "constructor", "idx": 11707, "Desc": "constructs an indexcolormodel from the specified arrays of red , green , and blue components . pixels described by this color model all have alpha components of 255 unnormalized ( 1.0 normalized ) , which means they are fully opaque . all of the arrays specifying the color components must have at least the specified number of entries . the colorspace is the default srgb space . since there is no alpha information in any of the arguments to <init>(int,int,byte[],byte[],byte[]) , the transparency value is always transparency.opaque . the transfer type is the smallest of databuffer.type_byte or databuffer.type_ushort that can hold a single pixel ."}{"node_name": "IndexColorModel(int,int,byte[],byte[],byte[],int)", "type": "constructor", "idx": 11713, "Desc": "constructs an indexcolormodel from the given arrays of red , green , and blue components . pixels described by this color model all have alpha components of 255 unnormalized ( 1.0 normalized ) , which means they are fully opaque , except for the indicated pixel to be made transparent . all of the arrays specifying the color components must have at least the specified number of entries . the colorspace is the default srgb space . the transparency value may be transparency.opaque or transparency.bitmask depending on the arguments , as specified in the class description above . the transfer type is the smallest of databuffer.type_byte or databuffer.type_ushort that can hold a single pixel ."}{"node_name": "IndexColorModel(int,int,byte[],byte[],byte[],byte[])", "type": "constructor", "idx": 11720, "Desc": "constructs an indexcolormodel from the given arrays of red , green , blue and alpha components . all of the arrays specifying the components must have at least the specified number of entries . the colorspace is the default srgb space . the transparency value may be any of transparency.opaque , transparency.bitmask , or transparency.translucent depending on the arguments , as specified in the class description above . the transfer type is the smallest of databuffer.type_byte or databuffer.type_ushort that can hold a single pixel ."}{"node_name": "IndexColorModel(int,int,byte[],int,boolean)", "type": "constructor", "idx": 11727, "Desc": "constructs an indexcolormodel from a single array of interleaved red , green , blue and optional alpha components . the array must have enough values in it to fill all of the needed component arrays of the specified size . the colorspace is the default srgb space . the transparency value may be any of transparency.opaque , transparency.bitmask , or transparency.translucent depending on the arguments , as specified in the class description above . the transfer type is the smallest of databuffer.type_byte or databuffer.type_ushort that can hold a single pixel ."}{"node_name": "IndexColorModel(int,int,byte[],int,boolean,int)", "type": "constructor", "idx": 11733, "Desc": "constructs an indexcolormodel from a single array of interleaved red , green , blue and optional alpha components . the specified transparent index represents a pixel that is made entirely transparent regardless of any alpha value specified for it . the array must have enough values in it to fill all of the needed component arrays of the specified size . the colorspace is the default srgb space . the transparency value may be any of transparency.opaque , transparency.bitmask , or transparency.translucent depending on the arguments , as specified in the class description above . the transfer type is the smallest of databuffer.type_byte or databuffer.type_ushort that can hold a single pixel ."}{"node_name": "IndexColorModel(int,int,int[],int,boolean,int,int)", "type": "constructor", "idx": 11740, "Desc": "constructs an indexcolormodel from an array of ints where each int is comprised of red , green , blue , and optional alpha components in the default rgb color model format . the specified transparent index represents a pixel that is made entirely transparent regardless of any alpha value specified for it . the array must have enough values in it to fill all of the needed component arrays of the specified size . the colorspace is the default srgb space . the transparency value may be any of transparency.opaque , transparency.bitmask , or transparency.translucent depending on the arguments , as specified in the class description above ."}{"node_name": "IndexColorModel(int,int,int[],int,int,java.math.BigInteger)", "type": "constructor", "idx": 11748, "Desc": "constructs an indexcolormodel from an int array where each int is comprised of red , green , blue , and alpha components in the default rgb color model format . the array must have enough values in it to fill all of the needed component arrays of the specified size . the colorspace is the default srgb space . the transparency value may be any of transparency.opaque , transparency.bitmask , or transparency.translucent depending on the arguments , as specified in the class description above . the transfer type must be one of databuffer.type_byte databuffer.type_ushort . the biginteger object specifies the valid / invalid pixels in the cmap array . a pixel is valid if the biginteger value at that index is set , and is invalid if the biginteger bit at that index is not set ."}{"node_name": "Image()", "type": "constructor", "idx": 11826, "Desc": ""}{"node_name": "Kernel(int,int,float[])", "type": "constructor", "idx": 11847, "Desc": "constructs a kernel object from an array of floats . the first width*height elements of the data array are copied . if the length of the data array is less than width*height , an illegalargumentexception is thrown . the x origin is ( width-1 ) / 2 and the y origin is ( height-1 ) / 2 ."}{"node_name": "LookupOp(java.awt.image.LookupTable,java.awt.RenderingHints)", "type": "constructor", "idx": 11859, "Desc": "constructs a lookupop object given the lookup table and a renderinghints object , which might be null ."}{"node_name": "LookupTable(int,int)", "type": "constructor", "idx": 11883, "Desc": "constructs a new lookuptable from the number of components and an offset into the lookup table ."}{"node_name": "MemoryImageSource(int,int,java.awt.image.ColorModel,byte[],int,int)", "type": "constructor", "idx": 11892, "Desc": "constructs an imageproducer object which uses an array of bytes to produce data for an image object ."}{"node_name": "MemoryImageSource(int,int,java.awt.image.ColorModel,byte[],int,int,java.util.Hashtable)", "type": "constructor", "idx": 11899, "Desc": "constructs an imageproducer object which uses an array of bytes to produce data for an image object ."}{"node_name": "MemoryImageSource(int,int,java.awt.image.ColorModel,int[],int,int)", "type": "constructor", "idx": 11907, "Desc": "constructs an imageproducer object which uses an array of integers to produce data for an image object ."}{"node_name": "MemoryImageSource(int,int,java.awt.image.ColorModel,int[],int,int,java.util.Hashtable)", "type": "constructor", "idx": 11914, "Desc": "constructs an imageproducer object which uses an array of integers to produce data for an image object ."}{"node_name": "MemoryImageSource(int,int,int[],int,int)", "type": "constructor", "idx": 11922, "Desc": "constructs an imageproducer object which uses an array of integers in the default rgb colormodel to produce data for an image object ."}{"node_name": "MemoryImageSource(int,int,int[],int,int,java.util.Hashtable)", "type": "constructor", "idx": 11928, "Desc": "constructs an imageproducer object which uses an array of integers in the default rgb colormodel to produce data for an image object ."}{"node_name": "MultiPixelPackedSampleModel(int,int,int,int)", "type": "constructor", "idx": 11972, "Desc": "constructs a multipixelpackedsamplemodel with the specified data type , width , height and number of bits per pixel ."}{"node_name": "MultiPixelPackedSampleModel(int,int,int,int,int,int)", "type": "constructor", "idx": 11977, "Desc": "constructs a multipixelpackedsamplemodel with specified data type , width , height , number of bits per pixel , scanline stride and data bit offset ."}{"node_name": "PackedColorModel(java.awt.color.ColorSpace,int,int[],int,boolean,int,int)", "type": "constructor", "idx": 12040, "Desc": "constructs a packedcolormodel from a color mask array , which specifies which bits in an int pixel representation contain each of the color samples , and an alpha mask . color components are in the specified colorspace . the length of colormaskarray should be the number of components in the colorspace . all of the bits in each mask must be contiguous and fit in the specified number of least significant bits of an int pixel representation . if the alphamask is 0 , there is no alpha . if there is alpha , the boolean isalphapremultiplied specifies how to interpret color and alpha samples in pixel values . if the boolean is true , color samples are assumed to have been multiplied by the alpha sample . the transparency , trans , specifies what alpha values can be represented by this color model . the transfer type is the type of primitive array used to represent pixel values ."}{"node_name": "PackedColorModel(java.awt.color.ColorSpace,int,int,int,int,int,boolean,int,int)", "type": "constructor", "idx": 12048, "Desc": "constructs a packedcolormodel from the specified masks which indicate which bits in an int pixel representation contain the alpha , red , green and blue color samples . color components are in the specified colorspace , which must be of type colorspace.type_rgb . all of the bits in each mask must be contiguous and fit in the specified number of least significant bits of an int pixel representation . if amask is 0 , there is no alpha . if there is alpha , the boolean isalphapremultiplied specifies how to interpret color and alpha samples in pixel values . if the boolean is true , color samples are assumed to have been multiplied by the alpha sample . the transparency , trans , specifies what alpha values can be represented by this color model . the transfer type is the type of primitive array used to represent pixel values ."}{"node_name": "PixelGrabber(java.awt.Image,int,int,int,int,int[],int,int)", "type": "constructor", "idx": 12072, "Desc": "create a pixelgrabber object to grab the ( x , y , w , h ) rectangular section of pixels from the specified image into the given array . the pixels are stored into the array in the default rgb colormodel . the rgb data for pixel ( i , j ) where ( i , j ) is inside the rectangle ( x , y , w , h ) is stored in the array at pix [( j - y ) * scansize + ( i - x ) + off ] ."}{"node_name": "PixelGrabber(java.awt.image.ImageProducer,int,int,int,int,int[],int,int)", "type": "constructor", "idx": 12081, "Desc": "create a pixelgrabber object to grab the ( x , y , w , h ) rectangular section of pixels from the image produced by the specified imageproducer into the given array . the pixels are stored into the array in the default rgb colormodel . the rgb data for pixel ( i , j ) where ( i , j ) is inside the rectangle ( x , y , w , h ) is stored in the array at pix [( j - y ) * scansize + ( i - x ) + off ] ."}{"node_name": "PixelGrabber(java.awt.Image,int,int,int,int,boolean)", "type": "constructor", "idx": 12090, "Desc": "create a pixelgrabber object to grab the ( x , y , w , h ) rectangular section of pixels from the specified image . the pixels are accumulated in the original colormodel if the same colormodel is used for every call to setpixels , otherwise the pixels are accumulated in the default rgb colormodel . if the forcergb parameter is true , then the pixels will be accumulated in the default rgb colormodel anyway . a buffer is allocated by the pixelgrabber to hold the pixels in either case . if ( w < 0 ) or ( h < 0 ) , then they will default to the remaining width and height of the source data when that information is delivered ."}{"node_name": "PixelInterleavedSampleModel(int,int,int,int,int,int[])", "type": "constructor", "idx": 12138, "Desc": "constructs a pixelinterleavedsamplemodel with the specified parameters . the number of bands will be given by the length of the bandoffsets array ."}{"node_name": "Raster(java.awt.image.SampleModel,java.awt.Point)", "type": "constructor", "idx": 12162, "Desc": "constructs a raster with the given samplemodel . the raster's upper left corner is origin and it is the same size as the samplemodel . a databuffer large enough to describe the raster is automatically created ."}{"node_name": "Raster(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Point)", "type": "constructor", "idx": 12165, "Desc": "constructs a raster with the given samplemodel and databuffer . the raster's upper left corner is origin and it is the same size as the samplemodel . the databuffer is not initialized and must be compatible with samplemodel ."}{"node_name": "Raster(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Rectangle,java.awt.Point,java.awt.image.Raster)", "type": "constructor", "idx": 12169, "Desc": "constructs a raster with the given samplemodel , databuffer , and parent . aregion specifies the bounding rectangle of the new raster . when translated into the base raster's coordinate system , aregion must be contained by the base raster . ( the base raster is the raster's ancestor which has no parent . ) samplemodeltranslate specifies the samplemodeltranslatex and samplemodeltranslatey values of the new raster . note that <init>(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Rectangle,java.awt.Point,java.awt.image.Raster) should generally be called by other constructors or create methods , it should not be used directly ."}{"node_name": "RasterFormatException(java.lang.String)", "type": "constructor", "idx": 12365, "Desc": "constructs a new rasterformatexception with the specified message ."}{"node_name": "ParameterBlock()", "type": "constructor", "idx": 12398, "Desc": "a dummy constructor ."}{"node_name": "ParameterBlock(java.util.Vector)", "type": "constructor", "idx": 12399, "Desc": "constructs a parameterblock with a given vector of sources ."}{"node_name": "ParameterBlock(java.util.Vector,java.util.Vector)", "type": "constructor", "idx": 12401, "Desc": "constructs a parameterblock with a given vector of sources and vector of parameters ."}{"node_name": "RenderableImageOp(java.awt.image.renderable.ContextualRenderedImageFactory,java.awt.image.renderable.ParameterBlock)", "type": "constructor", "idx": 12503, "Desc": "constructs a renderedimageop given a contextualrenderedimagefactory object , and a parameterblock containing renderableimage sources and other parameters . any renderedimage sources referenced by the parameterblock will be ignored ."}{"node_name": "RenderableImageProducer(java.awt.image.renderable.RenderableImage,java.awt.image.renderable.RenderContext)", "type": "constructor", "idx": 12526, "Desc": "constructs a new renderableimageproducer from a renderableimage and a rendercontext ."}{"node_name": "RenderContext(java.awt.geom.AffineTransform,java.awt.Shape,java.awt.RenderingHints)", "type": "constructor", "idx": 12543, "Desc": "constructs a rendercontext with a given transform . the area of interest is supplied as a shape , and the rendering hints are supplied as a renderinghints object ."}{"node_name": "RenderContext(java.awt.geom.AffineTransform)", "type": "constructor", "idx": 12547, "Desc": "constructs a rendercontext with a given transform . the area of interest is taken to be the entire renderable area . no rendering hints are used ."}{"node_name": "RenderContext(java.awt.geom.AffineTransform,java.awt.RenderingHints)", "type": "constructor", "idx": 12549, "Desc": "constructs a rendercontext with a given transform and rendering hints . the area of interest is taken to be the entire renderable area ."}{"node_name": "RenderContext(java.awt.geom.AffineTransform,java.awt.Shape)", "type": "constructor", "idx": 12552, "Desc": "constructs a rendercontext with a given transform and area of interest . the area of interest is supplied as a shape . no rendering hints are used ."}{"node_name": "ReplicateScaleFilter(int,int)", "type": "constructor", "idx": 12608, "Desc": "constructs a replicatescalefilter that scales the pixels from its source image as specified by the width and height parameters ."}{"node_name": "RescaleOp(float[],float[],java.awt.RenderingHints)", "type": "constructor", "idx": 12635, "Desc": "constructs a new rescaleop with the desired scale factors and offsets . the length of the scalefactor and offset arrays must meet the restrictions stated in the class comments above . the renderinghints argument may be null ."}{"node_name": "RescaleOp(float,float,java.awt.RenderingHints)", "type": "constructor", "idx": 12639, "Desc": "constructs a new rescaleop with the desired scale factor and offset . the scalefactor and offset will be applied to all bands in a source raster and to all color ( but not alpha ) components in a bufferedimage . the renderinghints argument may be null ."}{"node_name": "RGBImageFilter()", "type": "constructor", "idx": 12671, "Desc": ""}{"node_name": "SampleModel(int,int,int,int)", "type": "constructor", "idx": 12714, "Desc": "constructs a samplemodel with the specified parameters ."}{"node_name": "ShortLookupTable(int,short[][])", "type": "constructor", "idx": 12912, "Desc": "constructs a shortlookuptable object from an array of short arrays representing a lookup table for each band . the offset will be subtracted from the input values before indexing into the arrays . the number of bands is the length of the data argument . the data array for each band is stored as a reference ."}{"node_name": "ShortLookupTable(int,short[])", "type": "constructor", "idx": 12915, "Desc": "constructs a shortlookuptable object from an array of shorts representing a lookup table for each band . the offset will be subtracted from the input values before indexing into the array . the data array is stored as a reference ."}{"node_name": "SinglePixelPackedSampleModel(int,int,int,int[])", "type": "constructor", "idx": 12926, "Desc": "constructs a singlepixelpackedsamplemodel with bitmasks.length bands . each sample is stored in a data array element in the position of its corresponding bit mask . each bit mask must be contiguous and masks must not overlap . bit masks exceeding data type capacity are truncated ."}{"node_name": "SinglePixelPackedSampleModel(int,int,int,int,int[])", "type": "constructor", "idx": 12931, "Desc": "constructs a singlepixelpackedsamplemodel with bitmasks.length bands and a scanline stride equal to scanlinestride data array elements . each sample is stored in a data array element in the position of its corresponding bit mask . each bit mask must be contiguous and masks must not overlap . bit masks exceeding data type capacity are truncated ."}{"node_name": "VolatileImage()", "type": "constructor", "idx": 13025, "Desc": ""}{"node_name": "WritableRaster(java.awt.image.SampleModel,java.awt.Point)", "type": "constructor", "idx": 13038, "Desc": "constructs a writableraster with the given samplemodel . the writableraster's upper left corner is origin and it is the same size as the samplemodel . a databuffer large enough to describe the writableraster is automatically created ."}{"node_name": "WritableRaster(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Point)", "type": "constructor", "idx": 13041, "Desc": "constructs a writableraster with the given samplemodel and databuffer . the writableraster's upper left corner is origin and it is the same size as the samplemodel . the databuffer is not initialized and must be compatible with samplemodel ."}{"node_name": "WritableRaster(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Rectangle,java.awt.Point,java.awt.image.WritableRaster)", "type": "constructor", "idx": 13045, "Desc": "constructs a writableraster with the given samplemodel , databuffer , and parent . aregion specifies the bounding rectangle of the new raster . when translated into the base raster's coordinate system , aregion must be contained by the base raster . ( the base raster is the raster's ancestor which has no parent . ) samplemodeltranslate specifies the samplemodeltranslatex and samplemodeltranslatey values of the new raster . note that <init>(java.awt.image.SampleModel,java.awt.image.DataBuffer,java.awt.Rectangle,java.awt.Point,java.awt.image.WritableRaster) should generally be called by other constructors or create methods , it should not be used directly ."}{"node_name": "ImageCapabilities(boolean)", "type": "constructor", "idx": 13168, "Desc": "creates a new object for specifying image capabilities ."}{"node_name": "Insets(int,int,int,int)", "type": "constructor", "idx": 13178, "Desc": "creates and initializes a new insets object with the specified top , left , bottom , and right insets ."}{"node_name": "JobAttributes()", "type": "constructor", "idx": 13217, "Desc": "constructs a jobattributes instance with default values for every attribute . the dialog defaults to dialogtype.native . min page defaults to 1 . max page defaults to integer.max_value . destination defaults to destinationtype.printer . selection defaults to defaultselectiontype.all . number of copies defaults to 1 . multiple document handling defaults to multipledocumenthandlingtype.separate_documents_uncollated_copies . sides defaults to sidestype.one_sided . file name defaults to null ."}{"node_name": "JobAttributes(java.awt.JobAttributes)", "type": "constructor", "idx": 13218, "Desc": "constructs a jobattributes instance which is a copy of the supplied jobattributes ."}{"node_name": "JobAttributes(int,java.awt.JobAttributes.DefaultSelectionType,java.awt.JobAttributes.DestinationType,java.awt.JobAttributes.DialogType,java.lang.String,int,int,java.awt.JobAttributes.MultipleDocumentHandlingType,int[][],java.lang.String,java.awt.JobAttributes.SidesType)", "type": "constructor", "idx": 13220, "Desc": "constructs a jobattributes instance with the specified values for every attribute ."}{"node_name": "KeyboardFocusManager()", "type": "constructor", "idx": 13297, "Desc": "initializes a keyboardfocusmanager ."}{"node_name": "AccessibleAWTLabel()", "type": "constructor", "idx": 13414, "Desc": "constructor for the accessible label ."}{"node_name": "Label()", "type": "constructor", "idx": 13421, "Desc": "constructs an empty label . the text of the label is the empty string \"\" ."}{"node_name": "Label(java.lang.String)", "type": "constructor", "idx": 13422, "Desc": "constructs a new label with the specified string of text , left justified ."}{"node_name": "Label(java.lang.String,int)", "type": "constructor", "idx": 13424, "Desc": "constructs a new label that presents the specified string of text with the specified alignment . possible values for alignment are label.left , label.right , and label.center ."}{"node_name": "LinearGradientPaint(float,float,float,float,float[],java.awt.Color[])", "type": "constructor", "idx": 13461, "Desc": "constructs a lineargradientpaint with a default no_cycle repeating method and srgb color space ."}{"node_name": "LinearGradientPaint(float,float,float,float,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 13468, "Desc": "constructs a lineargradientpaint with a default srgb color space ."}{"node_name": "LinearGradientPaint(java.awt.geom.Point2D,java.awt.geom.Point2D,float[],java.awt.Color[])", "type": "constructor", "idx": 13476, "Desc": "constructs a lineargradientpaint with a default no_cycle repeating method and srgb color space ."}{"node_name": "LinearGradientPaint(java.awt.geom.Point2D,java.awt.geom.Point2D,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 13481, "Desc": "constructs a lineargradientpaint with a default srgb color space ."}{"node_name": "LinearGradientPaint(java.awt.geom.Point2D,java.awt.geom.Point2D,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod,java.awt.MultipleGradientPaint.ColorSpaceType,java.awt.geom.AffineTransform)", "type": "constructor", "idx": 13487, "Desc": "constructs a lineargradientpaint ."}{"node_name": "AccessibleAWTListChild(java.awt.List,int)", "type": "constructor", "idx": 13504, "Desc": "constructs new accessibleawtlistchild with the given parent list and 0-based index of this object in the parent ."}{"node_name": "AccessibleAWTList()", "type": "constructor", "idx": 13557, "Desc": "constructs new accessibleawtlist"}{"node_name": "List()", "type": "constructor", "idx": 13578, "Desc": "creates a new scrolling list . by default , there are four visible lines and multiple selections are not allowed . note that this is a convenience method for list ( 0 , false ) . also note that the number of visible lines in the list cannot be changed after it has been created ."}{"node_name": "List(int)", "type": "constructor", "idx": 13579, "Desc": "creates a new scrolling list initialized with the specified number of visible lines . by default , multiple selections are not allowed . note that this is a convenience method for list ( rows , false ) . also note that the number of visible rows in the list cannot be changed after it has been created ."}{"node_name": "List(int,boolean)", "type": "constructor", "idx": 13581, "Desc": "creates a new scrolling list initialized to display the specified number of rows . note that if zero rows are specified , then the list will be created with a default of four rows . also note that the number of visible rows in the list cannot be changed after it has been created . if the value of multiplemode is true , then the user can select multiple items from the list . if it is false , only one item at a time can be selected ."}{"node_name": "MediaTracker(java.awt.Component)", "type": "constructor", "idx": 13652, "Desc": "creates a media tracker to track images for a given component ."}{"node_name": "AccessibleAWTMenu()", "type": "constructor", "idx": 13700, "Desc": ""}{"node_name": "Menu()", "type": "constructor", "idx": 13703, "Desc": "constructs a new menu with an empty label . this menu is not a tear-off menu ."}{"node_name": "Menu(java.lang.String)", "type": "constructor", "idx": 13704, "Desc": "constructs a new menu with the specified label . this menu is not a tear-off menu ."}{"node_name": "Menu(java.lang.String,boolean)", "type": "constructor", "idx": 13706, "Desc": "constructs a new menu with the specified label , indicating whether the menu can be torn off . tear-off functionality may not be supported by all implementations of awt . if a particular implementation doesn't support tear-off menus , this value is silently ignored ."}{"node_name": "AccessibleAWTMenuBar()", "type": "constructor", "idx": 13736, "Desc": ""}{"node_name": "MenuBar()", "type": "constructor", "idx": 13739, "Desc": "creates a new menu bar ."}{"node_name": "AccessibleAWTMenuComponent()", "type": "constructor", "idx": 13761, "Desc": "although the class is abstract , this should be called by all sub-classes ."}{"node_name": "MenuComponent()", "type": "constructor", "idx": 13827, "Desc": "creates a menucomponent ."}{"node_name": "AccessibleAWTMenuItem()", "type": "constructor", "idx": 13849, "Desc": ""}{"node_name": "MenuItem()", "type": "constructor", "idx": 13865, "Desc": "constructs a new menuitem with an empty label and no keyboard shortcut ."}{"node_name": "MenuItem(java.lang.String)", "type": "constructor", "idx": 13866, "Desc": "constructs a new menuitem with the specified label and no keyboard shortcut . note that use of \" - \" in a label is reserved to indicate a separator between menu items . by default , all menu items except for separators are enabled ."}{"node_name": "MenuItem(java.lang.String,java.awt.MenuShortcut)", "type": "constructor", "idx": 13868, "Desc": "create a menu item with an associated keyboard shortcut . note that use of \" - \" in a label is reserved to indicate a separator between menu items . by default , all menu items except for separators are enabled ."}{"node_name": "MenuShortcut(int)", "type": "constructor", "idx": 13903, "Desc": "constructs a new menushortcut for the specified virtual keycode ."}{"node_name": "MenuShortcut(int,boolean)", "type": "constructor", "idx": 13905, "Desc": "constructs a new menushortcut for the specified virtual keycode ."}{"node_name": "PageAttributes()", "type": "constructor", "idx": 13941, "Desc": "constructs a pageattributes instance with default values for every attribute ."}{"node_name": "PageAttributes(java.awt.PageAttributes)", "type": "constructor", "idx": 13942, "Desc": "constructs a pageattributes instance which is a copy of the supplied pageattributes ."}{"node_name": "PageAttributes(java.awt.PageAttributes.ColorType,java.awt.PageAttributes.MediaType,java.awt.PageAttributes.OrientationRequestedType,java.awt.PageAttributes.OriginType,java.awt.PageAttributes.PrintQualityType,int[])", "type": "constructor", "idx": 13944, "Desc": "constructs a pageattributes instance with the specified values for every attribute ."}{"node_name": "AccessibleAWTPanel()", "type": "constructor", "idx": 14168, "Desc": ""}{"node_name": "Panel()", "type": "constructor", "idx": 14171, "Desc": "creates a new panel using the default layout manager . the default layout manager for all panels is the flowlayout class ."}{"node_name": "Panel(java.awt.LayoutManager)", "type": "constructor", "idx": 14172, "Desc": "creates a new panel with the specified layout manager ."}{"node_name": "Point()", "type": "constructor", "idx": 14179, "Desc": "constructs and initializes a point at the origin ( 0 , 0 ) of the coordinate space ."}{"node_name": "Point(java.awt.Point)", "type": "constructor", "idx": 14180, "Desc": "constructs and initializes a point with the same location as the specified point object ."}{"node_name": "Point(int,int)", "type": "constructor", "idx": 14182, "Desc": "constructs and initializes a point at the specified ( x , y ) location in the coordinate space ."}{"node_name": "Polygon()", "type": "constructor", "idx": 14213, "Desc": "creates an empty polygon ."}{"node_name": "Polygon(int[],int[],int)", "type": "constructor", "idx": 14214, "Desc": "constructs and initializes a polygon from the specified parameters ."}{"node_name": "AccessibleAWTPopupMenu()", "type": "constructor", "idx": 14258, "Desc": ""}{"node_name": "PopupMenu()", "type": "constructor", "idx": 14261, "Desc": "creates a new popup menu with an empty name ."}{"node_name": "PopupMenu(java.lang.String)", "type": "constructor", "idx": 14262, "Desc": "creates a new popup menu with the specified name ."}{"node_name": "Book()", "type": "constructor", "idx": 14271, "Desc": "creates a new , empty book ."}{"node_name": "PageFormat()", "type": "constructor", "idx": 14299, "Desc": "creates a default , portrait-oriented pageformat ."}{"node_name": "Paper()", "type": "constructor", "idx": 14315, "Desc": "creates a letter sized piece of paper with one inch margins ."}{"node_name": "PrinterAbortException()", "type": "constructor", "idx": 14339, "Desc": "constructs a new printerabortexception with no detail message ."}{"node_name": "PrinterAbortException(java.lang.String)", "type": "constructor", "idx": 14340, "Desc": "constructs a new printerabortexception with the specified detail message ."}{"node_name": "PrinterException()", "type": "constructor", "idx": 14343, "Desc": "constructs a new printerexception object without a detail message ."}{"node_name": "PrinterException(java.lang.String)", "type": "constructor", "idx": 14344, "Desc": "constructs a new printerexception object with the specified detail message ."}{"node_name": "PrinterIOException(java.io.IOException)", "type": "constructor", "idx": 14349, "Desc": "constructs a new printerioexception with the string representation of the specified ioexception ."}{"node_name": "PrinterJob()", "type": "constructor", "idx": 14354, "Desc": "a printerjob object should be created using the static getprinterjob method ."}{"node_name": "PrintJob()", "type": "constructor", "idx": 14398, "Desc": ""}{"node_name": "RadialGradientPaint(float,float,float,float[],java.awt.Color[])", "type": "constructor", "idx": 14405, "Desc": "constructs a radialgradientpaint with a default no_cycle repeating method and srgb color space , using the center as the focus point ."}{"node_name": "RadialGradientPaint(java.awt.geom.Point2D,float,float[],java.awt.Color[])", "type": "constructor", "idx": 14411, "Desc": "constructs a radialgradientpaint with a default no_cycle repeating method and srgb color space , using the center as the focus point ."}{"node_name": "RadialGradientPaint(float,float,float,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 14416, "Desc": "constructs a radialgradientpaint with a default srgb color space , using the center as the focus point ."}{"node_name": "RadialGradientPaint(java.awt.geom.Point2D,float,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 14423, "Desc": "constructs a radialgradientpaint with a default srgb color space , using the center as the focus point ."}{"node_name": "RadialGradientPaint(float,float,float,float,float,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 14429, "Desc": "constructs a radialgradientpaint with a default srgb color space ."}{"node_name": "RadialGradientPaint(java.awt.geom.Point2D,float,java.awt.geom.Point2D,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 14438, "Desc": "constructs a radialgradientpaint with a default srgb color space ."}{"node_name": "RadialGradientPaint(java.awt.geom.Point2D,float,java.awt.geom.Point2D,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod,java.awt.MultipleGradientPaint.ColorSpaceType,java.awt.geom.AffineTransform)", "type": "constructor", "idx": 14445, "Desc": "constructs a radialgradientpaint ."}{"node_name": "RadialGradientPaint(java.awt.geom.Rectangle2D,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod)", "type": "constructor", "idx": 14454, "Desc": "constructs a radialgradientpaint with a default srgb color space . the gradient circle of the radialgradientpaint is defined by the given bounding box . <init>(java.awt.geom.Rectangle2D,float[],java.awt.Color[],java.awt.MultipleGradientPaint.CycleMethod) is a more convenient way to express the following ( equivalent ) code : double gw = gradientbounds.getwidth() ; double gh = gradientbounds.getheight() ; double cx = gradientbounds.getcenterx() ; double cy = gradientbounds.getcentery() ; point2d center = new point2d.double ( cx , cy ); affinetransform gradienttransform = new affinetransform() ; gradienttransform.translate ( cx , cy ); gradienttransform.scale ( gw / 2 , gh / 2 ); gradienttransform.translate ( -cx , -cy ); radialgradientpaint gp = new radialgradientpaint ( center , 1.0f , center , fractions , colors , cyclemethod , colorspacetype.srgb , gradienttransform );"}{"node_name": "Rectangle()", "type": "constructor", "idx": 14473, "Desc": "constructs a new rectangle whose upper-left corner is at ( 0 , 0 ) in the coordinate space , and whose width and height are both zero ."}{"node_name": "Rectangle(java.awt.Rectangle)", "type": "constructor", "idx": 14474, "Desc": "constructs a new rectangle , initialized to match the values of the specified rectangle ."}{"node_name": "Rectangle(int,int,int,int)", "type": "constructor", "idx": 14476, "Desc": "constructs a new rectangle whose upper-left corner is specified as ( x , y ) and whose width and height are specified by the arguments of the same name ."}{"node_name": "Rectangle(int,int)", "type": "constructor", "idx": 14481, "Desc": "constructs a new rectangle whose upper-left corner is at ( 0 , 0 ) in the coordinate space , and whose width and height are specified by the arguments of the same name ."}{"node_name": "Rectangle(java.awt.Point,java.awt.Dimension)", "type": "constructor", "idx": 14484, "Desc": "constructs a new rectangle whose upper-left corner is specified by the point argument , and whose width and height are specified by the dimension argument ."}{"node_name": "Rectangle(java.awt.Point)", "type": "constructor", "idx": 14487, "Desc": "constructs a new rectangle whose upper-left corner is the specified point , and whose width and height are both zero ."}{"node_name": "Rectangle(java.awt.Dimension)", "type": "constructor", "idx": 14489, "Desc": "constructs a new rectangle whose top left corner is ( 0 , 0 ) and whose width and height are specified by the dimension argument ."}{"node_name": "RenderingHints(java.util.Map)", "type": "constructor", "idx": 14611, "Desc": "constructs a new object with keys and values initialized from the specified map object which may be null ."}{"node_name": "RenderingHints(java.awt.RenderingHints.Key,java.lang.Object)", "type": "constructor", "idx": 14613, "Desc": "constructs a new object with the specified key / value pair ."}{"node_name": "Key(int)", "type": "constructor", "idx": 14643, "Desc": "construct a key using the indicated private key . each subclass of key maintains its own unique domain of integer keys . no two objects with the same integer key and of the same specific subclass can be constructed . an exception will be thrown if an attempt is made to construct another object of a given class with the same integer key as a pre-existing instance of that subclass of key ."}{"node_name": "Robot()", "type": "constructor", "idx": 14652, "Desc": "constructs a robot object in the coordinate system of the primary screen ."}{"node_name": "Robot(java.awt.GraphicsDevice)", "type": "constructor", "idx": 14653, "Desc": "creates a robot for the given screen device . coordinates passed to robot method calls like mousemove , getpixelcolor and createscreencapture will be interpreted as being in the same coordinate system as the specified screen . note that depending on the platform configuration , multiple screens may either : share the same coordinate system to form a combined virtual screen use different coordinate systems to act as independent screens if screen devices are reconfigured such that the coordinate system is affected , the behavior of existing robot objects is undefined ."}{"node_name": "AccessibleAWTScrollBar()", "type": "constructor", "idx": 14686, "Desc": ""}{"node_name": "Scrollbar()", "type": "constructor", "idx": 14698, "Desc": "constructs a new vertical scroll bar . the default properties of the scroll bar are listed in the following table : scrollbar default properties property description default value orientation indicates whether the scroll bar is vertical or horizontal scrollbar.vertical value value which controls the location of the scroll bar's bubble 0 visible amount visible amount of the scroll bar's range , typically represented by the size of the scroll bar's bubble 10 minimum minimum value of the scroll bar 0 maximum maximum value of the scroll bar 100 unit increment amount the value changes when the line up or line down key is pressed , or when the end arrows of the scrollbar are clicked 1 block increment amount the value changes when the page up or page down key is pressed , or when the scrollbar track is clickedon either side of the bubble 10"}{"node_name": "Scrollbar(int)", "type": "constructor", "idx": 14699, "Desc": "constructs a new scroll bar with the specified orientation . the orientation argument must take one of the two values scrollbar.horizontal , or scrollbar.vertical , indicating a horizontal or vertical scroll bar , respectively ."}{"node_name": "Scrollbar(int,int,int,int,int)", "type": "constructor", "idx": 14701, "Desc": "constructs a new scroll bar with the specified orientation , initial value , visible amount , and minimum and maximum values . the orientation argument must take one of the two values scrollbar.horizontal , or scrollbar.vertical , indicating a horizontal or vertical scroll bar , respectively . the parameters supplied to <init>(int,int,int,int,int) are subject to the constraints described in setvalues ( int , int , int , int ) ."}{"node_name": "AccessibleAWTScrollPane()", "type": "constructor", "idx": 14751, "Desc": ""}{"node_name": "ScrollPane()", "type": "constructor", "idx": 14757, "Desc": "create a new scrollpane container with a scrollbar display policy of \" as needed \" ."}{"node_name": "ScrollPane(int)", "type": "constructor", "idx": 14758, "Desc": "create a new scrollpane container ."}{"node_name": "AccessibleAWTTextArea()", "type": "constructor", "idx": 14964, "Desc": ""}{"node_name": "TextArea()", "type": "constructor", "idx": 14971, "Desc": "constructs a new text area with the empty string as text . this text area is created with scrollbar visibility equal to scrollbars_both , so both vertical and horizontal scrollbars will be visible for this text area ."}{"node_name": "TextArea(java.lang.String)", "type": "constructor", "idx": 14972, "Desc": "constructs a new text area with the specified text . this text area is created with scrollbar visibility equal to scrollbars_both , so both vertical and horizontal scrollbars will be visible for this text area ."}{"node_name": "TextArea(int,int)", "type": "constructor", "idx": 14974, "Desc": "constructs a new text area with the specified number of rows and columns and the empty string as text . a column is an approximate average character width that is platform-dependent . the text area is created with scrollbar visibility equal to scrollbars_both , so both vertical and horizontal scrollbars will be visible for this text area ."}{"node_name": "TextArea(java.lang.String,int,int)", "type": "constructor", "idx": 14977, "Desc": "constructs a new text area with the specified text , and with the specified number of rows and columns . a column is an approximate average character width that is platform-dependent . the text area is created with scrollbar visibility equal to scrollbars_both , so both vertical and horizontal scrollbars will be visible for this text area ."}{"node_name": "TextArea(java.lang.String,int,int,int)", "type": "constructor", "idx": 14981, "Desc": "constructs a new text area with the specified text , and with the rows , columns , and scroll bar visibility as specified . all textarea constructors defer to this one . the textarea class defines several constants that can be supplied as values for the scrollbars argument : scrollbars_both , scrollbars_vertical_only , scrollbars_horizontal_only , scrollbars_none . any other value for the scrollbars argument is invalid and will result in this text area being created with scrollbar visibility equal to the default value of scrollbars_both ."}{"node_name": "AccessibleAWTTextComponent()", "type": "constructor", "idx": 15014, "Desc": "constructs an accessibleawttextcomponent . adds a listener to track caret change ."}{"node_name": "AccessibleAWTTextField()", "type": "constructor", "idx": 15083, "Desc": ""}{"node_name": "TextField()", "type": "constructor", "idx": 15086, "Desc": "constructs a new text field ."}{"node_name": "TextField(java.lang.String)", "type": "constructor", "idx": 15087, "Desc": "constructs a new text field initialized with the specified text ."}{"node_name": "TextField(int)", "type": "constructor", "idx": 15089, "Desc": "constructs a new empty text field with the specified number of columns . a column is an approximate average character width that is platform-dependent ."}{"node_name": "TextField(java.lang.String,int)", "type": "constructor", "idx": 15091, "Desc": "constructs a new text field initialized with the specified text to be displayed , and wide enough to hold the specified number of columns . a column is an approximate average character width that is platform-dependent ."}{"node_name": "TexturePaint(java.awt.image.BufferedImage,java.awt.geom.Rectangle2D)", "type": "constructor", "idx": 15124, "Desc": "constructs a texturepaint object ."}{"node_name": "Toolkit()", "type": "constructor", "idx": 15139, "Desc": ""}{"node_name": "TrayIcon(java.awt.Image)", "type": "constructor", "idx": 15259, "Desc": "creates a trayicon with the specified image ."}{"node_name": "TrayIcon(java.awt.Image,java.lang.String)", "type": "constructor", "idx": 15261, "Desc": "creates a trayicon with the specified image and tooltip text . tooltip may be not visible on some platforms ."}{"node_name": "TrayIcon(java.awt.Image,java.lang.String,java.awt.PopupMenu)", "type": "constructor", "idx": 15264, "Desc": "creates a trayicon with the specified image , tooltip and popup menu . tooltip may be not visible on some platforms ."}{"node_name": "AccessibleAWTWindow()", "type": "constructor", "idx": 15308, "Desc": ""}{"node_name": "Window(java.awt.Frame)", "type": "constructor", "idx": 15312, "Desc": "constructs a new , initially invisible window with the specified frame as its owner . the window will not be focusable unless its owner is showing on the screen . if there is a security manager set , it is invoked to check awtpermission ( \" showwindowwithoutwarningbanner \") . if that check fails with a securityexception then a warning banner is created ."}{"node_name": "Window(java.awt.Window)", "type": "constructor", "idx": 15314, "Desc": "constructs a new , initially invisible window with the specified window as its owner . this window will not be focusable unless its nearest owning frame or dialog is showing on the screen . if there is a security manager set , it is invoked to check awtpermission ( \" showwindowwithoutwarningbanner \") . if that check fails with a securityexception then a warning banner is created ."}{"node_name": "Window(java.awt.Window,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 15316, "Desc": "constructs a new , initially invisible window with the specified owner window and a graphicsconfiguration of a screen device . the window will not be focusable unless its nearest owning frame or dialog is showing on the screen . if there is a security manager set , it is invoked to check awtpermission ( \" showwindowwithoutwarningbanner \") . if that check fails with a securityexception then a warning banner is created ."}{"node_name": "BeanContextChildSupport()", "type": "constructor", "idx": 15486, "Desc": "construct a beancontextchildsupport where this class has been subclassed in order to implement the javabean component itself ."}{"node_name": "BeanContextChildSupport(java.beans.beancontext.BeanContextChild)", "type": "constructor", "idx": 15487, "Desc": "construct a beancontextchildsupport where the javabean component itself implements beancontextchild , and encapsulates this , delegating that interface to this implementation"}{"node_name": "BeanContextEvent(java.beans.beancontext.BeanContext)", "type": "constructor", "idx": 15526, "Desc": "contruct a beancontextevent"}{"node_name": "BeanContextMembershipEvent(java.beans.beancontext.BeanContext,java.util.Collection)", "type": "constructor", "idx": 15535, "Desc": "contruct a beancontextmembershipevent"}{"node_name": "BeanContextMembershipEvent(java.beans.beancontext.BeanContext,java.lang.Object[])", "type": "constructor", "idx": 15538, "Desc": "contruct a beancontextmembershipevent"}{"node_name": "BeanContextServiceAvailableEvent(java.beans.beancontext.BeanContextServices,java.lang.Class)", "type": "constructor", "idx": 15555, "Desc": "construct a beancontextavailableserviceevent ."}{"node_name": "BeanContextServiceRevokedEvent(java.beans.beancontext.BeanContextServices,java.lang.Class,boolean)", "type": "constructor", "idx": 15578, "Desc": "construct a beancontextserviceevent ."}{"node_name": "BeanContextServicesSupport(java.beans.beancontext.BeanContextServices,java.util.Locale,boolean,boolean)", "type": "constructor", "idx": 15630, "Desc": "construct a beancontextservicessupport instance"}{"node_name": "BeanContextServicesSupport(java.beans.beancontext.BeanContextServices,java.util.Locale,boolean)", "type": "constructor", "idx": 15635, "Desc": "create an instance using the specified locale and design mode ."}{"node_name": "BeanContextServicesSupport(java.beans.beancontext.BeanContextServices,java.util.Locale)", "type": "constructor", "idx": 15639, "Desc": "create an instance using the specified locale"}{"node_name": "BeanContextServicesSupport(java.beans.beancontext.BeanContextServices)", "type": "constructor", "idx": 15642, "Desc": "create an instance with a peer"}{"node_name": "BeanContextServicesSupport()", "type": "constructor", "idx": 15644, "Desc": "create an instance that is not a delegate of another object"}{"node_name": "BeanContextSupport(java.beans.beancontext.BeanContext,java.util.Locale,boolean,boolean)", "type": "constructor", "idx": 15715, "Desc": "construct a beancontextsupport instance"}{"node_name": "BeanContextSupport(java.beans.beancontext.BeanContext,java.util.Locale,boolean)", "type": "constructor", "idx": 15720, "Desc": "create an instance using the specified locale and design mode ."}{"node_name": "BeanContextSupport(java.beans.beancontext.BeanContext,java.util.Locale)", "type": "constructor", "idx": 15724, "Desc": "create an instance using the specified locale"}{"node_name": "BeanContextSupport(java.beans.beancontext.BeanContext)", "type": "constructor", "idx": 15727, "Desc": "create an instance using with a default locale"}{"node_name": "BeanContextSupport()", "type": "constructor", "idx": 15729, "Desc": "create an instance that is not a delegate of another object"}{"node_name": "BeanDescriptor(java.lang.Class)", "type": "constructor", "idx": 15837, "Desc": "create a beandescriptor for a bean that doesn't have a customizer ."}{"node_name": "BeanDescriptor(java.lang.Class,java.lang.Class)", "type": "constructor", "idx": 15839, "Desc": "create a beandescriptor for a bean that has a customizer ."}{"node_name": "Beans()", "type": "constructor", "idx": 15860, "Desc": ""}{"node_name": "DefaultPersistenceDelegate()", "type": "constructor", "idx": 15889, "Desc": "creates a persistence delegate for a class with a nullary constructor ."}{"node_name": "DefaultPersistenceDelegate(java.lang.String[])", "type": "constructor", "idx": 15890, "Desc": "creates a default persistence delegate for a class with a constructor whose arguments are the values of the property names as specified by constructorpropertynames . <init>(java.lang.String[]) arguments are created by evaluating the property names in the order they are supplied . to use this class to specify a single preferred constructor for use in the serialization of a particular type , we state the names of the properties that make up <init>(java.lang.String[])'s arguments . for example , the font class which does not define a nullary constructor can be handled with the following persistence delegate : new defaultpersistencedelegate ( new string [ ] { \" name \" , \" style \" , \" size \" } );"}{"node_name": "Encoder()", "type": "constructor", "idx": 15909, "Desc": ""}{"node_name": "EventHandler(java.lang.Object,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 15929, "Desc": "creates a new eventhandler object ; you generally use one of the create methods instead of invoking <init>(java.lang.Object,java.lang.String,java.lang.String,java.lang.String) directly . refer to the general version of create for a complete description of the eventpropertyname and listenermethodname parameter ."}{"node_name": "EventSetDescriptor(java.lang.Class,java.lang.String,java.lang.Class,java.lang.String)", "type": "constructor", "idx": 15958, "Desc": "creates an eventsetdescriptor assuming that you are following the most simple standard design pattern where a named event \" fred \" is ( 1 ) delivered as a call on the single method of interface fredlistener , ( 2 ) has a single argument of type fredevent , and ( 3 ) where the fredlistener may be registered with a call on an addfredlistener method of the source component and removed with a call on a removefredlistener method ."}{"node_name": "EventSetDescriptor(java.lang.Class,java.lang.String,java.lang.Class,java.lang.String[],java.lang.String,java.lang.String)", "type": "constructor", "idx": 15963, "Desc": "creates an eventsetdescriptor from scratch using string names ."}{"node_name": "EventSetDescriptor(java.lang.Class,java.lang.String,java.lang.Class,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 15970, "Desc": "<init>(java.lang.Class,java.lang.String,java.lang.Class,java.lang.String[],java.lang.String,java.lang.String,java.lang.String) creates an eventsetdescriptor from scratch using string names ."}{"node_name": "EventSetDescriptor(java.lang.String,java.lang.Class,java.lang.reflect.Method[],java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 15978, "Desc": "creates an eventsetdescriptor from scratch using java.lang.reflect.method and java.lang.class objects ."}{"node_name": "EventSetDescriptor(java.lang.String,java.lang.Class,java.lang.reflect.Method[],java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 15984, "Desc": "<init>(java.lang.String,java.lang.Class,java.lang.reflect.Method[],java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method) creates an eventsetdescriptor from scratch using java.lang.reflect.method and java.lang.class objects ."}{"node_name": "EventSetDescriptor(java.lang.String,java.lang.Class,java.beans.MethodDescriptor[],java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 15991, "Desc": "creates an eventsetdescriptor from scratch using java.lang.reflect.methoddescriptor and java.lang.class objects ."}{"node_name": "Expression(java.lang.Object,java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 16013, "Desc": "creates a new expression object for the specified target object to invoke the method specified by the name and by the array of arguments . the target and the methodname values should not be null . otherwise an attempt to execute this expression will result in a nullpointerexception . if the arguments value is null , an empty array is used as the value of the arguments property ."}{"node_name": "Expression(java.lang.Object,java.lang.Object,java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 16017, "Desc": "creates a new expression object with the specified value for the specified target object to invoke the method specified by the name and by the array of arguments . the value value is used as the value of the value property , so the getvalue() method will return it without executing this expression . the target and the methodname values should not be null . otherwise an attempt to execute this expression will result in a nullpointerexception . if the arguments value is null , an empty array is used as the value of the arguments property ."}{"node_name": "FeatureDescriptor()", "type": "constructor", "idx": 16028, "Desc": "constructs a featuredescriptor ."}{"node_name": "IndexedPropertyChangeEvent(java.lang.Object,java.lang.String,java.lang.Object,java.lang.Object,int)", "type": "constructor", "idx": 16055, "Desc": "constructs a new indexedpropertychangeevent object ."}{"node_name": "IndexedPropertyDescriptor(java.lang.String,java.lang.Class)", "type": "constructor", "idx": 16063, "Desc": "<init>(java.lang.String,java.lang.Class) constructs an indexedpropertydescriptor for a property that follows the standard java conventions by having getfoo and setfoo accessor methods , for both indexed access and array access . thus if the argument name is \" fred \" , it will assume that there is an indexed reader method \" getfred \" , a non-indexed ( array ) reader method also called \" getfred \" , an indexed writer method \" setfred \" , and finally a non-indexed writer method \" setfred \" ."}{"node_name": "IndexedPropertyDescriptor(java.lang.String,java.lang.Class,java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 16066, "Desc": "<init>(java.lang.String,java.lang.Class,java.lang.String,java.lang.String,java.lang.String,java.lang.String) takes the name of a simple property , and method names for reading and writing the property , both indexed and non-indexed ."}{"node_name": "IndexedPropertyDescriptor(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 16073, "Desc": "<init>(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method,java.lang.reflect.Method) takes the name of a simple property , and method objects for reading and writing the property ."}{"node_name": "IntrospectionException(java.lang.String)", "type": "constructor", "idx": 16090, "Desc": "constructs an introspectionexception with a detailed message ."}{"node_name": "MethodDescriptor(java.lang.reflect.Method)", "type": "constructor", "idx": 16115, "Desc": "constructs a methoddescriptor from a method ."}{"node_name": "MethodDescriptor(java.lang.reflect.Method,java.beans.ParameterDescriptor[])", "type": "constructor", "idx": 16117, "Desc": "constructs a methoddescriptor from a method providing descriptive information for each of the method's parameters ."}{"node_name": "ParameterDescriptor()", "type": "constructor", "idx": 16123, "Desc": "public default constructor ."}{"node_name": "PersistenceDelegate()", "type": "constructor", "idx": 16125, "Desc": ""}{"node_name": "PropertyChangeEvent(java.lang.Object,java.lang.String,java.lang.Object,java.lang.Object)", "type": "constructor", "idx": 16141, "Desc": "constructs a new propertychangeevent ."}{"node_name": "PropertyChangeListenerProxy(java.lang.String,java.beans.PropertyChangeListener)", "type": "constructor", "idx": 16157, "Desc": "constructor which binds the propertychangelistener to a specific property ."}{"node_name": "PropertyChangeSupport(java.lang.Object)", "type": "constructor", "idx": 16164, "Desc": "constructs a propertychangesupport object ."}{"node_name": "PropertyDescriptor(java.lang.String,java.lang.Class)", "type": "constructor", "idx": 16211, "Desc": "constructs a propertydescriptor for a property that follows the standard java convention by having getfoo and setfoo accessor methods . thus if the argument name is \" fred \" , it will assume that the writer method is \" setfred \" and the reader method is \" getfred \" ( or \" isfred \" for a boolean property ) . note that the property name should start with a lower case character , which will be capitalized in the method names ."}{"node_name": "PropertyDescriptor(java.lang.String,java.lang.Class,java.lang.String,java.lang.String)", "type": "constructor", "idx": 16214, "Desc": "<init>(java.lang.String,java.lang.Class,java.lang.String,java.lang.String) takes the name of a simple property , and method names for reading and writing the property ."}{"node_name": "PropertyDescriptor(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 16219, "Desc": "<init>(java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method) takes the name of a simple property , and method objects for reading and writing the property ."}{"node_name": "PropertyEditorManager()", "type": "constructor", "idx": 16264, "Desc": ""}{"node_name": "PropertyEditorSupport()", "type": "constructor", "idx": 16274, "Desc": "constructs a propertyeditorsupport object ."}{"node_name": "PropertyEditorSupport(java.lang.Object)", "type": "constructor", "idx": 16275, "Desc": "constructs a propertyeditorsupport object ."}{"node_name": "PropertyVetoException(java.lang.String,java.beans.PropertyChangeEvent)", "type": "constructor", "idx": 16300, "Desc": "constructs a propertyvetoexception with a detailed message ."}{"node_name": "SimpleBeanInfo()", "type": "constructor", "idx": 16305, "Desc": ""}{"node_name": "Statement(java.lang.Object,java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 16318, "Desc": "creates a new statement object for the specified target object to invoke the method specified by the name and by the array of arguments . the target and the methodname values should not be null . otherwise an attempt to execute this expression will result in a nullpointerexception . if the arguments value is null , an empty array is used as the value of the arguments property ."}{"node_name": "VetoableChangeListenerProxy(java.lang.String,java.beans.VetoableChangeListener)", "type": "constructor", "idx": 16332, "Desc": "constructor which binds the vetoablechangelistener to a specific property ."}{"node_name": "VetoableChangeSupport(java.lang.Object)", "type": "constructor", "idx": 16339, "Desc": "constructs a vetoablechangesupport object ."}{"node_name": "XMLDecoder(java.io.InputStream)", "type": "constructor", "idx": 16376, "Desc": "creates a new input stream for reading archives created by the xmlencoder class ."}{"node_name": "XMLDecoder(java.io.InputStream,java.lang.Object)", "type": "constructor", "idx": 16378, "Desc": "creates a new input stream for reading archives created by the xmlencoder class ."}{"node_name": "XMLDecoder(java.io.InputStream,java.lang.Object,java.beans.ExceptionListener)", "type": "constructor", "idx": 16381, "Desc": "creates a new input stream for reading archives created by the xmlencoder class ."}{"node_name": "XMLDecoder(java.io.InputStream,java.lang.Object,java.beans.ExceptionListener,java.lang.ClassLoader)", "type": "constructor", "idx": 16385, "Desc": "creates a new input stream for reading archives created by the xmlencoder class ."}{"node_name": "XMLDecoder(org.xml.sax.InputSource)", "type": "constructor", "idx": 16390, "Desc": "creates a new decoder to parse xml archives created by the xmlencoder class . if the input source is is null , no exception is thrown and no parsing is performed . this behavior is similar to behavior of other constructors that use inputstream as a parameter ."}{"node_name": "XMLEncoder(java.io.OutputStream)", "type": "constructor", "idx": 16405, "Desc": "creates a new xml encoder to write out javabeans to the stream out using an xml encoding ."}{"node_name": "XMLEncoder(java.io.OutputStream,java.lang.String,boolean,int)", "type": "constructor", "idx": 16407, "Desc": "creates a new xml encoder to write out javabeans to the stream out using the given charset starting from the given indentation ."}{"node_name": "BufferedInputStream(java.io.InputStream)", "type": "constructor", "idx": 16429, "Desc": "creates a bufferedinputstream and saves its argument , the input stream in , for later use . an internal buffer array is created and stored in buf ."}{"node_name": "BufferedInputStream(java.io.InputStream,int)", "type": "constructor", "idx": 16431, "Desc": "creates a bufferedinputstream with the specified buffer size , and saves its argument , the input stream in , for later use . an internal buffer array of length size is created and stored in buf ."}{"node_name": "BufferedOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 16450, "Desc": "creates a new buffered output stream to write data to the specified underlying output stream ."}{"node_name": "BufferedOutputStream(java.io.OutputStream,int)", "type": "constructor", "idx": 16452, "Desc": "creates a new buffered output stream to write data to the specified underlying output stream with the specified buffer size ."}{"node_name": "BufferedReader(java.io.Reader,int)", "type": "constructor", "idx": 16463, "Desc": "creates a buffering character-input stream that uses an input buffer of the specified size ."}{"node_name": "BufferedReader(java.io.Reader)", "type": "constructor", "idx": 16466, "Desc": "creates a buffering character-input stream that uses a default-sized input buffer ."}{"node_name": "BufferedWriter(java.io.Writer)", "type": "constructor", "idx": 16483, "Desc": "creates a buffered character-output stream that uses a default-sized output buffer ."}{"node_name": "BufferedWriter(java.io.Writer,int)", "type": "constructor", "idx": 16485, "Desc": "creates a new buffered character-output stream that uses an output buffer of the given size ."}{"node_name": "ByteArrayInputStream(byte[])", "type": "constructor", "idx": 16505, "Desc": "creates a bytearrayinputstream so that it uses buf as its buffer array . the buffer array is not copied . the initial value of pos is 0 and the initial value of count is the length of buf ."}{"node_name": "ByteArrayInputStream(byte[],int,int)", "type": "constructor", "idx": 16507, "Desc": "creates bytearrayinputstream that uses buf as its buffer array . the initial value of pos is offset and the initial value of count is the minimum of offset+length and buf.length . the buffer array is not copied . the buffer's mark is set to the specified offset ."}{"node_name": "ByteArrayOutputStream()", "type": "constructor", "idx": 16527, "Desc": "creates a new bytearrayoutputstream . the buffer capacity is initially 32 bytes , though its size increases if necessary ."}{"node_name": "ByteArrayOutputStream(int)", "type": "constructor", "idx": 16528, "Desc": "creates a new bytearrayoutputstream , with a buffer capacity of the specified size , in bytes ."}{"node_name": "CharArrayReader(char[])", "type": "constructor", "idx": 16554, "Desc": "creates a chararrayreader from the specified array of chars ."}{"node_name": "CharArrayReader(char[],int,int)", "type": "constructor", "idx": 16556, "Desc": "creates a chararrayreader from the specified array of chars . the resulting reader will start reading at the given offset . the total number of char values that can be read from this reader will be either length or buf.length-offset , whichever is smaller ."}{"node_name": "CharArrayWriter()", "type": "constructor", "idx": 16576, "Desc": "creates a new chararraywriter ."}{"node_name": "CharArrayWriter(int)", "type": "constructor", "idx": 16577, "Desc": "creates a new chararraywriter with the specified initial size ."}{"node_name": "CharConversionException()", "type": "constructor", "idx": 16606, "Desc": "this provides no detailed message ."}{"node_name": "CharConversionException(java.lang.String)", "type": "constructor", "idx": 16607, "Desc": "this provides a detailed message ."}{"node_name": "DataInputStream(java.io.InputStream)", "type": "constructor", "idx": 16651, "Desc": "creates a datainputstream that uses the specified underlying inputstream ."}{"node_name": "DataOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 16713, "Desc": "creates a new data output stream to write data to the specified underlying output stream . the counter written is set to zero ."}{"node_name": "EOFException()", "type": "constructor", "idx": 16746, "Desc": "constructs an eofexception with null as its error detail message ."}{"node_name": "EOFException(java.lang.String)", "type": "constructor", "idx": 16747, "Desc": "constructs an eofexception with the specified detail message . the string s may later be retrieved by the throwable.getmessage() method of class java.lang.throwable ."}{"node_name": "File(java.lang.String)", "type": "constructor", "idx": 16759, "Desc": "creates a new file instance by converting the given pathname string into an abstract pathname . if the given string is the empty string , then the result is the empty abstract pathname ."}{"node_name": "File(java.lang.String,java.lang.String)", "type": "constructor", "idx": 16761, "Desc": "creates a new file instance from a parent pathname string and a child pathname string . if parent is null then the new file instance is created as if by invoking the single-argument file constructor on the given child pathname string . otherwise the parent pathname string is taken to denote a directory , and the child pathname string is taken to denote either a directory or a file . if the child pathname string is absolute then it is converted into a relative pathname in a system-dependent way . if parent is the empty string then the new file instance is created by converting child into an abstract pathname and resolving the result against a system-dependent default directory . otherwise each pathname string is converted into an abstract pathname and the child abstract pathname is resolved against the parent ."}{"node_name": "File(java.io.File,java.lang.String)", "type": "constructor", "idx": 16764, "Desc": "creates a new file instance from a parent abstract pathname and a child pathname string . if parent is null then the new file instance is created as if by invoking the single-argument file constructor on the given child pathname string . otherwise the parent abstract pathname is taken to denote a directory , and the child pathname string is taken to denote either a directory or a file . if the child pathname string is absolute then it is converted into a relative pathname in a system-dependent way . if parent is the empty abstract pathname then the new file instance is created by converting child into an abstract pathname and resolving the result against a system-dependent default directory . otherwise each pathname string is converted into an abstract pathname and the child abstract pathname is resolved against the parent ."}{"node_name": "File(java.net.URI)", "type": "constructor", "idx": 16767, "Desc": "creates a new file instance by converting the given file : uri into an abstract pathname . the exact form of a file : uri is system-dependent , hence the transformation performed by <init>(java.net.URI) is also system-dependent . for a given abstract pathname f it is guaranteed that new file ( f.touri() ) .equals ( f.getabsolutefile() ) so long as the original abstract pathname , the uri , and the new abstract pathname are all created in ( possibly different invocations of ) the same java virtual machine . this relationship typically does not hold , however , when a file : uri that is created in a virtual machine on one operating system is converted into an abstract pathname in a virtual machine on a different operating system ."}{"node_name": "FileDescriptor()", "type": "constructor", "idx": 16843, "Desc": "constructs an ( invalid ) filedescriptor object . the fd or handle is set later ."}{"node_name": "FileInputStream(java.lang.String)", "type": "constructor", "idx": 16850, "Desc": "creates a fileinputstream by opening a connection to an actual file , the file named by the path name name in the file system . a new filedescriptor object is created to represent this file connection . first , if there is a security manager , its checkread method is called with the name argument as its argument . if the named file does not exist , is a directory rather than a regular file , or for some other reason cannot be opened for reading then a filenotfoundexception is thrown ."}{"node_name": "FileInputStream(java.io.File)", "type": "constructor", "idx": 16852, "Desc": "creates a fileinputstream by opening a connection to an actual file , the file named by the file object file in the file system . a new filedescriptor object is created to represent this file connection . first , if there is a security manager , its checkread method is called with the path represented by the file argument as its argument . if the named file does not exist , is a directory rather than a regular file , or for some other reason cannot be opened for reading then a filenotfoundexception is thrown ."}{"node_name": "FileInputStream(java.io.FileDescriptor)", "type": "constructor", "idx": 16854, "Desc": "creates a fileinputstream by using the file descriptor fdobj , which represents an existing connection to an actual file in the file system . if there is a security manager , its checkread method is called with the file descriptor fdobj as its argument to see if it's ok to read the file descriptor . if read access is denied to the file descriptor a securityexception is thrown . if fdobj is null then a nullpointerexception is thrown . <init>(java.io.FileDescriptor) does not throw an exception if fdobj is invalid . however , if the methods are invoked on the resulting stream to attempt i / o on the stream , an ioexception is thrown ."}{"node_name": "FileNotFoundException()", "type": "constructor", "idx": 16874, "Desc": "constructs a filenotfoundexception with null as its error detail message ."}{"node_name": "FileNotFoundException(java.lang.String)", "type": "constructor", "idx": 16875, "Desc": "constructs a filenotfoundexception with the specified detail message . the string s can be retrieved later by the throwable.getmessage() method of class java.lang.throwable ."}{"node_name": "FileOutputStream(java.lang.String)", "type": "constructor", "idx": 16878, "Desc": "creates a file output stream to write to the file with the specified name . a new filedescriptor object is created to represent this file connection . first , if there is a security manager , its checkwrite method is called with name as its argument . if the file exists but is a directory rather than a regular file , does not exist but cannot be created , or cannot be opened for any other reason then a filenotfoundexception is thrown ."}{"node_name": "FileOutputStream(java.lang.String,boolean)", "type": "constructor", "idx": 16880, "Desc": "creates a file output stream to write to the file with the specified name . if the second argument is true , then bytes will be written to the end of the file rather than the beginning . a new filedescriptor object is created to represent this file connection . first , if there is a security manager , its checkwrite method is called with name as its argument . if the file exists but is a directory rather than a regular file , does not exist but cannot be created , or cannot be opened for any other reason then a filenotfoundexception is thrown ."}{"node_name": "FileOutputStream(java.io.File)", "type": "constructor", "idx": 16883, "Desc": "creates a file output stream to write to the file represented by the specified file object . a new filedescriptor object is created to represent this file connection . first , if there is a security manager , its checkwrite method is called with the path represented by the file argument as its argument . if the file exists but is a directory rather than a regular file , does not exist but cannot be created , or cannot be opened for any other reason then a filenotfoundexception is thrown ."}{"node_name": "FileOutputStream(java.io.File,boolean)", "type": "constructor", "idx": 16885, "Desc": "creates a file output stream to write to the file represented by the specified file object . if the second argument is true , then bytes will be written to the end of the file rather than the beginning . a new filedescriptor object is created to represent this file connection . first , if there is a security manager , its checkwrite method is called with the path represented by the file argument as its argument . if the file exists but is a directory rather than a regular file , does not exist but cannot be created , or cannot be opened for any other reason then a filenotfoundexception is thrown ."}{"node_name": "FileOutputStream(java.io.FileDescriptor)", "type": "constructor", "idx": 16888, "Desc": "creates a file output stream to write to the specified file descriptor , which represents an existing connection to an actual file in the file system . first , if there is a security manager , its checkwrite method is called with the file descriptor fdobj argument as its argument . if fdobj is null then a nullpointerexception is thrown . <init>(java.io.FileDescriptor) does not throw an exception if fdobj is invalid . however , if the methods are invoked on the resulting stream to attempt i / o on the stream , an ioexception is thrown ."}{"node_name": "FilePermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 16902, "Desc": "creates a new filepermission object with the specified actions . path is the pathname of a file or directory , and actions contains a comma-separated list of the desired actions granted on the file or directory . possible actions are \" read \" , \" write \" , \" execute \" , \" delete \" , and \" readlink \" . a pathname that ends in \" / * \" ( where \" / \" is the file separator character , file.separatorchar ) indicates all the files and directories contained in that directory . a pathname that ends with \" / - \" indicates ( recursively ) all files and subdirectories contained in that directory . the special pathname \" << all files >> \" matches any file . a pathname consisting of a single \" * \" indicates all the files in the current directory , while a pathname consisting of a single \" - \" indicates all the files in the current directory and ( recursively ) all files and subdirectories contained in the current directory . a pathname containing an empty string represents an empty path ."}{"node_name": "FileReader(java.lang.String)", "type": "constructor", "idx": 16913, "Desc": "creates a new filereader , given the name of the file to read , using the platform's default charset ."}{"node_name": "FileReader(java.io.File)", "type": "constructor", "idx": 16915, "Desc": "creates a new filereader , given the file to read , using the platform's default charset ."}{"node_name": "FileReader(java.io.FileDescriptor)", "type": "constructor", "idx": 16917, "Desc": "creates a new filereader , given the filedescriptor to read , using the platform's default charset ."}{"node_name": "FileReader(java.lang.String,java.nio.charset.Charset)", "type": "constructor", "idx": 16919, "Desc": "creates a new filereader , given the name of the file to read and the charset ."}{"node_name": "FileReader(java.io.File,java.nio.charset.Charset)", "type": "constructor", "idx": 16922, "Desc": "creates a new filereader , given the file to read and the charset ."}{"node_name": "FileWriter(java.lang.String)", "type": "constructor", "idx": 16926, "Desc": "constructs a filewriter given a file name , using the platform's default charset"}{"node_name": "FileWriter(java.lang.String,boolean)", "type": "constructor", "idx": 16928, "Desc": "constructs a filewriter given a file name and a boolean indicating whether to append the data written , using the platform's default charset ."}{"node_name": "FileWriter(java.io.File)", "type": "constructor", "idx": 16931, "Desc": "constructs a filewriter given the file to write , using the platform's default charset"}{"node_name": "FileWriter(java.io.File,boolean)", "type": "constructor", "idx": 16933, "Desc": "constructs a filewriter given the file to write and a boolean indicating whether to append the data written , using the platform's default charset ."}{"node_name": "FileWriter(java.io.FileDescriptor)", "type": "constructor", "idx": 16936, "Desc": "constructs a filewriter given a file descriptor , using the platform's default charset ."}{"node_name": "FileWriter(java.lang.String,java.nio.charset.Charset)", "type": "constructor", "idx": 16938, "Desc": "constructs a filewriter given a file name and charset ."}{"node_name": "FileWriter(java.lang.String,java.nio.charset.Charset,boolean)", "type": "constructor", "idx": 16941, "Desc": "constructs a filewriter given a file name , charset and a boolean indicating whether to append the data written ."}{"node_name": "FileWriter(java.io.File,java.nio.charset.Charset)", "type": "constructor", "idx": 16945, "Desc": "constructs a filewriter given the file to write and charset ."}{"node_name": "FileWriter(java.io.File,java.nio.charset.Charset,boolean)", "type": "constructor", "idx": 16948, "Desc": "constructs a filewriter given the file to write , charset and a boolean indicating whether to append the data written ."}{"node_name": "FilterInputStream(java.io.InputStream)", "type": "constructor", "idx": 16954, "Desc": "creates a filterinputstream by assigning the argument in to the field this.in so as to remember it for later use ."}{"node_name": "FilterOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 16973, "Desc": "creates an output stream filter built on top of the specified underlying output stream ."}{"node_name": "FilterReader(java.io.Reader)", "type": "constructor", "idx": 16987, "Desc": "creates a new filtered reader ."}{"node_name": "FilterWriter(java.io.Writer)", "type": "constructor", "idx": 17003, "Desc": "create a new filtered writer ."}{"node_name": "InputStream()", "type": "constructor", "idx": 17019, "Desc": ""}{"node_name": "InputStreamReader(java.io.InputStream)", "type": "constructor", "idx": 17048, "Desc": "creates an inputstreamreader that uses the default charset ."}{"node_name": "InputStreamReader(java.io.InputStream,java.lang.String)", "type": "constructor", "idx": 17050, "Desc": "creates an inputstreamreader that uses the named charset ."}{"node_name": "InputStreamReader(java.io.InputStream,java.nio.charset.Charset)", "type": "constructor", "idx": 17053, "Desc": "creates an inputstreamreader that uses the given charset ."}{"node_name": "InputStreamReader(java.io.InputStream,java.nio.charset.CharsetDecoder)", "type": "constructor", "idx": 17056, "Desc": "creates an inputstreamreader that uses the given charset decoder ."}{"node_name": "InterruptedIOException()", "type": "constructor", "idx": 17068, "Desc": "constructs an interruptedioexception with null as its error detail message ."}{"node_name": "InterruptedIOException(java.lang.String)", "type": "constructor", "idx": 17069, "Desc": "constructs an interruptedioexception with the specified detail message . the string s can be retrieved later by the throwable.getmessage() method of class java.lang.throwable ."}{"node_name": "InvalidClassException(java.lang.String)", "type": "constructor", "idx": 17073, "Desc": "report an invalidclassexception for the reason specified ."}{"node_name": "InvalidClassException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 17075, "Desc": "constructs an invalidclassexception object ."}{"node_name": "InvalidObjectException(java.lang.String)", "type": "constructor", "idx": 17080, "Desc": "constructs an invalidobjectexception ."}{"node_name": "IOError(java.lang.Throwable)", "type": "constructor", "idx": 17083, "Desc": "constructs a new instance of ioerror with the specified cause . the ioerror is created with the detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "IOException()", "type": "constructor", "idx": 17086, "Desc": "constructs an ioexception with null as its error detail message ."}{"node_name": "IOException(java.lang.String)", "type": "constructor", "idx": 17087, "Desc": "constructs an ioexception with the specified detail message ."}{"node_name": "IOException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 17089, "Desc": "constructs an ioexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated into this exception's detail message ."}{"node_name": "IOException(java.lang.Throwable)", "type": "constructor", "idx": 17092, "Desc": "constructs an ioexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for io exceptions that are little more than wrappers for other throwables ."}{"node_name": "LineNumberReader(java.io.Reader)", "type": "constructor", "idx": 17096, "Desc": "create a new line-numbering reader , using the default input-buffer size ."}{"node_name": "LineNumberReader(java.io.Reader,int)", "type": "constructor", "idx": 17098, "Desc": "create a new line-numbering reader , reading characters into a buffer of the given size ."}{"node_name": "NotActiveException(java.lang.String)", "type": "constructor", "idx": 17116, "Desc": "constructor to create a new notactiveexception with the reason given ."}{"node_name": "NotActiveException()", "type": "constructor", "idx": 17118, "Desc": "constructor to create a new notactiveexception without a reason ."}{"node_name": "NotSerializableException(java.lang.String)", "type": "constructor", "idx": 17120, "Desc": "constructs a notserializableexception object with message string ."}{"node_name": "NotSerializableException()", "type": "constructor", "idx": 17122, "Desc": "constructs a notserializableexception object ."}{"node_name": "GetField()", "type": "constructor", "idx": 17156, "Desc": ""}{"node_name": "ObjectInputStream(java.io.InputStream)", "type": "constructor", "idx": 17188, "Desc": "creates an objectinputstream that reads from the specified inputstream . a serialization stream header is read from the stream and verified . <init>(java.io.InputStream) will block until the corresponding objectoutputstream has written and flushed the header . the serialization filter is initialized to the value of the system-wide filter . if a security manager is installed , <init>(java.io.InputStream) will check for the \" enablesubclassimplementation \" serializablepermission when invoked directly or indirectly by <init>(java.io.InputStream) of a subclass which overrides the objectinputstream.readfields or objectinputstream.readunshared methods ."}{"node_name": "ObjectInputStream()", "type": "constructor", "idx": 17190, "Desc": "provide a way for subclasses that are completely reimplementing objectinputstream to not have to allocate private data just used by this implementation of objectinputstream . the serialization filter is initialized to the value of the system-wide filter . if there is a security manager installed , this method first calls the security manager's checkpermission method with the serializablepermission ( \" enablesubclassimplementation \") permission to ensure it's ok to enable subclassing ."}{"node_name": "ObjectOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 17254, "Desc": "creates an objectoutputstream that writes to the specified outputstream . <init>(java.io.OutputStream) writes the serialization stream header to the underlying stream ; callers may wish to flush the stream immediately to ensure <init>(java.io.OutputStream)s for receiving objectinputstreams will not block when reading the header . if a security manager is installed , <init>(java.io.OutputStream) will check for the \" enablesubclassimplementation \" serializablepermission when invoked directly or indirectly by <init>(java.io.OutputStream) of a subclass which overrides the objectoutputstream.putfields or objectoutputstream.writeunshared methods ."}{"node_name": "ObjectOutputStream()", "type": "constructor", "idx": 17256, "Desc": "provide a way for subclasses that are completely reimplementing objectoutputstream to not have to allocate private data just used by this implementation of objectoutputstream . if there is a security manager installed , this method first calls the security manager's checkpermission method with a serializablepermission ( \" enablesubclassimplementation \") permission to ensure it's ok to enable subclassing ."}{"node_name": "PutField()", "type": "constructor", "idx": 17314, "Desc": ""}{"node_name": "ObjectStreamException(java.lang.String)", "type": "constructor", "idx": 17387, "Desc": "create an objectstreamexception with the specified argument ."}{"node_name": "ObjectStreamException()", "type": "constructor", "idx": 17389, "Desc": "create an objectstreamexception ."}{"node_name": "ObjectStreamField(java.lang.String,java.lang.Class)", "type": "constructor", "idx": 17391, "Desc": "create a serializable field with the specified type . this field should be documented with a serialfield tag ."}{"node_name": "ObjectStreamField(java.lang.String,java.lang.Class,boolean)", "type": "constructor", "idx": 17394, "Desc": "creates an objectstreamfield representing a serializable field with the given name and type . if unshared is false , values of the represented field are serialized and deserialized in the default manner -- if the field is non-primitive , object values are serialized and deserialized as if they had been written and read by calls to writeobject and readobject . if unshared is true , values of the represented field are serialized and deserialized as if they had been written and read by calls to writeunshared and readunshared ."}{"node_name": "OutputStream()", "type": "constructor", "idx": 17414, "Desc": ""}{"node_name": "OutputStreamWriter(java.io.OutputStream,java.lang.String)", "type": "constructor", "idx": 17427, "Desc": "creates an outputstreamwriter that uses the named charset ."}{"node_name": "OutputStreamWriter(java.io.OutputStream)", "type": "constructor", "idx": 17430, "Desc": "creates an outputstreamwriter that uses the default character encoding ."}{"node_name": "OutputStreamWriter(java.io.OutputStream,java.nio.charset.Charset)", "type": "constructor", "idx": 17432, "Desc": "creates an outputstreamwriter that uses the given charset ."}{"node_name": "OutputStreamWriter(java.io.OutputStream,java.nio.charset.CharsetEncoder)", "type": "constructor", "idx": 17435, "Desc": "creates an outputstreamwriter that uses the given charset encoder ."}{"node_name": "PipedInputStream(java.io.PipedOutputStream)", "type": "constructor", "idx": 17455, "Desc": "creates a pipedinputstream so that it is connected to the piped output stream src . data bytes written to src will then be available as input from this stream ."}{"node_name": "PipedInputStream(java.io.PipedOutputStream,int)", "type": "constructor", "idx": 17457, "Desc": "creates a pipedinputstream so that it is connected to the piped output stream src and uses the specified pipe size for the pipe's buffer . data bytes written to src will then be available as input from this stream ."}{"node_name": "PipedInputStream()", "type": "constructor", "idx": 17460, "Desc": "creates a pipedinputstream so that it is not yet connected . it must be connected to a pipedoutputstream before being used ."}{"node_name": "PipedInputStream(int)", "type": "constructor", "idx": 17461, "Desc": "creates a pipedinputstream so that it is not yet connected and uses the specified pipe size for the pipe's buffer . it must be connected to a pipedoutputstream before being used ."}{"node_name": "PipedOutputStream(java.io.PipedInputStream)", "type": "constructor", "idx": 17475, "Desc": "creates a piped output stream connected to the specified piped input stream . data bytes written to this stream will then be available as input from snk ."}{"node_name": "PipedOutputStream()", "type": "constructor", "idx": 17477, "Desc": "creates a piped output stream that is not yet connected to a piped input stream . it must be connected to a piped input stream , either by the receiver or the sender , before being used ."}{"node_name": "PipedReader(java.io.PipedWriter)", "type": "constructor", "idx": 17489, "Desc": "creates a pipedreader so that it is connected to the piped writer src . data written to src will then be available as input from this stream ."}{"node_name": "PipedReader(java.io.PipedWriter,int)", "type": "constructor", "idx": 17491, "Desc": "creates a pipedreader so that it is connected to the piped writer src and uses the specified pipe size for the pipe's buffer . data written to src will then be available as input from this stream ."}{"node_name": "PipedReader()", "type": "constructor", "idx": 17494, "Desc": "creates a pipedreader so that it is not yet connected . it must be connected to a pipedwriter before being used ."}{"node_name": "PipedReader(int)", "type": "constructor", "idx": 17495, "Desc": "creates a pipedreader so that it is not yet connected and uses the specified pipe size for the pipe's buffer . it must be connected to a pipedwriter before being used ."}{"node_name": "PipedWriter(java.io.PipedReader)", "type": "constructor", "idx": 17507, "Desc": "creates a piped writer connected to the specified piped reader . data characters written to this stream will then be available as input from snk ."}{"node_name": "PipedWriter()", "type": "constructor", "idx": 17509, "Desc": "creates a piped writer that is not yet connected to a piped reader . it must be connected to a piped reader , either by the receiver or the sender , before being used ."}{"node_name": "PrintStream(java.io.OutputStream)", "type": "constructor", "idx": 17521, "Desc": "creates a new print stream . this stream will not flush automatically ."}{"node_name": "PrintStream(java.io.OutputStream,boolean)", "type": "constructor", "idx": 17523, "Desc": "creates a new print stream ."}{"node_name": "PrintStream(java.io.OutputStream,boolean,java.lang.String)", "type": "constructor", "idx": 17526, "Desc": "creates a new print stream ."}{"node_name": "PrintStream(java.io.OutputStream,boolean,java.nio.charset.Charset)", "type": "constructor", "idx": 17530, "Desc": "creates a new print stream , with the specified outputstream , automatic line flushing and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintStream(java.lang.String)", "type": "constructor", "idx": 17534, "Desc": "creates a new print stream , without automatic line flushing , with the specified file name . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the default charset for this instance of the java virtual machine ."}{"node_name": "PrintStream(java.lang.String,java.lang.String)", "type": "constructor", "idx": 17536, "Desc": "creates a new print stream , without automatic line flushing , with the specified file name and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintStream(java.lang.String,java.nio.charset.Charset)", "type": "constructor", "idx": 17539, "Desc": "creates a new print stream , without automatic line flushing , with the specified file name and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintStream(java.io.File)", "type": "constructor", "idx": 17542, "Desc": "creates a new print stream , without automatic line flushing , with the specified file . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the default charset for this instance of the java virtual machine ."}{"node_name": "PrintStream(java.io.File,java.lang.String)", "type": "constructor", "idx": 17544, "Desc": "creates a new print stream , without automatic line flushing , with the specified file and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintStream(java.io.File,java.nio.charset.Charset)", "type": "constructor", "idx": 17547, "Desc": "creates a new print stream , without automatic line flushing , with the specified file and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintWriter(java.io.Writer)", "type": "constructor", "idx": 17622, "Desc": "creates a new printwriter , without automatic line flushing ."}{"node_name": "PrintWriter(java.io.Writer,boolean)", "type": "constructor", "idx": 17624, "Desc": "creates a new printwriter ."}{"node_name": "PrintWriter(java.io.OutputStream)", "type": "constructor", "idx": 17627, "Desc": "creates a new printwriter , without automatic line flushing , from an existing outputstream . this convenience constructor creates the necessary intermediate outputstreamwriter , which will convert characters into bytes using the default character encoding ."}{"node_name": "PrintWriter(java.io.OutputStream,boolean)", "type": "constructor", "idx": 17629, "Desc": "creates a new printwriter from an existing outputstream . this convenience constructor creates the necessary intermediate outputstreamwriter , which will convert characters into bytes using the default character encoding ."}{"node_name": "PrintWriter(java.io.OutputStream,boolean,java.nio.charset.Charset)", "type": "constructor", "idx": 17632, "Desc": "creates a new printwriter from an existing outputstream . this convenience constructor creates the necessary intermediate outputstreamwriter , which will convert characters into bytes using the specified charset ."}{"node_name": "PrintWriter(java.lang.String)", "type": "constructor", "idx": 17636, "Desc": "creates a new printwriter , without automatic line flushing , with the specified file name . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the default charset for this instance of the java virtual machine ."}{"node_name": "PrintWriter(java.lang.String,java.lang.String)", "type": "constructor", "idx": 17638, "Desc": "creates a new printwriter , without automatic line flushing , with the specified file name and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintWriter(java.lang.String,java.nio.charset.Charset)", "type": "constructor", "idx": 17641, "Desc": "creates a new printwriter , without automatic line flushing , with the specified file name and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintWriter(java.io.File)", "type": "constructor", "idx": 17644, "Desc": "creates a new printwriter , without automatic line flushing , with the specified file . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the default charset for this instance of the java virtual machine ."}{"node_name": "PrintWriter(java.io.File,java.lang.String)", "type": "constructor", "idx": 17646, "Desc": "creates a new printwriter , without automatic line flushing , with the specified file and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PrintWriter(java.io.File,java.nio.charset.Charset)", "type": "constructor", "idx": 17649, "Desc": "creates a new printwriter , without automatic line flushing , with the specified file and charset . this convenience constructor creates the necessary intermediate outputstreamwriter , which will encode characters using the provided charset ."}{"node_name": "PushbackInputStream(java.io.InputStream,int)", "type": "constructor", "idx": 17733, "Desc": "creates a pushbackinputstream with a pushback buffer of the specified size , and saves its argument , the input stream in , for later use . initially , the pushback buffer is empty ."}{"node_name": "PushbackInputStream(java.io.InputStream)", "type": "constructor", "idx": 17736, "Desc": "creates a pushbackinputstream with a 1-byte pushback buffer , and saves its argument , the input stream in , for later use . initially , the pushback buffer is empty ."}{"node_name": "PushbackReader(java.io.Reader,int)", "type": "constructor", "idx": 17760, "Desc": "creates a new pushback reader with a pushback buffer of the given size ."}{"node_name": "PushbackReader(java.io.Reader)", "type": "constructor", "idx": 17763, "Desc": "creates a new pushback reader with a one-character pushback buffer ."}{"node_name": "RandomAccessFile(java.lang.String,java.lang.String)", "type": "constructor", "idx": 17787, "Desc": "creates a random access file stream to read from , and optionally to write to , a file with the specified name . a new filedescriptor object is created to represent the connection to the file . the mode argument specifies the access mode with which the file is to be opened . the permitted values and their meanings are as specified for the randomaccessfile ( file , string ) constructor . if there is a security manager , its checkread method is called with the name argument as its argument to see if read access to the file is allowed . if the mode allows writing , the security manager's checkwrite method is also called with the name argument as its argument to see if write access to the file is allowed ."}{"node_name": "RandomAccessFile(java.io.File,java.lang.String)", "type": "constructor", "idx": 17790, "Desc": "creates a random access file stream to read from , and optionally to write to , the file specified by the file argument . a new filedescriptor object is created to represent this file connection . the mode argument specifies the access mode in which the file is to be opened . the permitted values and their meanings are : access mode permitted values and meanings valuemeaning \" r \" open for reading only . invoking any of the write methods of the resulting object will cause an ioexception to be thrown . \" rw \" open for reading and writing . if the file does not already exist then an attempt will be made to create it . \" rws \" open for reading and writing , as with \" rw \" , and also require that every update to the file's content or metadata be written synchronously to the underlying storage device . \" rwd \" open for reading and writing , as with \" rw \" , and also require that every update to the file's content be written synchronously to the underlying storage device . the \" rws \" and \" rwd \" modes work much like the force ( boolean ) method of the filechannel class , passing arguments of true and false , respectively , except that they always apply to every i / o operation and are therefore often more efficient . if the file resides on a local storage device then when an invocation of a method of this class returns it is guaranteed that all changes made to the file by that invocation will have been written to that device . this is useful for ensuring that critical information is not lost in the event of a system crash . if the file does not reside on a local device then no such guarantee is made . the \" rwd \" mode can be used to reduce the number of i / o operations performed . using \" rwd \" only requires updates to the file's content to be written to storage ; using \" rws \" requires updates to both the file's content and its metadata to be written , which generally requires at least one more low-level i / o operation . if there is a security manager , its checkread method is called with the pathname of the file argument as its argument to see if read access to the file is allowed . if the mode allows writing , the security manager's checkwrite method is also called with the path argument to see if write access to the file is allowed ."}{"node_name": "Reader()", "type": "constructor", "idx": 17861, "Desc": "creates a new character-stream reader whose critical sections will synchronize on the reader itself ."}{"node_name": "Reader(java.lang.Object)", "type": "constructor", "idx": 17862, "Desc": "creates a new character-stream reader whose critical sections will synchronize on the given object ."}{"node_name": "SequenceInputStream(java.util.Enumeration)", "type": "constructor", "idx": 17885, "Desc": "initializes a newly created sequenceinputstream by remembering the argument , which must be an enumeration that produces objects whose run-time type is inputstream . the input streams that are produced by the enumeration will be read , in order , to provide the bytes to be read from this sequenceinputstream . after each input stream from the enumeration is exhausted , it is closed by calling its close method ."}{"node_name": "SequenceInputStream(java.io.InputStream,java.io.InputStream)", "type": "constructor", "idx": 17887, "Desc": "initializes a newly created sequenceinputstream by remembering the two arguments , which will be read in order , first s1 and then s2 , to provide the bytes to be read from this sequenceinputstream ."}{"node_name": "SerializablePermission(java.lang.String)", "type": "constructor", "idx": 17899, "Desc": "creates a new serializablepermission with the specified name . the name is the symbolic name of the serializablepermission , such as \" enablesubstitution \" , etc ."}{"node_name": "SerializablePermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 17901, "Desc": "creates a new serializablepermission object with the specified name . the name is the symbolic name of the serializablepermission , and the actions string is currently unused and should be null ."}{"node_name": "StreamCorruptedException(java.lang.String)", "type": "constructor", "idx": 17905, "Desc": "create a streamcorruptedexception and list a reason why thrown ."}{"node_name": "StreamCorruptedException()", "type": "constructor", "idx": 17907, "Desc": "create a streamcorruptedexception and list no reason why thrown ."}{"node_name": "StreamTokenizer(java.io.Reader)", "type": "constructor", "idx": 17916, "Desc": "create a tokenizer that parses the given character stream ."}{"node_name": "StringReader(java.lang.String)", "type": "constructor", "idx": 17949, "Desc": "creates a new string reader ."}{"node_name": "StringWriter()", "type": "constructor", "idx": 17965, "Desc": "create a new string writer using the default initial string-buffer size ."}{"node_name": "StringWriter(int)", "type": "constructor", "idx": 17966, "Desc": "create a new string writer using the specified initial string-buffer size ."}{"node_name": "SyncFailedException(java.lang.String)", "type": "constructor", "idx": 17993, "Desc": "constructs an syncfailedexception with a detail message . a detail message is a string that describes this particular exception ."}{"node_name": "UncheckedIOException(java.lang.String,java.io.IOException)", "type": "constructor", "idx": 17996, "Desc": "constructs an instance of this class ."}{"node_name": "UncheckedIOException(java.io.IOException)", "type": "constructor", "idx": 17999, "Desc": "constructs an instance of this class ."}{"node_name": "UnsupportedEncodingException()", "type": "constructor", "idx": 18003, "Desc": "constructs an unsupportedencodingexception without a detail message ."}{"node_name": "UnsupportedEncodingException(java.lang.String)", "type": "constructor", "idx": 18004, "Desc": "constructs an unsupportedencodingexception with a detail message ."}{"node_name": "UTFDataFormatException()", "type": "constructor", "idx": 18007, "Desc": "constructs a utfdataformatexception with null as its error detail message ."}{"node_name": "UTFDataFormatException(java.lang.String)", "type": "constructor", "idx": 18008, "Desc": "constructs a utfdataformatexception with the specified detail message . the string s can be retrieved later by the throwable.getmessage() method of class java.lang.throwable ."}{"node_name": "WriteAbortedException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 18012, "Desc": "constructs a writeabortedexception with a string describing the exception and the exception causing the abort ."}{"node_name": "Writer()", "type": "constructor", "idx": 18019, "Desc": "creates a new character-stream writer whose critical sections will synchronize on the writer itself ."}{"node_name": "Writer(java.lang.Object)", "type": "constructor", "idx": 18020, "Desc": "creates a new character-stream writer whose critical sections will synchronize on the given object ."}{"node_name": "AbstractMethodError()", "type": "constructor", "idx": 18048, "Desc": "constructs an abstractmethoderror with no detail message ."}{"node_name": "AbstractMethodError(java.lang.String)", "type": "constructor", "idx": 18049, "Desc": "constructs an abstractmethoderror with the specified detail message ."}{"node_name": "AnnotationFormatError(java.lang.String)", "type": "constructor", "idx": 18058, "Desc": "constructs a new annotationformaterror with the specified detail message ."}{"node_name": "AnnotationFormatError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 18060, "Desc": "constructs a new annotationformaterror with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this error's detail message ."}{"node_name": "AnnotationFormatError(java.lang.Throwable)", "type": "constructor", "idx": 18063, "Desc": "constructs a new annotationformaterror with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "AnnotationTypeMismatchException(java.lang.reflect.Method,java.lang.String)", "type": "constructor", "idx": 18066, "Desc": "constructs an annotationtypemismatchexception for the specified annotation type element and found data type ."}{"node_name": "IncompleteAnnotationException(java.lang.Class,java.lang.String)", "type": "constructor", "idx": 18077, "Desc": "constructs an incompleteannotationexception to indicate that the named element was missing from the specified annotation type ."}{"node_name": "ArithmeticException()", "type": "constructor", "idx": 18101, "Desc": "constructs an arithmeticexception with no detail message ."}{"node_name": "ArithmeticException(java.lang.String)", "type": "constructor", "idx": 18102, "Desc": "constructs an arithmeticexception with the specified detail message ."}{"node_name": "ArrayIndexOutOfBoundsException()", "type": "constructor", "idx": 18105, "Desc": "constructs an arrayindexoutofboundsexception with no detail message ."}{"node_name": "ArrayIndexOutOfBoundsException(java.lang.String)", "type": "constructor", "idx": 18106, "Desc": "constructs an arrayindexoutofboundsexception class with the specified detail message ."}{"node_name": "ArrayIndexOutOfBoundsException(int)", "type": "constructor", "idx": 18108, "Desc": "constructs a new arrayindexoutofboundsexception class with an argument indicating the illegal index . the index is included in this exception's detail message . the exact presentation format of the detail message is unspecified ."}{"node_name": "ArrayStoreException()", "type": "constructor", "idx": 18111, "Desc": "constructs an arraystoreexception with no detail message ."}{"node_name": "ArrayStoreException(java.lang.String)", "type": "constructor", "idx": 18112, "Desc": "constructs an arraystoreexception with the specified detail message ."}{"node_name": "AssertionError()", "type": "constructor", "idx": 18115, "Desc": "constructs an assertionerror with no detail message ."}{"node_name": "AssertionError(java.lang.Object)", "type": "constructor", "idx": 18116, "Desc": "constructs an assertionerror with its detail message derived from the specified object , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification . if the specified object is an instance of throwable , it becomes the cause of the newly constructed assertion error ."}{"node_name": "AssertionError(boolean)", "type": "constructor", "idx": 18118, "Desc": "constructs an assertionerror with its detail message derived from the specified boolean , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification ."}{"node_name": "AssertionError(char)", "type": "constructor", "idx": 18120, "Desc": "constructs an assertionerror with its detail message derived from the specified char , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification ."}{"node_name": "AssertionError(int)", "type": "constructor", "idx": 18122, "Desc": "constructs an assertionerror with its detail message derived from the specified int , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification ."}{"node_name": "AssertionError(long)", "type": "constructor", "idx": 18124, "Desc": "constructs an assertionerror with its detail message derived from the specified long , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification ."}{"node_name": "AssertionError(float)", "type": "constructor", "idx": 18126, "Desc": "constructs an assertionerror with its detail message derived from the specified float , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification ."}{"node_name": "AssertionError(double)", "type": "constructor", "idx": 18128, "Desc": "constructs an assertionerror with its detail message derived from the specified double , which is converted to a string as defined in section 15.18.1.1 of the java\u2122 language specification ."}{"node_name": "AssertionError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 18130, "Desc": "constructs a new assertionerror with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this error's detail message ."}{"node_name": "BootstrapMethodError()", "type": "constructor", "idx": 18171, "Desc": "constructs a bootstrapmethoderror with no detail message ."}{"node_name": "BootstrapMethodError(java.lang.String)", "type": "constructor", "idx": 18172, "Desc": "constructs a bootstrapmethoderror with the specified detail message ."}{"node_name": "BootstrapMethodError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 18174, "Desc": "constructs a bootstrapmethoderror with the specified detail message and cause ."}{"node_name": "BootstrapMethodError(java.lang.Throwable)", "type": "constructor", "idx": 18177, "Desc": "constructs a bootstrapmethoderror with the specified cause ."}{"node_name": "Subset(java.lang.String)", "type": "constructor", "idx": 18489, "Desc": "constructs a new subset instance ."}{"node_name": "ClassCastException()", "type": "constructor", "idx": 18924, "Desc": "constructs a classcastexception with no detail message ."}{"node_name": "ClassCastException(java.lang.String)", "type": "constructor", "idx": 18925, "Desc": "constructs a classcastexception with the specified detail message ."}{"node_name": "ClassCircularityError()", "type": "constructor", "idx": 18928, "Desc": "constructs a classcircularityerror with no detail message ."}{"node_name": "ClassCircularityError(java.lang.String)", "type": "constructor", "idx": 18929, "Desc": "constructs a classcircularityerror with the specified detail message ."}{"node_name": "ClassFormatError()", "type": "constructor", "idx": 18932, "Desc": "constructs a classformaterror with no detail message ."}{"node_name": "ClassFormatError(java.lang.String)", "type": "constructor", "idx": 18933, "Desc": "constructs a classformaterror with the specified detail message ."}{"node_name": "ClassLoader(java.lang.String,java.lang.ClassLoader)", "type": "constructor", "idx": 18936, "Desc": "creates a new class loader of the specified name and using the specified parent class loader for delegation ."}{"node_name": "ClassLoader(java.lang.ClassLoader)", "type": "constructor", "idx": 18939, "Desc": "creates a new class loader using the specified parent class loader for delegation . if there is a security manager , its checkcreateclassloader method is invoked . this may result in a security exception ."}{"node_name": "ClassLoader()", "type": "constructor", "idx": 18941, "Desc": "creates a new class loader using the classloader returned by the method getsystemclassloader() as the parent class loader . if there is a security manager , its checkcreateclassloader method is invoked . this may result in a security exception ."}{"node_name": "ClassNotFoundException()", "type": "constructor", "idx": 19031, "Desc": "constructs a classnotfoundexception with no detail message ."}{"node_name": "ClassNotFoundException(java.lang.String)", "type": "constructor", "idx": 19032, "Desc": "constructs a classnotfoundexception with the specified detail message ."}{"node_name": "ClassNotFoundException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19034, "Desc": "constructs a classnotfoundexception with the specified detail message and optional exception that was raised while loading the class ."}{"node_name": "ClassValue()", "type": "constructor", "idx": 19039, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "CloneNotSupportedException()", "type": "constructor", "idx": 19048, "Desc": "constructs a clonenotsupportedexception with no detail message ."}{"node_name": "CloneNotSupportedException(java.lang.String)", "type": "constructor", "idx": 19049, "Desc": "constructs a clonenotsupportedexception with the specified detail message ."}{"node_name": "DynamicConstantDesc(java.lang.constant.DirectMethodHandleDesc,java.lang.String,java.lang.constant.ClassDesc,java.lang.constant.ConstantDesc...)", "type": "constructor", "idx": 19197, "Desc": "creates a nominal descriptor for a dynamic constant ."}{"node_name": "Enum(java.lang.String,int)", "type": "constructor", "idx": 19346, "Desc": "sole constructor . programmers cannot invoke <init>(java.lang.String,int) . it is for use by code emitted by the compiler in response to enum type declarations ."}{"node_name": "EnumConstantNotPresentException(java.lang.Class,java.lang.String)", "type": "constructor", "idx": 19365, "Desc": "constructs an enumconstantnotpresentexception for the specified constant ."}{"node_name": "Error()", "type": "constructor", "idx": 19371, "Desc": "constructs a new error with null as its detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "Error(java.lang.String)", "type": "constructor", "idx": 19372, "Desc": "constructs a new error with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "Error(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19374, "Desc": "constructs a new error with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this error's detail message ."}{"node_name": "Error(java.lang.Throwable)", "type": "constructor", "idx": 19377, "Desc": "constructs a new error with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for errors that are little more than wrappers for other throwables ."}{"node_name": "Error(java.lang.String,java.lang.Throwable,boolean,boolean)", "type": "constructor", "idx": 19379, "Desc": "constructs a new error with the specified detail message , cause , suppression enabled or disabled , and writable stack trace enabled or disabled ."}{"node_name": "Exception()", "type": "constructor", "idx": 19385, "Desc": "constructs a new exception with null as its detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "Exception(java.lang.String)", "type": "constructor", "idx": 19386, "Desc": "constructs a new exception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "Exception(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19388, "Desc": "constructs a new exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "Exception(java.lang.Throwable)", "type": "constructor", "idx": 19391, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for exceptions that are little more than wrappers for other throwables ( for example , privilegedactionexception ) ."}{"node_name": "Exception(java.lang.String,java.lang.Throwable,boolean,boolean)", "type": "constructor", "idx": 19393, "Desc": "constructs a new exception with the specified detail message , cause , suppression enabled or disabled , and writable stack trace enabled or disabled ."}{"node_name": "ExceptionInInitializerError()", "type": "constructor", "idx": 19399, "Desc": "constructs an exceptionininitializererror with null as its detail message string and with no saved throwable object . a detail message is a string that describes this particular exception ."}{"node_name": "ExceptionInInitializerError(java.lang.Throwable)", "type": "constructor", "idx": 19400, "Desc": "constructs a new exceptionininitializererror class by saving a reference to the throwable object thrown for later retrieval by the getexception() method . the detail message string is set to null ."}{"node_name": "ExceptionInInitializerError(java.lang.String)", "type": "constructor", "idx": 19402, "Desc": "constructs an exceptionininitializererror with the specified detail message string . a detail message is a string that describes this particular exception . the detail message string is saved for later retrieval by the throwable.getmessage() method . there is no saved throwable object ."}{"node_name": "IllegalAccessError()", "type": "constructor", "idx": 19471, "Desc": "constructs an illegalaccesserror with no detail message ."}{"node_name": "IllegalAccessError(java.lang.String)", "type": "constructor", "idx": 19472, "Desc": "constructs an illegalaccesserror with the specified detail message ."}{"node_name": "IllegalAccessException()", "type": "constructor", "idx": 19475, "Desc": "constructs an illegalaccessexception without a detail message ."}{"node_name": "IllegalAccessException(java.lang.String)", "type": "constructor", "idx": 19476, "Desc": "constructs an illegalaccessexception with a detail message ."}{"node_name": "IllegalArgumentException()", "type": "constructor", "idx": 19479, "Desc": "constructs an illegalargumentexception with no detail message ."}{"node_name": "IllegalArgumentException(java.lang.String)", "type": "constructor", "idx": 19480, "Desc": "constructs an illegalargumentexception with the specified detail message ."}{"node_name": "IllegalArgumentException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19482, "Desc": "constructs a new exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "IllegalArgumentException(java.lang.Throwable)", "type": "constructor", "idx": 19485, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for exceptions that are little more than wrappers for other throwables ( for example , privilegedactionexception ) ."}{"node_name": "IllegalCallerException()", "type": "constructor", "idx": 19488, "Desc": "constructs an illegalcallerexception with no detail message ."}{"node_name": "IllegalCallerException(java.lang.String)", "type": "constructor", "idx": 19489, "Desc": "constructs an illegalcallerexception with the specified detail message ."}{"node_name": "IllegalCallerException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19491, "Desc": "constructs a new exception with the specified detail message and cause ."}{"node_name": "IllegalCallerException(java.lang.Throwable)", "type": "constructor", "idx": 19494, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "IllegalMonitorStateException()", "type": "constructor", "idx": 19497, "Desc": "constructs an illegalmonitorstateexception with no detail message ."}{"node_name": "IllegalMonitorStateException(java.lang.String)", "type": "constructor", "idx": 19498, "Desc": "constructs an illegalmonitorstateexception with the specified detail message ."}{"node_name": "IllegalStateException()", "type": "constructor", "idx": 19501, "Desc": "constructs an illegalstateexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "IllegalStateException(java.lang.String)", "type": "constructor", "idx": 19502, "Desc": "constructs an illegalstateexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "IllegalStateException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19504, "Desc": "constructs a new exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "IllegalStateException(java.lang.Throwable)", "type": "constructor", "idx": 19507, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for exceptions that are little more than wrappers for other throwables ( for example , privilegedactionexception ) ."}{"node_name": "IllegalThreadStateException()", "type": "constructor", "idx": 19510, "Desc": "constructs an illegalthreadstateexception with no detail message ."}{"node_name": "IllegalThreadStateException(java.lang.String)", "type": "constructor", "idx": 19511, "Desc": "constructs an illegalthreadstateexception with the specified detail message ."}{"node_name": "IncompatibleClassChangeError()", "type": "constructor", "idx": 19514, "Desc": "constructs an incompatibleclasschangeerror with no detail message ."}{"node_name": "IncompatibleClassChangeError(java.lang.String)", "type": "constructor", "idx": 19515, "Desc": "constructs an incompatibleclasschangeerror with the specified detail message ."}{"node_name": "IndexOutOfBoundsException()", "type": "constructor", "idx": 19518, "Desc": "constructs an indexoutofboundsexception with no detail message ."}{"node_name": "IndexOutOfBoundsException(java.lang.String)", "type": "constructor", "idx": 19519, "Desc": "constructs an indexoutofboundsexception with the specified detail message ."}{"node_name": "IndexOutOfBoundsException(int)", "type": "constructor", "idx": 19521, "Desc": "constructs a new indexoutofboundsexception class with an argument indicating the illegal index . the index is included in this exception's detail message . the exact presentation format of the detail message is unspecified ."}{"node_name": "InheritableThreadLocal()", "type": "constructor", "idx": 19524, "Desc": ""}{"node_name": "InstantiationError()", "type": "constructor", "idx": 19528, "Desc": "constructs an instantiationerror with no detail message ."}{"node_name": "InstantiationError(java.lang.String)", "type": "constructor", "idx": 19529, "Desc": "constructs an instantiationerror with the specified detail message ."}{"node_name": "InstantiationException()", "type": "constructor", "idx": 19532, "Desc": "constructs an instantiationexception with no detail message ."}{"node_name": "InstantiationException(java.lang.String)", "type": "constructor", "idx": 19533, "Desc": "constructs an instantiationexception with the specified detail message ."}{"node_name": "ClassDefinition(java.lang.Class,byte[])", "type": "constructor", "idx": 19536, "Desc": "creates a new classdefinition binding using the supplied class and class file bytes . does not copy the supplied buffer , just captures a reference to it ."}{"node_name": "IllegalClassFormatException()", "type": "constructor", "idx": 19556, "Desc": "constructs an illegalclassformatexception with no detail message ."}{"node_name": "IllegalClassFormatException(java.lang.String)", "type": "constructor", "idx": 19557, "Desc": "constructs an illegalclassformatexception with the specified detail message ."}{"node_name": "UnmodifiableClassException()", "type": "constructor", "idx": 19598, "Desc": "constructs an unmodifiableclassexception with no detail message ."}{"node_name": "UnmodifiableClassException(java.lang.String)", "type": "constructor", "idx": 19599, "Desc": "constructs an unmodifiableclassexception with the specified detail message ."}{"node_name": "UnmodifiableModuleException()", "type": "constructor", "idx": 19602, "Desc": "constructs an unmodifiablemoduleexception with no detail message ."}{"node_name": "UnmodifiableModuleException(java.lang.String)", "type": "constructor", "idx": 19603, "Desc": "constructs an unmodifiablemoduleexception with the specified detail message ."}{"node_name": "InternalError()", "type": "constructor", "idx": 19726, "Desc": "constructs an internalerror with no detail message ."}{"node_name": "InternalError(java.lang.String)", "type": "constructor", "idx": 19727, "Desc": "constructs an internalerror with the specified detail message ."}{"node_name": "InternalError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19729, "Desc": "constructs an internalerror with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this error's detail message ."}{"node_name": "InternalError(java.lang.Throwable)", "type": "constructor", "idx": 19732, "Desc": "constructs an internalerror with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "InterruptedException()", "type": "constructor", "idx": 19735, "Desc": "constructs an interruptedexception with no detail message ."}{"node_name": "InterruptedException(java.lang.String)", "type": "constructor", "idx": 19736, "Desc": "constructs an interruptedexception with the specified detail message ."}{"node_name": "ConstantBootstraps()", "type": "constructor", "idx": 19745, "Desc": ""}{"node_name": "ConstantCallSite(java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 19791, "Desc": "creates a call site with a permanent target ."}{"node_name": "ConstantCallSite(java.lang.invoke.MethodType,java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 19793, "Desc": "creates a call site with a permanent target , possibly bound to the call site itself . during construction of the call site , the createtargethook is invoked to produce the actual target , as if by a call of the form ( methodhandle ) createtargethook.invoke ( this ) . note that user code cannot perform such an action directly in a subclass constructor , since the target must be fixed before the constantcallsite constructor returns . the hook is said to bind the call site to a target method handle , and a typical action would be sometarget.bindto ( this ) . however , the hook is free to take any action whatever , including ignoring the call site and returning a constant target . the result returned by the hook must be a method handle of exactly the same type as the call site . while the hook is being called , the new constantcallsite object is in a partially constructed state . in this state , a call to gettarget , or any other attempt to use the target , will result in an illegalstateexception . it is legal at all times to obtain the call site's type using the type method ."}{"node_name": "LambdaConversionException()", "type": "constructor", "idx": 19801, "Desc": "constructs a lambdaconversionexception ."}{"node_name": "LambdaConversionException(java.lang.String)", "type": "constructor", "idx": 19802, "Desc": "constructs a lambdaconversionexception with a message ."}{"node_name": "LambdaConversionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 19804, "Desc": "constructs a lambdaconversionexception with a message and cause ."}{"node_name": "LambdaConversionException(java.lang.Throwable)", "type": "constructor", "idx": 19807, "Desc": "constructs a lambdaconversionexception with a cause ."}{"node_name": "LambdaConversionException(java.lang.String,java.lang.Throwable,boolean,boolean)", "type": "constructor", "idx": 19809, "Desc": "constructs a lambdaconversionexception with a message , cause , and other settings ."}{"node_name": "MutableCallSite(java.lang.invoke.MethodType)", "type": "constructor", "idx": 20174, "Desc": "creates a blank call site object with the given method type . the initial target is set to a method handle of the given type which will throw an illegalstateexception if called . the type of the call site is permanently set to the given type . before this callsite object is returned from a bootstrap method , or invoked in some other manner , it is usually provided with a more useful target method , via a call to settarget ."}{"node_name": "MutableCallSite(java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 20176, "Desc": "creates a call site object with an initial target method handle . the type of the call site is permanently set to the initial target's type ."}{"node_name": "SerializedLambda(java.lang.Class,java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 20184, "Desc": "create a serializedlambda from the low-level information present at the lambda factory site ."}{"node_name": "StringConcatException(java.lang.String)", "type": "constructor", "idx": 20208, "Desc": "constructs an exception with a message"}{"node_name": "StringConcatException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 20210, "Desc": "constructs an exception with a message and a linked throwable"}{"node_name": "SwitchPoint()", "type": "constructor", "idx": 20225, "Desc": "creates a new switch point ."}{"node_name": "VolatileCallSite(java.lang.invoke.MethodType)", "type": "constructor", "idx": 20358, "Desc": "creates a call site with a volatile binding to its target . the initial target is set to a method handle of the given type which will throw an illegalstateexception if called ."}{"node_name": "VolatileCallSite(java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 20360, "Desc": "creates a call site with a volatile binding to its target . the target is set to the given value ."}{"node_name": "WrongMethodTypeException()", "type": "constructor", "idx": 20366, "Desc": "constructs a wrongmethodtypeexception with no detail message ."}{"node_name": "WrongMethodTypeException(java.lang.String)", "type": "constructor", "idx": 20367, "Desc": "constructs a wrongmethodtypeexception with the specified detail message ."}{"node_name": "LayerInstantiationException()", "type": "constructor", "idx": 20375, "Desc": "constructs a layerinstantiationexception with no detail message ."}{"node_name": "LayerInstantiationException(java.lang.String)", "type": "constructor", "idx": 20376, "Desc": "constructs a layerinstantiationexception with the given detail message ."}{"node_name": "LayerInstantiationException(java.lang.Throwable)", "type": "constructor", "idx": 20378, "Desc": "constructs a layerinstantiationexception with the given cause ."}{"node_name": "LayerInstantiationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 20380, "Desc": "constructs a layerinstantiationexception with the given detail message and cause ."}{"node_name": "LinkageError()", "type": "constructor", "idx": 20384, "Desc": "constructs a linkageerror with no detail message ."}{"node_name": "LinkageError(java.lang.String)", "type": "constructor", "idx": 20385, "Desc": "constructs a linkageerror with the specified detail message ."}{"node_name": "LinkageError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 20387, "Desc": "constructs a linkageerror with the specified detail message and cause ."}{"node_name": "LockInfo(java.lang.String,int)", "type": "constructor", "idx": 20528, "Desc": "constructs a lockinfo object ."}{"node_name": "ManagementPermission(java.lang.String)", "type": "constructor", "idx": 20572, "Desc": "constructs a managementpermission with the specified name ."}{"node_name": "ManagementPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 20574, "Desc": "constructs a new managementpermission object ."}{"node_name": "MemoryNotificationInfo(java.lang.String,java.lang.management.MemoryUsage,long)", "type": "constructor", "idx": 20592, "Desc": "constructs a memorynotificationinfo object ."}{"node_name": "MemoryUsage(long,long,long,long)", "type": "constructor", "idx": 20628, "Desc": "constructs a memoryusage object ."}{"node_name": "MonitorInfo(java.lang.String,int,int,java.lang.StackTraceElement)", "type": "constructor", "idx": 20641, "Desc": "construct a monitorinfo object ."}{"node_name": "FindException()", "type": "constructor", "idx": 20984, "Desc": "constructs a findexception with no detail message ."}{"node_name": "FindException(java.lang.String)", "type": "constructor", "idx": 20985, "Desc": "constructs a findexception with the given detail message ."}{"node_name": "FindException(java.lang.Throwable)", "type": "constructor", "idx": 20987, "Desc": "constructs a findexception with the given cause ."}{"node_name": "FindException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 20989, "Desc": "constructs a findexception with the given detail message and cause ."}{"node_name": "InvalidModuleDescriptorException()", "type": "constructor", "idx": 20993, "Desc": "constructs an invalidmoduledescriptorexception with no detail message ."}{"node_name": "InvalidModuleDescriptorException(java.lang.String)", "type": "constructor", "idx": 20994, "Desc": "constructs an invalidmoduledescriptorexception with the specified detail message ."}{"node_name": "ModuleReference(java.lang.module.ModuleDescriptor,java.net.URI)", "type": "constructor", "idx": 21218, "Desc": "constructs a new instance of this class ."}{"node_name": "ResolutionException()", "type": "constructor", "idx": 21225, "Desc": "constructs a resolutionexception with no detail message ."}{"node_name": "ResolutionException(java.lang.String)", "type": "constructor", "idx": 21226, "Desc": "constructs a resolutionexception with the given detail message ."}{"node_name": "ResolutionException(java.lang.Throwable)", "type": "constructor", "idx": 21228, "Desc": "constructs an instance of this exception with the given cause ."}{"node_name": "ResolutionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 21230, "Desc": "constructs a resolutionexception with the given detail message and cause ."}{"node_name": "NegativeArraySizeException()", "type": "constructor", "idx": 21288, "Desc": "constructs a negativearraysizeexception with no detail message ."}{"node_name": "NegativeArraySizeException(java.lang.String)", "type": "constructor", "idx": 21289, "Desc": "constructs a negativearraysizeexception with the specified detail message ."}{"node_name": "NoClassDefFoundError()", "type": "constructor", "idx": 21292, "Desc": "constructs a noclassdeffounderror with no detail message ."}{"node_name": "NoClassDefFoundError(java.lang.String)", "type": "constructor", "idx": 21293, "Desc": "constructs a noclassdeffounderror with the specified detail message ."}{"node_name": "NoSuchFieldError()", "type": "constructor", "idx": 21296, "Desc": "constructs a nosuchfielderror with no detail message ."}{"node_name": "NoSuchFieldError(java.lang.String)", "type": "constructor", "idx": 21297, "Desc": "constructs a nosuchfielderror with the specified detail message ."}{"node_name": "NoSuchFieldException()", "type": "constructor", "idx": 21300, "Desc": "constructor ."}{"node_name": "NoSuchFieldException(java.lang.String)", "type": "constructor", "idx": 21301, "Desc": "constructor with a detail message ."}{"node_name": "NoSuchMethodError()", "type": "constructor", "idx": 21304, "Desc": "constructs a nosuchmethoderror with no detail message ."}{"node_name": "NoSuchMethodError(java.lang.String)", "type": "constructor", "idx": 21305, "Desc": "constructs a nosuchmethoderror with the specified detail message ."}{"node_name": "NoSuchMethodException()", "type": "constructor", "idx": 21308, "Desc": "constructs a nosuchmethodexception without a detail message ."}{"node_name": "NoSuchMethodException(java.lang.String)", "type": "constructor", "idx": 21309, "Desc": "constructs a nosuchmethodexception with a detail message ."}{"node_name": "NullPointerException()", "type": "constructor", "idx": 21312, "Desc": "constructs a nullpointerexception with no detail message ."}{"node_name": "NullPointerException(java.lang.String)", "type": "constructor", "idx": 21313, "Desc": "constructs a nullpointerexception with the specified detail message ."}{"node_name": "Number()", "type": "constructor", "idx": 21316, "Desc": "constructor for subclasses to call ."}{"node_name": "NumberFormatException()", "type": "constructor", "idx": 21324, "Desc": "constructs a numberformatexception with no detail message ."}{"node_name": "NumberFormatException(java.lang.String)", "type": "constructor", "idx": 21325, "Desc": "constructs a numberformatexception with the specified detail message ."}{"node_name": "Object()", "type": "constructor", "idx": 21328, "Desc": "constructs a new object ."}{"node_name": "OutOfMemoryError()", "type": "constructor", "idx": 21344, "Desc": "constructs an outofmemoryerror with no detail message ."}{"node_name": "OutOfMemoryError(java.lang.String)", "type": "constructor", "idx": 21345, "Desc": "constructs an outofmemoryerror with the specified detail message ."}{"node_name": "Process()", "type": "constructor", "idx": 21377, "Desc": "default constructor for process ."}{"node_name": "ProcessBuilder(java.util.List)", "type": "constructor", "idx": 21397, "Desc": "constructs a process builder with the specified operating system program and arguments . <init>(java.util.List) does not make a copy of the command list . subsequent updates to the list will be reflected in the state of the process builder . it is not checked whether command corresponds to a valid operating system command ."}{"node_name": "ProcessBuilder(java.lang.String...)", "type": "constructor", "idx": 21399, "Desc": "constructs a process builder with the specified operating system program and arguments . this is a convenience constructor that sets the process builder's command to a string list containing the same strings as the command array , in the same order . it is not checked whether command corresponds to a valid operating system command ."}{"node_name": "PhantomReference(java.lang.Object,java.lang.ref.ReferenceQueue)", "type": "constructor", "idx": 21491, "Desc": "creates a new phantom reference that refers to the given object and is registered with the given queue . it is possible to create a phantom reference with a null queue , but such a reference is completely useless : its get method will always return null and , since it does not have a queue , it will never be enqueued ."}{"node_name": "ReferenceQueue()", "type": "constructor", "idx": 21504, "Desc": "constructs a new reference-object queue ."}{"node_name": "SoftReference(java.lang.Object)", "type": "constructor", "idx": 21510, "Desc": "creates a new soft reference that refers to the given object . the new reference is not registered with any queue ."}{"node_name": "SoftReference(java.lang.Object,java.lang.ref.ReferenceQueue)", "type": "constructor", "idx": 21512, "Desc": "creates a new soft reference that refers to the given object and is registered with the given queue ."}{"node_name": "WeakReference(java.lang.Object)", "type": "constructor", "idx": 21517, "Desc": "creates a new weak reference that refers to the given object . the new reference is not registered with any queue ."}{"node_name": "WeakReference(java.lang.Object,java.lang.ref.ReferenceQueue)", "type": "constructor", "idx": 21519, "Desc": "creates a new weak reference that refers to the given object and is registered with the given queue ."}{"node_name": "AccessibleObject()", "type": "constructor", "idx": 21523, "Desc": "constructor : only used by the java virtual machine ."}{"node_name": "GenericSignatureFormatError()", "type": "constructor", "idx": 21762, "Desc": "constructs a new genericsignatureformaterror ."}{"node_name": "GenericSignatureFormatError(java.lang.String)", "type": "constructor", "idx": 21763, "Desc": "constructs a new genericsignatureformaterror with the specified message ."}{"node_name": "InaccessibleObjectException()", "type": "constructor", "idx": 21766, "Desc": "constructs an inaccessibleobjectexception with no detail message ."}{"node_name": "InaccessibleObjectException(java.lang.String)", "type": "constructor", "idx": 21767, "Desc": "constructs an inaccessibleobjectexception with the given detail message ."}{"node_name": "InvocationTargetException()", "type": "constructor", "idx": 21775, "Desc": "constructs an invocationtargetexception with null as the target exception ."}{"node_name": "InvocationTargetException(java.lang.Throwable)", "type": "constructor", "idx": 21776, "Desc": "constructs a invocationtargetexception with a target exception ."}{"node_name": "InvocationTargetException(java.lang.Throwable,java.lang.String)", "type": "constructor", "idx": 21778, "Desc": "constructs a invocationtargetexception with a target exception and a detail message ."}{"node_name": "MalformedParameterizedTypeException()", "type": "constructor", "idx": 21784, "Desc": "constructs a malformedparameterizedtypeexception with no detail message ."}{"node_name": "MalformedParameterizedTypeException(java.lang.String)", "type": "constructor", "idx": 21785, "Desc": "constructs a malformedparameterizedtypeexception with the given detail message ."}{"node_name": "MalformedParametersException()", "type": "constructor", "idx": 21788, "Desc": "create a malformedparametersexception with an empty reason ."}{"node_name": "MalformedParametersException(java.lang.String)", "type": "constructor", "idx": 21789, "Desc": "create a malformedparametersexception ."}{"node_name": "Modifier()", "type": "constructor", "idx": 21840, "Desc": ""}{"node_name": "Proxy(java.lang.reflect.InvocationHandler)", "type": "constructor", "idx": 21902, "Desc": "constructs a new proxy instance from a subclass ( typically , a dynamic proxy class ) with the specified value for its invocation handler ."}{"node_name": "ReflectPermission(java.lang.String)", "type": "constructor", "idx": 21913, "Desc": "constructs a reflectpermission with the specified name ."}{"node_name": "ReflectPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 21915, "Desc": "constructs a reflectpermission with the specified name and actions . the actions should be null ; they are ignored ."}{"node_name": "UndeclaredThrowableException(java.lang.Throwable)", "type": "constructor", "idx": 21926, "Desc": "constructs an undeclaredthrowableexception with the specified throwable ."}{"node_name": "UndeclaredThrowableException(java.lang.Throwable,java.lang.String)", "type": "constructor", "idx": 21928, "Desc": "constructs an undeclaredthrowableexception with the specified throwable and a detail message ."}{"node_name": "ReflectiveOperationException()", "type": "constructor", "idx": 21936, "Desc": "constructs a new exception with null as its detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "ReflectiveOperationException(java.lang.String)", "type": "constructor", "idx": 21937, "Desc": "constructs a new exception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "ReflectiveOperationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 21939, "Desc": "constructs a new exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "ReflectiveOperationException(java.lang.Throwable)", "type": "constructor", "idx": 21942, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "RuntimeException()", "type": "constructor", "idx": 22007, "Desc": "constructs a new runtime exception with null as its detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "RuntimeException(java.lang.String)", "type": "constructor", "idx": 22008, "Desc": "constructs a new runtime exception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "RuntimeException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 22010, "Desc": "constructs a new runtime exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this runtime exception's detail message ."}{"node_name": "RuntimeException(java.lang.Throwable)", "type": "constructor", "idx": 22013, "Desc": "constructs a new runtime exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for runtime exceptions that are little more than wrappers for other throwables ."}{"node_name": "RuntimeException(java.lang.String,java.lang.Throwable,boolean,boolean)", "type": "constructor", "idx": 22015, "Desc": "constructs a new runtime exception with the specified detail message , cause , suppression enabled or disabled , and writable stack trace enabled or disabled ."}{"node_name": "RuntimePermission(java.lang.String)", "type": "constructor", "idx": 22021, "Desc": "creates a new runtimepermission with the specified name . the name is the symbolic name of the runtimepermission , such as \" exit \" , \" setfactory \" , etc . an asterisk may appear at the end of the name , following a \" . \" , or by itself , to signify a wildcard match ."}{"node_name": "RuntimePermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 22023, "Desc": "creates a new runtimepermission object with the specified name . the name is the symbolic name of the runtimepermission , and the actions string is currently unused and should be null ."}{"node_name": "SecurityException()", "type": "constructor", "idx": 22028, "Desc": "constructs a securityexception with no detail message ."}{"node_name": "SecurityException(java.lang.String)", "type": "constructor", "idx": 22029, "Desc": "constructs a securityexception with the specified detail message ."}{"node_name": "SecurityException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 22031, "Desc": "creates a securityexception with the specified detail message and cause ."}{"node_name": "SecurityException(java.lang.Throwable)", "type": "constructor", "idx": 22034, "Desc": "creates a securityexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "SecurityManager()", "type": "constructor", "idx": 22037, "Desc": "constructs a new securitymanager . if there is a security manager already installed , this method first calls the security manager's checkpermission method with the runtimepermission ( \" createsecuritymanager \") permission to ensure the calling thread has permission to create a new security manager . this may result in throwing a securityexception ."}{"node_name": "StackOverflowError()", "type": "constructor", "idx": 22143, "Desc": "constructs a stackoverflowerror with no detail message ."}{"node_name": "StackOverflowError(java.lang.String)", "type": "constructor", "idx": 22144, "Desc": "constructs a stackoverflowerror with the specified detail message ."}{"node_name": "StackTraceElement(java.lang.String,java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 22147, "Desc": "creates a stack trace element representing the specified execution point . the module name and module version of the stack trace element will be null ."}{"node_name": "StackTraceElement(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 22152, "Desc": "creates a stack trace element representing the specified execution point ."}{"node_name": "String()", "type": "constructor", "idx": 22390, "Desc": "initializes a newly created string object so that it represents an empty character sequence . note that use of <init>() is unnecessary since strings are immutable ."}{"node_name": "String(java.lang.String)", "type": "constructor", "idx": 22391, "Desc": "initializes a newly created string object so that it represents the same sequence of characters as the argument ; in other words , the newly created string is a copy of the argument string . unless an explicit copy of original is needed , use of <init>(java.lang.String) is unnecessary since strings are immutable ."}{"node_name": "String(char[])", "type": "constructor", "idx": 22393, "Desc": "allocates a new string so that it represents the sequence of characters currently contained in the character array argument . the contents of the character array are copied ; subsequent modification of the character array does not affect the newly created string ."}{"node_name": "String(char[],int,int)", "type": "constructor", "idx": 22395, "Desc": "allocates a new string that contains characters from a subarray of the character array argument . the offset argument is the index of the first character of the subarray and the count argument specifies the length of the subarray . the contents of the subarray are copied ; subsequent modification of the character array does not affect the newly created string ."}{"node_name": "String(int[],int,int)", "type": "constructor", "idx": 22399, "Desc": "allocates a new string that contains characters from a subarray of the unicode code point array argument . the offset argument is the index of the first code point of the subarray and the count argument specifies the length of the subarray . the contents of the subarray are converted to chars ; subsequent modification of the int array does not affect the newly created string ."}{"node_name": "String(byte[],int,int,java.lang.String)", "type": "constructor", "idx": 22403, "Desc": "constructs a new string by decoding the specified subarray of bytes using the specified charset . the length of the new string is a function of the charset , and hence may not be equal to the length of the subarray . the behavior of <init>(byte[],int,int,java.lang.String) when the given bytes are not valid in the given charset is unspecified . the charsetdecoder class should be used when more control over the decoding process is required ."}{"node_name": "String(byte[],int,int,java.nio.charset.Charset)", "type": "constructor", "idx": 22408, "Desc": "constructs a new string by decoding the specified subarray of bytes using the specified charset . the length of the new string is a function of the charset , and hence may not be equal to the length of the subarray . this method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string . the charsetdecoder class should be used when more control over the decoding process is required ."}{"node_name": "String(byte[],java.lang.String)", "type": "constructor", "idx": 22413, "Desc": "constructs a new string by decoding the specified array of bytes using the specified charset . the length of the new string is a function of the charset , and hence may not be equal to the length of the byte array . the behavior of <init>(byte[],java.lang.String) when the given bytes are not valid in the given charset is unspecified . the charsetdecoder class should be used when more control over the decoding process is required ."}{"node_name": "String(byte[],java.nio.charset.Charset)", "type": "constructor", "idx": 22416, "Desc": "constructs a new string by decoding the specified array of bytes using the specified charset . the length of the new string is a function of the charset , and hence may not be equal to the length of the byte array . this method always replaces malformed-input and unmappable-character sequences with this charset's default replacement string . the charsetdecoder class should be used when more control over the decoding process is required ."}{"node_name": "String(byte[],int,int)", "type": "constructor", "idx": 22419, "Desc": "constructs a new string by decoding the specified subarray of bytes using the platform's default charset . the length of the new string is a function of the charset , and hence may not be equal to the length of the subarray . the behavior of <init>(byte[],int,int) when the given bytes are not valid in the default charset is unspecified . the charsetdecoder class should be used when more control over the decoding process is required ."}{"node_name": "String(byte[])", "type": "constructor", "idx": 22423, "Desc": "constructs a new string by decoding the specified array of bytes using the platform's default charset . the length of the new string is a function of the charset , and hence may not be equal to the length of the byte array . the behavior of <init>(byte[]) when the given bytes are not valid in the default charset is unspecified . the charsetdecoder class should be used when more control over the decoding process is required ."}{"node_name": "String(java.lang.StringBuffer)", "type": "constructor", "idx": 22425, "Desc": "allocates a new string that contains the sequence of characters currently contained in the string buffer argument . the contents of the string buffer are copied ; subsequent modification of the string buffer does not affect the newly created string ."}{"node_name": "String(java.lang.StringBuilder)", "type": "constructor", "idx": 22427, "Desc": "allocates a new string that contains the sequence of characters currently contained in the string builder argument . the contents of the string builder are copied ; subsequent modification of the string builder does not affect the newly created string . <init>(java.lang.StringBuilder) is provided to ease migration to stringbuilder . obtaining a string from a string builder via the tostring method is likely to run faster and is generally preferred ."}{"node_name": "StringBuffer()", "type": "constructor", "idx": 22601, "Desc": "constructs a string buffer with no characters in it and an initial capacity of 16 characters ."}{"node_name": "StringBuffer(int)", "type": "constructor", "idx": 22602, "Desc": "constructs a string buffer with no characters in it and the specified initial capacity ."}{"node_name": "StringBuffer(java.lang.String)", "type": "constructor", "idx": 22604, "Desc": "constructs a string buffer initialized to the contents of the specified string . the initial capacity of the string buffer is 16 plus the length of the string argument ."}{"node_name": "StringBuffer(java.lang.CharSequence)", "type": "constructor", "idx": 22606, "Desc": "constructs a string buffer that contains the same characters as the specified charsequence . the initial capacity of the string buffer is 16 plus the length of the charsequence argument ."}{"node_name": "StringBuilder()", "type": "constructor", "idx": 22739, "Desc": "constructs a string builder with no characters in it and an initial capacity of 16 characters ."}{"node_name": "StringBuilder(int)", "type": "constructor", "idx": 22740, "Desc": "constructs a string builder with no characters in it and an initial capacity specified by the capacity argument ."}{"node_name": "StringBuilder(java.lang.String)", "type": "constructor", "idx": 22742, "Desc": "constructs a string builder initialized to the contents of the specified string . the initial capacity of the string builder is 16 plus the length of the string argument ."}{"node_name": "StringBuilder(java.lang.CharSequence)", "type": "constructor", "idx": 22744, "Desc": "constructs a string builder that contains the same characters as the specified charsequence . the initial capacity of the string builder is 16 plus the length of the charsequence argument ."}{"node_name": "StringIndexOutOfBoundsException()", "type": "constructor", "idx": 22878, "Desc": "constructs a stringindexoutofboundsexception with no detail message ."}{"node_name": "StringIndexOutOfBoundsException(java.lang.String)", "type": "constructor", "idx": 22879, "Desc": "constructs a stringindexoutofboundsexception with the specified detail message ."}{"node_name": "StringIndexOutOfBoundsException(int)", "type": "constructor", "idx": 22881, "Desc": "constructs a new stringindexoutofboundsexception class with an argument indicating the illegal index . the index is included in this exception's detail message . the exact presentation format of the detail message is unspecified ."}{"node_name": "LoggerFinder()", "type": "constructor", "idx": 22983, "Desc": "creates a new instance of loggerfinder ."}{"node_name": "Thread()", "type": "constructor", "idx": 22996, "Desc": "allocates a new thread object . <init>() has the same effect as thread ( null , null , gname ) , where gname is a newly generated name . automatically generated names are of the form \" thread- \" +n , where n is an integer ."}{"node_name": "Thread(java.lang.Runnable)", "type": "constructor", "idx": 22997, "Desc": "allocates a new thread object . <init>(java.lang.Runnable) has the same effect as thread ( null , target , gname ) , where gname is a newly generated name . automatically generated names are of the form \" thread- \" +n , where n is an integer ."}{"node_name": "Thread(java.lang.ThreadGroup,java.lang.Runnable)", "type": "constructor", "idx": 22999, "Desc": "allocates a new thread object . <init>(java.lang.ThreadGroup,java.lang.Runnable) has the same effect as thread ( group , target , gname ) , where gname is a newly generated name . automatically generated names are of the form \" thread- \" +n , where n is an integer ."}{"node_name": "Thread(java.lang.String)", "type": "constructor", "idx": 23002, "Desc": "allocates a new thread object . <init>(java.lang.String) has the same effect as thread ( null , null , name ) ."}{"node_name": "Thread(java.lang.ThreadGroup,java.lang.String)", "type": "constructor", "idx": 23004, "Desc": "allocates a new thread object . <init>(java.lang.ThreadGroup,java.lang.String) has the same effect as thread ( group , null , name ) ."}{"node_name": "Thread(java.lang.Runnable,java.lang.String)", "type": "constructor", "idx": 23007, "Desc": "allocates a new thread object . <init>(java.lang.Runnable,java.lang.String) has the same effect as thread ( null , target , name ) ."}{"node_name": "Thread(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String)", "type": "constructor", "idx": 23010, "Desc": "allocates a new thread object so that it has target as its run object , has the specified name as its name , and belongs to the thread group referred to by group . if there is a security manager , its checkaccess method is invoked with the threadgroup as its argument . in addition , its checkpermission method is invoked with the runtimepermission ( \" enablecontextclassloaderoverride \") permission when invoked directly or indirectly by <init>(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String) of a subclass which overrides the getcontextclassloader or setcontextclassloader methods . the priority of the newly created thread is set equal to the priority of the thread creating it , that is , the currently running thread . the method setpriority may be used to change the priority to a new value . the newly created thread is initially marked as being a daemon thread if and only if the thread creating it is currently marked as a daemon thread . the method setdaemon may be used to change whether or not a thread is a daemon ."}{"node_name": "Thread(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long)", "type": "constructor", "idx": 23014, "Desc": "allocates a new thread object so that it has target as its run object , has the specified name as its name , and belongs to the thread group referred to by group , and has the specified stack size . <init>(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long) is identical to thread ( threadgroup , runnable , string ) with the exception of the fact that it allows the thread stack size to be specified . the stack size is the approximate number of bytes of address space that the virtual machine is to allocate for this thread's stack . the effect of the stacksize parameter , if any , is highly platform dependent . on some platforms , specifying a higher value for the stacksize parameter may allow a thread to achieve greater recursion depth before throwing a stackoverflowerror . similarly , specifying a lower value may allow a greater number of threads to exist concurrently without throwing an outofmemoryerror ( or other internal error ) . the details of the relationship between the value of the stacksize parameter and the maximum recursion depth and concurrency level are platform-dependent . on some platforms , the value of the stacksize parameter may have no effect whatsoever . the virtual machine is free to treat the stacksize parameter as a suggestion . if the specified value is unreasonably low for the platform , the virtual machine may instead use some platform-specific minimum value ; if the specified value is unreasonably high , the virtual machine may instead use some platform-specific maximum . likewise , the virtual machine is free to round the specified value up or down as it sees fit ( or to ignore it completely ) . specifying a value of zero for the stacksize parameter will cause <init>(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long) to behave exactly like the thread ( threadgroup , runnable , string ) constructor . due to the platform-dependent nature of the behavior of <init>(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long) , extreme care should be exercised in its use . the thread stack size necessary to perform a given computation will likely vary from one jre implementation to another . in light of this variation , careful tuning of the stack size parameter may be required , and the tuning may need to be repeated for each jre implementation on which an application is to run . implementation note : java platform implementers are encouraged to document their implementation's behavior with respect to the stacksize parameter ."}{"node_name": "Thread(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long,boolean)", "type": "constructor", "idx": 23019, "Desc": "allocates a new thread object so that it has target as its run object , has the specified name as its name , belongs to the thread group referred to by group , has the specified stacksize , and inherits initial values for inheritable thread-local variables if inheritthreadlocals is true . <init>(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long,boolean) is identical to thread ( threadgroup , runnable , string , long ) with the added ability to suppress , or not , the inheriting of initial values for inheritable thread-local variables from the constructing thread . this allows for finer grain control over inheritable thread-locals . care must be taken when passing a value of false for inheritthreadlocals , as it may lead to unexpected behavior if the new thread executes code that expects a specific thread-local value to be inherited . specifying a value of true for the inheritthreadlocals parameter will cause <init>(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long,boolean) to behave exactly like the thread ( threadgroup , runnable , string , long ) constructor ."}{"node_name": "ThreadDeath()", "type": "constructor", "idx": 23086, "Desc": ""}{"node_name": "ThreadGroup(java.lang.String)", "type": "constructor", "idx": 23088, "Desc": "constructs a new thread group . the parent of this new group is the thread group of the currently running thread . the checkaccess method of the parent thread group is called with no arguments ; this may result in a security exception ."}{"node_name": "ThreadGroup(java.lang.ThreadGroup,java.lang.String)", "type": "constructor", "idx": 23090, "Desc": "creates a new thread group . the parent of this new group is the specified thread group . the checkaccess method of the parent thread group is called with no arguments ; this may result in a security exception ."}{"node_name": "ThreadLocal()", "type": "constructor", "idx": 23125, "Desc": "creates a thread local variable ."}{"node_name": "Throwable()", "type": "constructor", "idx": 23134, "Desc": "constructs a new throwable with null as its detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ( java.lang.throwable ) . the fillinstacktrace() method is called to initialize the stack trace data in the newly created throwable ."}{"node_name": "Throwable(java.lang.String)", "type": "constructor", "idx": 23135, "Desc": "constructs a new throwable with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ( java.lang.throwable ) . the fillinstacktrace() method is called to initialize the stack trace data in the newly created throwable ."}{"node_name": "Throwable(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 23137, "Desc": "constructs a new throwable with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this throwable's detail message . the fillinstacktrace() method is called to initialize the stack trace data in the newly created throwable ."}{"node_name": "Throwable(java.lang.Throwable)", "type": "constructor", "idx": 23140, "Desc": "constructs a new throwable with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for throwables that are little more than wrappers for other throwables ( for example , privilegedactionexception ) . the fillinstacktrace() method is called to initialize the stack trace data in the newly created throwable ."}{"node_name": "Throwable(java.lang.String,java.lang.Throwable,boolean,boolean)", "type": "constructor", "idx": 23142, "Desc": "constructs a new throwable with the specified detail message , cause , suppression enabled or disabled , and writable stack trace enabled or disabled . if suppression is disabled , getsuppressed() for this object will return a zero-length array and calls to addsuppressed ( java.lang.throwable ) that would otherwise append an exception to the suppressed list will have no effect . if the writable stack trace is false , <init>(java.lang.String,java.lang.Throwable,boolean,boolean) will not call fillinstacktrace() , a null will be written to the stacktrace field , and subsequent calls to fillinstacktrace and setstacktrace ( stacktraceelement [ ]) will not set the stack trace . if the writable stack trace is false , getstacktrace() will return a zero length array . note that the other constructors of throwable treat suppression as being enabled and the stack trace as being writable . subclasses of throwable should document any conditions under which suppression is disabled and document conditions under which the stack trace is not writable . disabling of suppression should only occur in exceptional circumstances where special requirements exist , such as a virtual machine reusing exception objects under low-memory situations . circumstances where a given exception object is repeatedly caught and rethrown , such as to implement control flow between two sub-systems , is another situation where immutable throwable objects would be appropriate ."}{"node_name": "TypeNotPresentException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 23166, "Desc": "constructs a typenotpresentexception for the named type with the specified cause ."}{"node_name": "UnknownError()", "type": "constructor", "idx": 23171, "Desc": "constructs an unknownerror with no detail message ."}{"node_name": "UnknownError(java.lang.String)", "type": "constructor", "idx": 23172, "Desc": "constructs an unknownerror with the specified detail message ."}{"node_name": "UnsatisfiedLinkError()", "type": "constructor", "idx": 23175, "Desc": "constructs an unsatisfiedlinkerror with no detail message ."}{"node_name": "UnsatisfiedLinkError(java.lang.String)", "type": "constructor", "idx": 23176, "Desc": "constructs an unsatisfiedlinkerror with the specified detail message ."}{"node_name": "UnsupportedClassVersionError()", "type": "constructor", "idx": 23179, "Desc": "constructs a unsupportedclassversionerror with no detail message ."}{"node_name": "UnsupportedClassVersionError(java.lang.String)", "type": "constructor", "idx": 23180, "Desc": "constructs a unsupportedclassversionerror with the specified detail message ."}{"node_name": "UnsupportedOperationException()", "type": "constructor", "idx": 23183, "Desc": "constructs an unsupportedoperationexception with no detail message ."}{"node_name": "UnsupportedOperationException(java.lang.String)", "type": "constructor", "idx": 23184, "Desc": "constructs an unsupportedoperationexception with the specified detail message ."}{"node_name": "UnsupportedOperationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 23186, "Desc": "constructs a new exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "UnsupportedOperationException(java.lang.Throwable)", "type": "constructor", "idx": 23189, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) . <init>(java.lang.Throwable) is useful for exceptions that are little more than wrappers for other throwables ( for example , privilegedactionexception ) ."}{"node_name": "VerifyError()", "type": "constructor", "idx": 23192, "Desc": "constructs an verifyerror with no detail message ."}{"node_name": "VerifyError(java.lang.String)", "type": "constructor", "idx": 23193, "Desc": "constructs an verifyerror with the specified detail message ."}{"node_name": "VirtualMachineError()", "type": "constructor", "idx": 23196, "Desc": "constructs a virtualmachineerror with no detail message ."}{"node_name": "VirtualMachineError(java.lang.String)", "type": "constructor", "idx": 23197, "Desc": "constructs a virtualmachineerror with the specified detail message ."}{"node_name": "VirtualMachineError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 23199, "Desc": "constructs a virtualmachineerror with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this error's detail message ."}{"node_name": "VirtualMachineError(java.lang.Throwable)", "type": "constructor", "idx": 23202, "Desc": "constructs an a virtualmachineerror with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "BigDecimal(char[],int,int)", "type": "constructor", "idx": 23210, "Desc": "translates a character array representation of a bigdecimal into a bigdecimal , accepting the same sequence of characters as the bigdecimal ( string ) constructor , while allowing a sub-array to be specified ."}{"node_name": "BigDecimal(char[],int,int,java.math.MathContext)", "type": "constructor", "idx": 23214, "Desc": "translates a character array representation of a bigdecimal into a bigdecimal , accepting the same sequence of characters as the bigdecimal ( string ) constructor , while allowing a sub-array to be specified and with rounding according to the context settings ."}{"node_name": "BigDecimal(char[])", "type": "constructor", "idx": 23219, "Desc": "translates a character array representation of a bigdecimal into a bigdecimal , accepting the same sequence of characters as the bigdecimal ( string ) constructor ."}{"node_name": "BigDecimal(char[],java.math.MathContext)", "type": "constructor", "idx": 23221, "Desc": "translates a character array representation of a bigdecimal into a bigdecimal , accepting the same sequence of characters as the bigdecimal ( string ) constructor and with rounding according to the context settings ."}{"node_name": "BigDecimal(java.lang.String)", "type": "constructor", "idx": 23224, "Desc": "translates the string representation of a bigdecimal into a bigdecimal . the string representation consists of an optional sign , ' + ' ( ' \\u002b ') or ' - ' ( ' \\u002d ') , followed by a sequence of zero or more decimal digits ( \" the integer \") , optionally followed by a fraction , optionally followed by an exponent . the fraction consists of a decimal point followed by zero or more decimal digits . the string must contain at least one digit in either the integer or the fraction . the number formed by the sign , the integer and the fraction is referred to as the significand . the exponent consists of the character ' e ' ( ' \\u0065 ') or ' e ' ( ' \\u0045 ') followed by one or more decimal digits . the value of the exponent must lie between - integer.max_value ( integer.min_value +1 ) and integer.max_value , inclusive . more formally , the strings <init>(java.lang.String) accepts are described by the following grammar : bigdecimalstring : signopt significand exponentopt sign : + - significand : integerpart . fractionpartopt . fractionpart integerpart integerpart : digits fractionpart : digits exponent : exponentindicator signedinteger exponentindicator : e e signedinteger : signopt digits digits : digit digits digit digit : any character for which character.isdigit ( char ) returns true , including 0 , 1 , 2 ... the scale of the returned bigdecimal will be the number of digits in the fraction , or zero if the string contains no decimal point , subject to adjustment for any exponent ; if the string contains an exponent , the exponent is subtracted from the scale . the value of the resulting scale must lie between integer.min_value and integer.max_value , inclusive . the character-to-digit mapping is provided by character.digit ( char , int ) set to convert to radix 10 . the string may not contain any extraneous characters ( whitespace , for example ) . examples : the value of the returned bigdecimal is equal to significand \u00d7 10 exponent . for each string on the left , the resulting representation [ biginteger , scale ] is shown on the right . \" 0 \" [ 0 , 0 ] \" 0.00 \" [ 0 , 2 ] \" 123 \" [ 123 , 0 ] \" -123 \" [ -123 , 0 ] \" 1.23e3 \" [ 123 , -1 ] \" 1.23e +3 \" [ 123 , -1 ] \" 12.3e +7 \" [ 123 , -6 ] \" 12.0 \" [ 120 , 1 ] \" 12.3 \" [ 123 , 1 ] \" 0.00123 \" [ 123 , 5 ] \" - 1.23e-12 \" [ -123 , 14 ] \" 1234.5e-4 \" [ 12345 , 5 ] \" 0e+7 \" [ 0 , -7 ] \" -0 \" [ 0 , 0 ]"}{"node_name": "BigDecimal(java.lang.String,java.math.MathContext)", "type": "constructor", "idx": 23225, "Desc": "translates the string representation of a bigdecimal into a bigdecimal , accepting the same strings as the bigdecimal ( string ) constructor , with rounding according to the context settings ."}{"node_name": "BigDecimal(double)", "type": "constructor", "idx": 23228, "Desc": "translates a double into a bigdecimal which is the exact decimal representation of the double's binary floating-point value . the scale of the returned bigdecimal is the smallest value such that ( 10scale \u00d7 val ) is an integer . notes : the results of <init>(double) can be somewhat unpredictable . one might assume that writing new bigdecimal ( 0.1 ) in java creates a bigdecimal which is exactly equal to 0.1 ( an unscaled value of 1 , with a scale of 1 ) , but it is actually equal to 0.1000000000000000055511151231257827021181583404541015625 . this is because 0.1 cannot be represented exactly as a double ( or , for that matter , as a binary fraction of any finite length ) . thus , the value that is being passed in to <init>(double) is not exactly equal to 0.1 , appearances notwithstanding . the string constructor , on the other hand , is perfectly predictable : writing new bigdecimal ( \" 0.1 \") creates a bigdecimal which is exactly equal to 0.1 , as one would expect . therefore , it is generally recommended that the string constructor be used in preference to this one . when a double must be used as a source for a bigdecimal , note that <init>(double) provides an exact conversion ; it does not give the same result as converting the double to a string using the double.tostring ( double ) method and then using the bigdecimal ( string ) constructor . to get that result , use the static valueof ( double ) method ."}{"node_name": "BigDecimal(double,java.math.MathContext)", "type": "constructor", "idx": 23230, "Desc": "translates a double into a bigdecimal , with rounding according to the context settings . the scale of the bigdecimal is the smallest value such that ( 10scale \u00d7 val ) is an integer . the results of <init>(double,java.math.MathContext) can be somewhat unpredictable and its use is generally not recommended ; see the notes under the bigdecimal ( double ) constructor ."}{"node_name": "BigDecimal(java.math.BigInteger)", "type": "constructor", "idx": 23233, "Desc": "translates a biginteger into a bigdecimal . the scale of the bigdecimal is zero ."}{"node_name": "BigDecimal(java.math.BigInteger,java.math.MathContext)", "type": "constructor", "idx": 23235, "Desc": "translates a biginteger into a bigdecimal rounding according to the context settings . the scale of the bigdecimal is zero ."}{"node_name": "BigDecimal(java.math.BigInteger,int)", "type": "constructor", "idx": 23238, "Desc": "translates a biginteger unscaled value and an int scale into a bigdecimal . the value of the bigdecimal is ( unscaledval \u00d7 10-scale ) ."}{"node_name": "BigDecimal(java.math.BigInteger,int,java.math.MathContext)", "type": "constructor", "idx": 23241, "Desc": "translates a biginteger unscaled value and an int scale into a bigdecimal , with rounding according to the context settings . the value of the bigdecimal is ( unscaledval \u00d7 10-scale ) , rounded according to the precision and rounding mode settings ."}{"node_name": "BigDecimal(int)", "type": "constructor", "idx": 23245, "Desc": "translates an int into a bigdecimal . the scale of the bigdecimal is zero ."}{"node_name": "BigDecimal(int,java.math.MathContext)", "type": "constructor", "idx": 23247, "Desc": "translates an int into a bigdecimal , with rounding according to the context settings . the scale of the bigdecimal , before any rounding , is zero ."}{"node_name": "BigDecimal(long)", "type": "constructor", "idx": 23250, "Desc": "translates a long into a bigdecimal . the scale of the bigdecimal is zero ."}{"node_name": "BigDecimal(long,java.math.MathContext)", "type": "constructor", "idx": 23252, "Desc": "translates a long into a bigdecimal , with rounding according to the context settings . the scale of the bigdecimal , before any rounding , is zero ."}{"node_name": "BigInteger(byte[],int,int)", "type": "constructor", "idx": 23366, "Desc": "translates a byte sub-array containing the two's -complement binary representation of a biginteger into a biginteger . the sub-array is specified via an offset into the array and a length . the sub-array is assumed to be in big-endian byte-order : the most significant byte is the element at index off . the val array is assumed to be unchanged for the duration of <init>(byte[],int,int) call . an indexoutofboundsexception is thrown if the length of the array val is non-zero and either off is negative , len is negative , or off+len is greater than the length of val ."}{"node_name": "BigInteger(byte[])", "type": "constructor", "idx": 23370, "Desc": "translates a byte array containing the two's -complement binary representation of a biginteger into a biginteger . the input array is assumed to be in big-endian byte-order : the most significant byte is in the zeroth element . the val array is assumed to be unchanged for the duration of <init>(byte[]) call ."}{"node_name": "BigInteger(int,byte[],int,int)", "type": "constructor", "idx": 23372, "Desc": "translates the sign-magnitude representation of a biginteger into a biginteger . the sign is represented as an integer signum value : -1 for negative , 0 for zero , or 1 for positive . the magnitude is a sub-array of a byte array in big-endian byte-order : the most significant byte is the element at index off . a zero value of the length len is permissible , and will result in a biginteger value of 0 , whether signum is -1 , 0 or 1 . the magnitude array is assumed to be unchanged for the duration of <init>(int,byte[],int,int) call . an indexoutofboundsexception is thrown if the length of the array magnitude is non-zero and either off is negative , len is negative , or off+len is greater than the length of magnitude ."}{"node_name": "BigInteger(int,byte[])", "type": "constructor", "idx": 23377, "Desc": "translates the sign-magnitude representation of a biginteger into a biginteger . the sign is represented as an integer signum value : -1 for negative , 0 for zero , or 1 for positive . the magnitude is a byte array in big-endian byte-order : the most significant byte is the zeroth element . a zero-length magnitude array is permissible , and will result in a biginteger value of 0 , whether signum is -1 , 0 or 1 . the magnitude array is assumed to be unchanged for the duration of <init>(int,byte[]) call ."}{"node_name": "BigInteger(java.lang.String,int)", "type": "constructor", "idx": 23380, "Desc": "translates the string representation of a biginteger in the specified radix into a biginteger . the string representation consists of an optional minus or plus sign followed by a sequence of one or more digits in the specified radix . the character-to-digit mapping is provided by character.digit . the string may not contain any extraneous characters ( whitespace , for example ) ."}{"node_name": "BigInteger(java.lang.String)", "type": "constructor", "idx": 23383, "Desc": "translates the decimal string representation of a biginteger into a biginteger . the string representation consists of an optional minus sign followed by a sequence of one or more decimal digits . the character-to-digit mapping is provided by character.digit . the string may not contain any extraneous characters ( whitespace , for example ) ."}{"node_name": "BigInteger(int,java.util.Random)", "type": "constructor", "idx": 23385, "Desc": "constructs a randomly generated biginteger , uniformly distributed over the range 0 to ( 2numbits - 1 ) , inclusive . the uniformity of the distribution assumes that a fair source of random bits is provided in rnd . note that <init>(int,java.util.Random) always constructs a non-negative biginteger ."}{"node_name": "BigInteger(int,int,java.util.Random)", "type": "constructor", "idx": 23388, "Desc": "constructs a randomly generated positive biginteger that is probably prime , with the specified bitlength ."}{"node_name": "MathContext(int)", "type": "constructor", "idx": 23478, "Desc": "constructs a new mathcontext with the specified precision and the half_up rounding mode ."}{"node_name": "MathContext(int,java.math.RoundingMode)", "type": "constructor", "idx": 23480, "Desc": "constructs a new mathcontext with a specified precision and rounding mode ."}{"node_name": "MathContext(java.lang.String)", "type": "constructor", "idx": 23483, "Desc": "constructs a new mathcontext from a string . the string must be in the same format as that produced by the tostring() method . an illegalargumentexception is thrown if the precision section of the string is out of range ( < 0 ) or the string is not in the format created by the tostring() method ."}{"node_name": "Authenticator()", "type": "constructor", "idx": 23498, "Desc": ""}{"node_name": "BindException(java.lang.String)", "type": "constructor", "idx": 23557, "Desc": "constructs a new bindexception with the specified detail message as to why the bind error occurred . a detail message is a string that gives a specific description of this error ."}{"node_name": "BindException()", "type": "constructor", "idx": 23559, "Desc": "construct a new bindexception with no detailed message ."}{"node_name": "CacheRequest()", "type": "constructor", "idx": 23561, "Desc": ""}{"node_name": "CacheResponse()", "type": "constructor", "idx": 23565, "Desc": ""}{"node_name": "ConnectException(java.lang.String)", "type": "constructor", "idx": 23569, "Desc": "constructs a new connectexception with the specified detail message as to why the connect error occurred . a detail message is a string that gives a specific description of this error ."}{"node_name": "ConnectException()", "type": "constructor", "idx": 23571, "Desc": "construct a new connectexception with no detailed message ."}{"node_name": "ContentHandler()", "type": "constructor", "idx": 23573, "Desc": ""}{"node_name": "CookieHandler()", "type": "constructor", "idx": 23583, "Desc": ""}{"node_name": "CookieManager()", "type": "constructor", "idx": 23594, "Desc": "create a new cookie manager . <init>() will create new cookie manager with default cookie store and accept policy . the effect is same as cookiemanager ( null , null ) ."}{"node_name": "CookieManager(java.net.CookieStore,java.net.CookiePolicy)", "type": "constructor", "idx": 23595, "Desc": "create a new cookie manager with specified cookie store and cookie policy ."}{"node_name": "DatagramPacket(byte[],int,int)", "type": "constructor", "idx": 23621, "Desc": "constructs a datagrampacket for receiving packets of length length , specifying an offset into the buffer . the length argument must be less than or equal to buf.length ."}{"node_name": "DatagramPacket(byte[],int)", "type": "constructor", "idx": 23625, "Desc": "constructs a datagrampacket for receiving packets of length length . the length argument must be less than or equal to buf.length ."}{"node_name": "DatagramPacket(byte[],int,int,java.net.InetAddress,int)", "type": "constructor", "idx": 23628, "Desc": "constructs a datagram packet for sending packets of length length with offset offset to the specified port number on the specified host . the length argument must be less than or equal to buf.length ."}{"node_name": "DatagramPacket(byte[],int,int,java.net.SocketAddress)", "type": "constructor", "idx": 23634, "Desc": "constructs a datagram packet for sending packets of length length with offset offset to the specified port number on the specified host . the length argument must be less than or equal to buf.length ."}{"node_name": "DatagramPacket(byte[],int,java.net.InetAddress,int)", "type": "constructor", "idx": 23639, "Desc": "constructs a datagram packet for sending packets of length length to the specified port number on the specified host . the length argument must be less than or equal to buf.length ."}{"node_name": "DatagramPacket(byte[],int,java.net.SocketAddress)", "type": "constructor", "idx": 23644, "Desc": "constructs a datagram packet for sending packets of length length to the specified port number on the specified host . the length argument must be less than or equal to buf.length ."}{"node_name": "DatagramSocket()", "type": "constructor", "idx": 23669, "Desc": "constructs a datagram socket and binds it to any available port on the local host machine . the socket will be bound to the wildcard address , an ip address chosen by the kernel . if there is a security manager , its checklisten method is first called with 0 as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "DatagramSocket(java.net.DatagramSocketImpl)", "type": "constructor", "idx": 23670, "Desc": "creates an unbound datagram socket with the specified datagramsocketimpl ."}{"node_name": "DatagramSocket(java.net.SocketAddress)", "type": "constructor", "idx": 23672, "Desc": "creates a datagram socket , bound to the specified local socket address . if , if the address is null , creates an unbound socket . if there is a security manager , its checklisten method is first called with the port from the socket address as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "DatagramSocket(int)", "type": "constructor", "idx": 23674, "Desc": "constructs a datagram socket and binds it to the specified port on the local host machine . the socket will be bound to the wildcard address , an ip address chosen by the kernel . if there is a security manager , its checklisten method is first called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "DatagramSocket(int,java.net.InetAddress)", "type": "constructor", "idx": 23676, "Desc": "creates a datagram socket , bound to the specified local address . the local port must be between 0 and 65535 inclusive . if the ip address is 0.0.0.0 , the socket will be bound to the wildcard address , an ip address chosen by the kernel . if there is a security manager , its checklisten method is first called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "DatagramSocketImpl()", "type": "constructor", "idx": 23731, "Desc": ""}{"node_name": "HttpClient()", "type": "constructor", "idx": 23799, "Desc": "creates an httpclient ."}{"node_name": "HttpConnectTimeoutException(java.lang.String)", "type": "constructor", "idx": 23831, "Desc": "constructs an httpconnecttimeoutexception with the given detail message ."}{"node_name": "HttpRequest()", "type": "constructor", "idx": 23903, "Desc": "creates an httprequest ."}{"node_name": "HttpTimeoutException(java.lang.String)", "type": "constructor", "idx": 24015, "Desc": "constructs an httptimeoutexception with the given detail message ."}{"node_name": "WebSocketHandshakeException(java.net.http.HttpResponse)", "type": "constructor", "idx": 24075, "Desc": "constructs a websockethandshakeexception with the given httpresponse ."}{"node_name": "HttpCookie(java.lang.String,java.lang.String)", "type": "constructor", "idx": 24081, "Desc": "constructs a cookie with a specified name and value . the name must conform to rfc 2965 . that means it can contain only ascii alphanumeric characters and cannot contain commas , semicolons , or white space or begin with a $ character . the cookie's name cannot be changed after creation . the value can be anything the server chooses to send . its value is probably of interest only to the server . the cookie's value can be changed after creation with the setvalue method . by default , cookies are created according to the rfc 2965 cookie specification . the version can be changed with the setversion method ."}{"node_name": "HttpRetryException(java.lang.String,int)", "type": "constructor", "idx": 24130, "Desc": "constructs a new httpretryexception from the specified response code and exception detail message"}{"node_name": "HttpRetryException(java.lang.String,int,java.lang.String)", "type": "constructor", "idx": 24133, "Desc": "constructs a new httpretryexception with detail message responsecode and the contents of the location response header field ."}{"node_name": "HttpURLConnection(java.net.URL)", "type": "constructor", "idx": 24183, "Desc": "constructor for the httpurlconnection ."}{"node_name": "InetSocketAddress(int)", "type": "constructor", "idx": 24305, "Desc": "creates a socket address where the ip address is the wildcard address and the port number a specified value . a valid port value is between 0 and 65535 . a port number of zero will let the system pick up an ephemeral port in a bind operation ."}{"node_name": "InetSocketAddress(java.net.InetAddress,int)", "type": "constructor", "idx": 24307, "Desc": "creates a socket address from an ip address and a port number . a valid port value is between 0 and 65535 . a port number of zero will let the system pick up an ephemeral port in a bind operation . a null address will assign the wildcard address ."}{"node_name": "InetSocketAddress(java.lang.String,int)", "type": "constructor", "idx": 24310, "Desc": "creates a socket address from a hostname and a port number . an attempt will be made to resolve the hostname into an inetaddress . if that attempt fails , the address will be flagged as unresolved . if there is a security manager , its checkconnect method is called with the host name as its argument to check the permission to resolve it . this could result in a securityexception . a valid port value is between 0 and 65535 . a port number of zero will let the system pick up an ephemeral port in a bind operation ."}{"node_name": "JarURLConnection(java.net.URL)", "type": "constructor", "idx": 24335, "Desc": "creates the new jarurlconnection to the specified url ."}{"node_name": "MalformedURLException()", "type": "constructor", "idx": 24346, "Desc": "constructs a malformedurlexception with no detail message ."}{"node_name": "MalformedURLException(java.lang.String)", "type": "constructor", "idx": 24347, "Desc": "constructs a malformedurlexception with the specified detail message ."}{"node_name": "MulticastSocket()", "type": "constructor", "idx": 24350, "Desc": "create a multicast socket . if there is a security manager , its checklisten method is first called with 0 as its argument to ensure the operation is allowed . this could result in a securityexception . when the socket is created the datagramsocket.setreuseaddress ( boolean ) method is called to enable the so_reuseaddr socket option ."}{"node_name": "MulticastSocket(int)", "type": "constructor", "idx": 24351, "Desc": "create a multicast socket and bind it to a specific port . if there is a security manager , its checklisten method is first called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception . when the socket is created the datagramsocket.setreuseaddress ( boolean ) method is called to enable the so_reuseaddr socket option ."}{"node_name": "MulticastSocket(java.net.SocketAddress)", "type": "constructor", "idx": 24353, "Desc": "create a multicastsocket bound to the specified socket address . or , if the address is null , create an unbound socket . if there is a security manager , its checklisten method is first called with the socketaddress port as its argument to ensure the operation is allowed . this could result in a securityexception . when the socket is created the datagramsocket.setreuseaddress ( boolean ) method is called to enable the so_reuseaddr socket option ."}{"node_name": "NetPermission(java.lang.String)", "type": "constructor", "idx": 24378, "Desc": "creates a new netpermission with the specified name . the name is the symbolic name of the netpermission , such as \" setdefaultauthenticator \" , etc . an asterisk may appear at the end of the name , following a \" . \" , or by itself , to signify a wildcard match ."}{"node_name": "NetPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 24380, "Desc": "creates a new netpermission object with the specified name . the name is the symbolic name of the netpermission , and the actions string is currently unused and should be null ."}{"node_name": "NoRouteToHostException(java.lang.String)", "type": "constructor", "idx": 24411, "Desc": "constructs a new noroutetohostexception with the specified detail message as to why the remote host cannot be reached . a detail message is a string that gives a specific description of this error ."}{"node_name": "NoRouteToHostException()", "type": "constructor", "idx": 24413, "Desc": "construct a new noroutetohostexception with no detailed message ."}{"node_name": "PasswordAuthentication(java.lang.String,char[])", "type": "constructor", "idx": 24415, "Desc": "creates a new passwordauthentication object from the given user name and password . note that the given user password is cloned before it is stored in the new passwordauthentication object ."}{"node_name": "PortUnreachableException(java.lang.String)", "type": "constructor", "idx": 24421, "Desc": "constructs a new portunreachableexception with a detail message ."}{"node_name": "PortUnreachableException()", "type": "constructor", "idx": 24423, "Desc": "construct a new portunreachableexception with no detailed message ."}{"node_name": "ProtocolException(java.lang.String)", "type": "constructor", "idx": 24425, "Desc": "constructs a new protocolexception with the specified detail message ."}{"node_name": "ProtocolException()", "type": "constructor", "idx": 24427, "Desc": "constructs a new protocolexception with no detail message ."}{"node_name": "Proxy(java.net.Proxy.Type,java.net.SocketAddress)", "type": "constructor", "idx": 24432, "Desc": "creates an entry representing a proxy connection . certain combinations are illegal . for instance , for types http , and socks , a socketaddress must be provided . use the proxy.no_proxy constant for representing a direct connection ."}{"node_name": "ProxySelector()", "type": "constructor", "idx": 24446, "Desc": ""}{"node_name": "ResponseCache()", "type": "constructor", "idx": 24459, "Desc": ""}{"node_name": "SecureCacheResponse()", "type": "constructor", "idx": 24471, "Desc": ""}{"node_name": "ServerSocket(java.net.SocketImpl)", "type": "constructor", "idx": 24479, "Desc": "creates a server socket with a user-specified socketimpl ."}{"node_name": "ServerSocket()", "type": "constructor", "idx": 24481, "Desc": "creates an unbound server socket ."}{"node_name": "ServerSocket(int)", "type": "constructor", "idx": 24482, "Desc": "creates a server socket , bound to the specified port . a port number of 0 means that the port number is automatically allocated , typically from an ephemeral port range . this port number can then be retrieved by calling getlocalport . the maximum queue length for incoming connection indications ( a request to connect ) is set to 50 . if a connection indication arrives when the queue is full , the connection is refused . if the application has specified a server socket implementation factory , that factory's createsocketimpl method is called to create the actual socket implementation . otherwise a system-default socket implementation is created . if there is a security manager , its checklisten method is called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "ServerSocket(int,int)", "type": "constructor", "idx": 24484, "Desc": "creates a server socket and binds it to the specified local port number , with the specified backlog . a port number of 0 means that the port number is automatically allocated , typically from an ephemeral port range . this port number can then be retrieved by calling getlocalport . the maximum queue length for incoming connection indications ( a request to connect ) is set to the backlog parameter . if a connection indication arrives when the queue is full , the connection is refused . if the application has specified a server socket implementation factory , that factory's createsocketimpl method is called to create the actual socket implementation . otherwise a system-default socket implementation is created . if there is a security manager , its checklisten method is called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception . the backlog argument is the requested maximum number of pending connections on the socket . its exact semantics are implementation specific . in particular , an implementation may impose a maximum length or may choose to ignore the parameter altogether . the value provided should be greater than 0 . if it is less than or equal to 0 , then an implementation specific default will be used ."}{"node_name": "ServerSocket(int,int,java.net.InetAddress)", "type": "constructor", "idx": 24487, "Desc": "create a server with the specified port , listen backlog , and local ip address to bind to . the bindaddr argument can be used on a multi-homed host for a serversocket that will only accept connect requests to one of its addresses . if bindaddr is null , it will default accepting connections on any / all local addresses . the port must be between 0 and 65535 , inclusive . a port number of 0 means that the port number is automatically allocated , typically from an ephemeral port range . this port number can then be retrieved by calling getlocalport . if there is a security manager , this method calls its checklisten method with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception . the backlog argument is the requested maximum number of pending connections on the socket . its exact semantics are implementation specific . in particular , an implementation may impose a maximum length or may choose to ignore the parameter altogether . the value provided should be greater than 0 . if it is less than or equal to 0 , then an implementation specific default will be used ."}{"node_name": "Socket()", "type": "constructor", "idx": 24529, "Desc": "creates an unconnected socket . if the application has specified a client socket implementation factory , that factory's createsocketimpl method is called to create the actual socket implementation . otherwise a system-default socket implementation is created ."}{"node_name": "Socket(java.net.Proxy)", "type": "constructor", "idx": 24530, "Desc": "creates an unconnected socket , specifying the type of proxy , if any , that should be used regardless of any other settings . if there is a security manager , its checkconnect method is called with the proxy host address and port number as its arguments . this could result in a securityexception . examples : socket s = new socket ( proxy.no_proxy ); will create a plain socket ignoring any other proxy configuration . socket s = new socket ( new proxy ( proxy.type.socks , new inetsocketaddress ( \" socks.mydom.com \" , 1080 ))); will create a socket connecting through the specified socks proxy server ."}{"node_name": "Socket(java.net.SocketImpl)", "type": "constructor", "idx": 24532, "Desc": "creates an unconnected socket with a user-specified socketimpl ."}{"node_name": "Socket(java.lang.String,int)", "type": "constructor", "idx": 24534, "Desc": "creates a stream socket and connects it to the specified port number on the named host . if the specified host is null it is the equivalent of specifying the address as inetaddress.getbyname ( null ) . in other words , it is equivalent to specifying an address of the loopback interface . if the application has specified a client socket implementation factory , that factory's createsocketimpl method is called to create the actual socket implementation . otherwise a system-default socket implementation is created . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "Socket(java.net.InetAddress,int)", "type": "constructor", "idx": 24537, "Desc": "creates a stream socket and connects it to the specified port number at the specified ip address . if the application has specified a client socket implementation factory , that factory's createsocketimpl method is called to create the actual socket implementation . otherwise a system-default socket implementation is created . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "Socket(java.lang.String,int,java.net.InetAddress,int)", "type": "constructor", "idx": 24540, "Desc": "creates a socket and connects it to the specified remote host on the specified remote port . the socket will also bind() to the local address and port supplied . if the specified host is null it is the equivalent of specifying the address as inetaddress.getbyname ( null ) . in other words , it is equivalent to specifying an address of the loopback interface . a local port number of zero will let the system pick up a free port in the bind operation . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "Socket(java.net.InetAddress,int,java.net.InetAddress,int)", "type": "constructor", "idx": 24545, "Desc": "creates a socket and connects it to the specified remote address on the specified remote port . the socket will also bind() to the local address and port supplied . if the specified local address is null it is the equivalent of specifying the address as the anylocal address ( see inetaddress.isanylocaladdress() ) . a local port number of zero will let the system pick up a free port in the bind operation . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "SocketAddress()", "type": "constructor", "idx": 24618, "Desc": ""}{"node_name": "SocketException(java.lang.String)", "type": "constructor", "idx": 24620, "Desc": "constructs a new socketexception with the specified detail message ."}{"node_name": "SocketException()", "type": "constructor", "idx": 24622, "Desc": "constructs a new socketexception with no detail message ."}{"node_name": "SocketImpl()", "type": "constructor", "idx": 24628, "Desc": "initialize a new instance of this class"}{"node_name": "SocketPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 24698, "Desc": "creates a new socketpermission object with the specified actions . the host is expressed as a dns name , or as a numerical ip address . optionally , a port or a portrange may be supplied ( separated from the dns name or ip address by a colon ) . to specify the local machine , use \" localhost \" as the host . also note : an empty host string ( \"\") is equivalent to \" localhost \" . the actions parameter contains a comma-separated list of the actions granted for the specified host ( and port ( s )) . possible actions are \" connect \" , \" listen \" , \" accept \" , \" resolve \" , or any combination of those . \" resolve \" is automatically added when any of the other three are specified . examples of socketpermission instantiation are the following : nr = new socketpermission ( \" www.example.com \" , \" connect \") ; nr = new socketpermission ( \" www.example.com:80 \" , \" connect \") ; nr = new socketpermission ( \" * .example .com \" , \" connect \") ; nr = new socketpermission ( \" * .edu \" , \" resolve \") ; nr = new socketpermission ( \" 204.160.241.0 \" , \" connect \") ; nr = new socketpermission ( \" localhost : 1024-65535 \" , \" listen \") ; nr = new socketpermission ( \" 204.160.241.0 : 1024-65535 \" , \" connect \") ;"}{"node_name": "SocketTimeoutException(java.lang.String)", "type": "constructor", "idx": 24709, "Desc": "constructs a new sockettimeoutexception with a detail message ."}{"node_name": "SocketTimeoutException()", "type": "constructor", "idx": 24711, "Desc": "construct a new sockettimeoutexception with no detailed message ."}{"node_name": "URLStreamHandlerProvider()", "type": "constructor", "idx": 24713, "Desc": "initializes a new url stream handler provider ."}{"node_name": "UnknownHostException(java.lang.String)", "type": "constructor", "idx": 24732, "Desc": "constructs a new unknownhostexception with the specified detail message ."}{"node_name": "UnknownHostException()", "type": "constructor", "idx": 24734, "Desc": "constructs a new unknownhostexception with no detail message ."}{"node_name": "UnknownServiceException()", "type": "constructor", "idx": 24736, "Desc": "constructs a new unknownserviceexception with no detail message ."}{"node_name": "UnknownServiceException(java.lang.String)", "type": "constructor", "idx": 24737, "Desc": "constructs a new unknownserviceexception with the specified detail message ."}{"node_name": "URI(java.lang.String)", "type": "constructor", "idx": 24740, "Desc": "constructs a uri by parsing the given string . <init>(java.lang.String) parses the given string exactly as specified by the grammar in rfc 2396 , appendix a , except for the following deviations : an empty authority component is permitted as long as it is followed by a non-empty path , a query component , or a fragment component . this allows the parsing of uris such as \" file :/ // foo / bar \" , which seems to be the intent of rfc 2396 although the grammar does not permit it . if the authority component is empty then the user-information , host , and port components are undefined . empty relative paths are permitted ; this seems to be the intent of rfc 2396 although the grammar does not permit it . the primary consequence of this deviation is that a standalone fragment such as \" #foo \" parses as a relative uri with an empty path and the given fragment , and can be usefully resolved against a base uri . ipv4 addresses in host components are parsed rigorously , as specified by rfc 2732 : each element of a dotted-quad address must contain no more than three decimal digits . each element is further constrained to have a value no greater than 255 . hostnames in host components that comprise only a single domain label are permitted to start with an alphanum character . this seems to be the intent of rfc 2396 section 3.2.2 although the grammar does not permit it . the consequence of this deviation is that the authority component of a hierarchical uri such as s :/ / 123 , will parse as a server-based authority . ipv6 addresses are permitted for the host component . an ipv6 address must be enclosed in square brackets ( ' [ ' and ']') as specified by rfc 2732 . the ipv6 address itself must parse according to rfc 2373 . ipv6 addresses are further constrained to describe no more than sixteen bytes of address information , a constraint implicit in rfc 2373 but not expressible in the grammar . characters in the other category are permitted wherever rfc 2396 permits escaped octets , that is , in the user-information , path , query , and fragment components , as well as in the authority component if the authority is registry-based . this allows uris to contain unicode characters beyond those in the us-ascii character set ."}{"node_name": "URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 24742, "Desc": "constructs a hierarchical uri from the given components . if a scheme is given then the path , if also given , must either be empty or begin with a slash character ( ' / ') . otherwise a component of the new uri may be left undefined by passing null for the corresponding parameter or , in the case of the port parameter , by passing -1 . <init>(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String) first builds a uri string from the given components according to the rules specified in rfc 2396 , section 5.2 , step 7 : initially , the result string is empty . if a scheme is given then it is appended to the result , followed by a colon character ( ' : ') . if user information , a host , or a port are given then the string \" // \" is appended . if user information is given then it is appended , followed by a commercial-at character ( ' @ ') . any character not in the unreserved , punct , escaped , or other categories is quoted . if a host is given then it is appended . if the host is a literal ipv6 address but is not enclosed in square brackets ( ' [ ' and ']') then the square brackets are added . if a port number is given then a colon character ( ' : ') is appended , followed by the port number in decimal . if a path is given then it is appended . any character not in the unreserved , punct , escaped , or other categories , and not equal to the slash character ( ' / ') or the commercial-at character ( ' @ ') , is quoted . if a query is given then a question-mark character ( ' ? ') is appended , followed by the query . any character that is not a legal uri character is quoted . finally , if a fragment is given then a hash character ( ' # ') is appended , followed by the fragment . any character that is not a legal uri character is quoted . the resulting uri string is then parsed as if by invoking the uri ( string ) constructor and then invoking the parseserverauthority() method upon the result ; this may cause a urisyntaxexception to be thrown ."}{"node_name": "URI(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 24750, "Desc": "constructs a hierarchical uri from the given components . if a scheme is given then the path , if also given , must either be empty or begin with a slash character ( ' / ') . otherwise a component of the new uri may be left undefined by passing null for the corresponding parameter . <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String) first builds a uri string from the given components according to the rules specified in rfc 2396 , section 5.2 , step 7 : initially , the result string is empty . if a scheme is given then it is appended to the result , followed by a colon character ( ' : ') . if an authority is given then the string \" // \" is appended , followed by the authority . if the authority contains a literal ipv6 address then the address must be enclosed in square brackets ( ' [ ' and ']') . any character not in the unreserved , punct , escaped , or other categories , and not equal to the commercial-at character ( ' @ ') , is quoted . if a path is given then it is appended . any character not in the unreserved , punct , escaped , or other categories , and not equal to the slash character ( ' / ') or the commercial-at character ( ' @ ') , is quoted . if a query is given then a question-mark character ( ' ? ') is appended , followed by the query . any character that is not a legal uri character is quoted . finally , if a fragment is given then a hash character ( ' # ') is appended , followed by the fragment . any character that is not a legal uri character is quoted . the resulting uri string is then parsed as if by invoking the uri ( string ) constructor and then invoking the parseserverauthority() method upon the result ; this may cause a urisyntaxexception to be thrown ."}{"node_name": "URI(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 24756, "Desc": "constructs a hierarchical uri from the given components . a component may be left undefined by passing null . this convenience constructor works as if by invoking the seven-argument constructor as follows : new uri ( scheme , null , host , -1 , path , null , fragment );"}{"node_name": "URI(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 24761, "Desc": "constructs a uri from the given components . a component may be left undefined by passing null . <init>(java.lang.String,java.lang.String,java.lang.String) first builds a uri in string form using the given components as follows : initially , the result string is empty . if a scheme is given then it is appended to the result , followed by a colon character ( ' : ') . if a scheme-specific part is given then it is appended . any character that is not a legal uri character is quoted . finally , if a fragment is given then a hash character ( ' # ') is appended to the string , followed by the fragment . any character that is not a legal uri character is quoted . the resulting uri string is then parsed in order to create the new uri instance as if by invoking the uri ( string ) constructor ; this may cause a urisyntaxexception to be thrown ."}{"node_name": "URISyntaxException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 24801, "Desc": "constructs an instance from the given input string , reason , and error index ."}{"node_name": "URISyntaxException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 24805, "Desc": "constructs an instance from the given input string and reason . the resulting object will have an error index of -1 ."}{"node_name": "URL(java.lang.String,java.lang.String,int,java.lang.String)", "type": "constructor", "idx": 24813, "Desc": "creates a url object from the specified protocol , host , port number , and file . host can be expressed as a host name or a literal ip address . if ipv6 literal address is used , it should be enclosed in square brackets ( ' [ ' and ']') , as specified by rfc 2732 ; however , the literal ipv6 address format defined in rfc 2373 : ip version 6 addressing architecture is also accepted . specifying a port number of -1 indicates that the url should use the default port for the protocol . if this is the first url object being created with the specified protocol , a stream protocol handler object , an instance of class urlstreamhandler , is created for that protocol : if the application has previously set up an instance of urlstreamhandlerfactory as the stream handler factory , then the createurlstreamhandler method of that instance is called with the protocol string as an argument to create the stream protocol handler . if no urlstreamhandlerfactory has yet been set up , or if the factory's createurlstreamhandler method returns null , then the serviceloader mechanism is used to locate urlstreamhandlerprovider implementations using the system class loader . the order that providers are located is implementation specific , and an implementation is free to cache the located providers . a serviceconfigurationerror , error or runtimeexception thrown from the createurlstreamhandler , if encountered , will be propagated to the calling thread . the createurlstreamhandler method of each provider , if instantiated , is invoked , with the protocol string , until a provider returns non-null , or all providers have been exhausted . if the previous step fails to find a protocol handler , <init>(java.lang.String,java.lang.String,int,java.lang.String) reads the value of the system property : java.protocol.handler.pkgs if the value of that system property is not null , it is interpreted as a list of packages separated by a vertical slash character ' | ' . <init>(java.lang.String,java.lang.String,int,java.lang.String) tries to load the class named : < package > . < protocol > .handler where < package > is replaced by the name of the package and < protocol > is replaced by the name of the protocol . if this class does not exist , or if the class exists but it is not a subclass of urlstreamhandler , then the next package in the list is tried . if the previous step fails to find a protocol handler , then <init>(java.lang.String,java.lang.String,int,java.lang.String) tries to load a built-in protocol handler . if this class does not exist , or if the class exists but it is not a subclass of urlstreamhandler , then a malformedurlexception is thrown . protocol handlers for the following protocols are guaranteed to exist on the search path : - http , https , file , and jar protocol handlers for additional protocols may also be available . some protocol handlers , for example those used for loading platform classes or classes on the class path , may not be overridden . the details of such restrictions , and when those restrictions apply ( during initialization of the runtime for example ) , are implementation specific and therefore not specified no validation of the inputs is performed by <init>(java.lang.String,java.lang.String,int,java.lang.String) ."}{"node_name": "URL(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 24818, "Desc": "creates a url from the specified protocol name , host name , and file name . the default port for the specified protocol is used . <init>(java.lang.String,java.lang.String,java.lang.String) is equivalent to the four-argument constructor with the only difference of using the default port for the specified protocol . no validation of the inputs is performed by <init>(java.lang.String,java.lang.String,java.lang.String) ."}{"node_name": "URL(java.lang.String,java.lang.String,int,java.lang.String,java.net.URLStreamHandler)", "type": "constructor", "idx": 24822, "Desc": "creates a url object from the specified protocol , host , port number , file , and handler . specifying a port number of -1 indicates that the url should use the default port for the protocol . specifying a handler of null indicates that the url should use a default stream handler for the protocol , as outlined for : java.net.url#url(java.lang.string , java.lang.string , int , java.lang.string ) if the handler is not null and there is a security manager , the security manager's checkpermission method is called with a netpermission ( \" specifystreamhandler \") permission . this may result in a securityexception . no validation of the inputs is performed by <init>(java.lang.String,java.lang.String,int,java.lang.String,java.net.URLStreamHandler) ."}{"node_name": "URL(java.lang.String)", "type": "constructor", "idx": 24828, "Desc": "creates a url object from the string representation . <init>(java.lang.String) is equivalent to a call to the two-argument constructor with a null first argument ."}{"node_name": "URL(java.net.URL,java.lang.String)", "type": "constructor", "idx": 24830, "Desc": "creates a url by parsing the given spec within a specified context . the new url is created from the given context url and the spec argument as described in rfc2396 \" uniform resource identifiers : generic * syntax \" : < scheme > :/ / < authority > < path > ? < query > # < fragment > the reference is parsed into the scheme , authority , path , query and fragment parts . if the path component is empty and the scheme , authority , and query components are undefined , then the new url is a reference to the current document . otherwise , the fragment and query parts present in the spec are used in the new url . if the scheme component is defined in the given spec and does not match the scheme of the context , then the new url is created as an absolute url based on the spec alone . otherwise the scheme component is inherited from the context url . if the authority component is present in the spec then the spec is treated as absolute and the spec authority and path will replace the context authority and path . if the authority component is absent in the spec then the authority of the new url will be inherited from the context . if the spec's path component begins with a slash character \" / \" then the path is treated as absolute and the spec path replaces the context path . otherwise , the path is treated as a relative path and is appended to the context path , as described in rfc2396 . also , in this case , the path is canonicalized through the removal of directory changes made by occurrences of \" .. \" and \" . \" . for a more detailed description of url parsing , refer to rfc2396 ."}{"node_name": "URL(java.net.URL,java.lang.String,java.net.URLStreamHandler)", "type": "constructor", "idx": 24833, "Desc": "creates a url by parsing the given spec with the specified handler within a specified context . if the handler is null , the parsing occurs as with the two argument constructor ."}{"node_name": "URLClassLoader(java.net.URL[],java.lang.ClassLoader)", "type": "constructor", "idx": 24865, "Desc": "constructs a new urlclassloader for the given urls . the urls will be searched in the order specified for classes and resources after first searching in the specified parent class loader . any jar : scheme url is assumed to refer to a jar file . any file : scheme url that ends with a ' / ' is assumed to refer to a directory . otherwise , the url is assumed to refer to a jar file which will be downloaded and opened as needed . if there is a security manager , this method first calls the security manager's checkcreateclassloader method to ensure creation of a class loader is allowed ."}{"node_name": "URLClassLoader(java.net.URL[])", "type": "constructor", "idx": 24868, "Desc": "constructs a new urlclassloader for the specified urls using the default delegation parent classloader . the urls will be searched in the order specified for classes and resources after first searching in the parent class loader . any url that ends with a ' / ' is assumed to refer to a directory . otherwise , the url is assumed to refer to a jar file which will be downloaded and opened as needed . if there is a security manager , this method first calls the security manager's checkcreateclassloader method to ensure creation of a class loader is allowed ."}{"node_name": "URLClassLoader(java.net.URL[],java.lang.ClassLoader,java.net.URLStreamHandlerFactory)", "type": "constructor", "idx": 24870, "Desc": "constructs a new urlclassloader for the specified urls , parent class loader , and urlstreamhandlerfactory . the parent argument will be used as the parent class loader for delegation . the factory argument will be used as the stream handler factory to obtain protocol handlers when creating new jar urls . if there is a security manager , this method first calls the security manager's checkcreateclassloader method to ensure creation of a class loader is allowed ."}{"node_name": "URLClassLoader(java.lang.String,java.net.URL[],java.lang.ClassLoader)", "type": "constructor", "idx": 24874, "Desc": "constructs a new named urlclassloader for the specified urls . the urls will be searched in the order specified for classes and resources after first searching in the specified parent class loader . any url that ends with a ' / ' is assumed to refer to a directory . otherwise , the url is assumed to refer to a jar file which will be downloaded and opened as needed ."}{"node_name": "URLClassLoader(java.lang.String,java.net.URL[],java.lang.ClassLoader,java.net.URLStreamHandlerFactory)", "type": "constructor", "idx": 24878, "Desc": "constructs a new named urlclassloader for the specified urls , parent class loader , and urlstreamhandlerfactory . the parent argument will be used as the parent class loader for delegation . the factory argument will be used as the stream handler factory to obtain protocol handlers when creating new jar urls ."}{"node_name": "URLConnection(java.net.URL)", "type": "constructor", "idx": 24914, "Desc": "constructs a url connection to the specified url . a connection to the object referenced by the url is not created ."}{"node_name": "URLDecoder()", "type": "constructor", "idx": 24999, "Desc": ""}{"node_name": "URLPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 25014, "Desc": "creates a new urlpermission from a url string and which permits the given request methods and user-settable request headers . the name of the permission is the url string it was created with . only the scheme , authority and path components of the url are used internally . any fragment or query components are ignored . the permissions action string is as specified above ."}{"node_name": "URLPermission(java.lang.String)", "type": "constructor", "idx": 25017, "Desc": "creates a urlpermission with the given url string and unrestricted methods and request headers by invoking the two argument constructor as follows : urlpermission ( url , \" * : * \")"}{"node_name": "URLStreamHandler()", "type": "constructor", "idx": 25026, "Desc": ""}{"node_name": "BufferOverflowException()", "type": "constructor", "idx": 25092, "Desc": "constructs an instance of this class ."}{"node_name": "BufferUnderflowException()", "type": "constructor", "idx": 25094, "Desc": "constructs an instance of this class ."}{"node_name": "AcceptPendingException()", "type": "constructor", "idx": 25240, "Desc": "constructs an instance of this class ."}{"node_name": "AlreadyBoundException()", "type": "constructor", "idx": 25242, "Desc": "constructs an instance of this class ."}{"node_name": "AlreadyConnectedException()", "type": "constructor", "idx": 25244, "Desc": "constructs an instance of this class ."}{"node_name": "AsynchronousChannelGroup(java.nio.channels.spi.AsynchronousChannelProvider)", "type": "constructor", "idx": 25261, "Desc": "initialize a new instance of this class ."}{"node_name": "AsynchronousCloseException()", "type": "constructor", "idx": 25280, "Desc": "constructs an instance of this class ."}{"node_name": "AsynchronousFileChannel()", "type": "constructor", "idx": 25282, "Desc": "initializes a new instance of this class ."}{"node_name": "AsynchronousServerSocketChannel(java.nio.channels.spi.AsynchronousChannelProvider)", "type": "constructor", "idx": 25332, "Desc": "initializes a new instance of this class ."}{"node_name": "AsynchronousSocketChannel(java.nio.channels.spi.AsynchronousChannelProvider)", "type": "constructor", "idx": 25352, "Desc": "initializes a new instance of this class ."}{"node_name": "CancelledKeyException()", "type": "constructor", "idx": 25415, "Desc": "constructs an instance of this class ."}{"node_name": "ClosedByInterruptException()", "type": "constructor", "idx": 25453, "Desc": "constructs an instance of this class ."}{"node_name": "ClosedChannelException()", "type": "constructor", "idx": 25455, "Desc": "constructs an instance of this class ."}{"node_name": "ClosedSelectorException()", "type": "constructor", "idx": 25457, "Desc": "constructs an instance of this class ."}{"node_name": "ConnectionPendingException()", "type": "constructor", "idx": 25466, "Desc": "constructs an instance of this class ."}{"node_name": "DatagramChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25468, "Desc": "initializes a new instance of this class ."}{"node_name": "FileChannel()", "type": "constructor", "idx": 25508, "Desc": "initializes a new instance of this class ."}{"node_name": "FileLock(java.nio.channels.FileChannel,long,long,boolean)", "type": "constructor", "idx": 25574, "Desc": "initializes a new instance of this class ."}{"node_name": "FileLock(java.nio.channels.AsynchronousFileChannel,long,long,boolean)", "type": "constructor", "idx": 25579, "Desc": "initializes a new instance of this class ."}{"node_name": "FileLockInterruptionException()", "type": "constructor", "idx": 25597, "Desc": "constructs an instance of this class ."}{"node_name": "IllegalBlockingModeException()", "type": "constructor", "idx": 25606, "Desc": "constructs an instance of this class ."}{"node_name": "IllegalChannelGroupException()", "type": "constructor", "idx": 25608, "Desc": "constructs an instance of this class ."}{"node_name": "IllegalSelectorException()", "type": "constructor", "idx": 25610, "Desc": "constructs an instance of this class ."}{"node_name": "InterruptedByTimeoutException()", "type": "constructor", "idx": 25612, "Desc": "constructs an instance of this class ."}{"node_name": "MembershipKey()", "type": "constructor", "idx": 25616, "Desc": "initializes a new instance of this class ."}{"node_name": "NoConnectionPendingException()", "type": "constructor", "idx": 25647, "Desc": "constructs an instance of this class ."}{"node_name": "NonReadableChannelException()", "type": "constructor", "idx": 25649, "Desc": "constructs an instance of this class ."}{"node_name": "NonWritableChannelException()", "type": "constructor", "idx": 25651, "Desc": "constructs an instance of this class ."}{"node_name": "NotYetBoundException()", "type": "constructor", "idx": 25653, "Desc": "constructs an instance of this class ."}{"node_name": "NotYetConnectedException()", "type": "constructor", "idx": 25655, "Desc": "constructs an instance of this class ."}{"node_name": "OverlappingFileLockException()", "type": "constructor", "idx": 25657, "Desc": "constructs an instance of this class ."}{"node_name": "Pipe()", "type": "constructor", "idx": 25659, "Desc": "initializes a new instance of this class ."}{"node_name": "SinkChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25664, "Desc": "initializes a new instance of this class ."}{"node_name": "SourceChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25668, "Desc": "constructs a new instance of this class ."}{"node_name": "ReadPendingException()", "type": "constructor", "idx": 25675, "Desc": "constructs an instance of this class ."}{"node_name": "SelectableChannel()", "type": "constructor", "idx": 25695, "Desc": "initializes a new instance of this class ."}{"node_name": "SelectionKey()", "type": "constructor", "idx": 25717, "Desc": "constructs an instance of this class ."}{"node_name": "Selector()", "type": "constructor", "idx": 25738, "Desc": "initializes a new instance of this class ."}{"node_name": "ServerSocketChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25758, "Desc": "initializes a new instance of this class ."}{"node_name": "ShutdownChannelGroupException()", "type": "constructor", "idx": 25774, "Desc": "constructs an instance of this class ."}{"node_name": "SocketChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25776, "Desc": "initializes a new instance of this class ."}{"node_name": "AbstractInterruptibleChannel()", "type": "constructor", "idx": 25814, "Desc": "initializes a new instance of this class ."}{"node_name": "AbstractSelectableChannel(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25821, "Desc": "initializes a new instance of this class ."}{"node_name": "AbstractSelectionKey()", "type": "constructor", "idx": 25835, "Desc": "initializes a new instance of this class ."}{"node_name": "AbstractSelector(java.nio.channels.spi.SelectorProvider)", "type": "constructor", "idx": 25838, "Desc": "initializes a new instance of this class ."}{"node_name": "AsynchronousChannelProvider()", "type": "constructor", "idx": 25853, "Desc": "initializes a new instance of this class ."}{"node_name": "SelectorProvider()", "type": "constructor", "idx": 25866, "Desc": "initializes a new instance of this class ."}{"node_name": "UnresolvedAddressException()", "type": "constructor", "idx": 25877, "Desc": "constructs an instance of this class ."}{"node_name": "UnsupportedAddressTypeException()", "type": "constructor", "idx": 25879, "Desc": "constructs an instance of this class ."}{"node_name": "WritePendingException()", "type": "constructor", "idx": 25884, "Desc": "constructs an instance of this class ."}{"node_name": "CharacterCodingException()", "type": "constructor", "idx": 25990, "Desc": "constructs an instance of this class ."}{"node_name": "Charset(java.lang.String,java.lang.String[])", "type": "constructor", "idx": 25992, "Desc": "initializes a new charset with the given canonical name and alias set ."}{"node_name": "CharsetDecoder(java.nio.charset.Charset,float,float)", "type": "constructor", "idx": 26025, "Desc": "initializes a new decoder . the new decoder will have the given chars-per-byte values and its replacement will be the string \" \\ufffd \" ."}{"node_name": "CharsetEncoder(java.nio.charset.Charset,float,float,byte[])", "type": "constructor", "idx": 26066, "Desc": "initializes a new encoder . the new encoder will have the given bytes-per-char and replacement values ."}{"node_name": "CharsetEncoder(java.nio.charset.Charset,float,float)", "type": "constructor", "idx": 26071, "Desc": "initializes a new encoder . the new encoder will have the given bytes-per-char values and its replacement will be the byte array { ( byte )' ? ' } ."}{"node_name": "CoderMalfunctionError(java.lang.Exception)", "type": "constructor", "idx": 26115, "Desc": "initializes an instance of this class ."}{"node_name": "IllegalCharsetNameException(java.lang.String)", "type": "constructor", "idx": 26138, "Desc": "constructs an instance of this class ."}{"node_name": "MalformedInputException(int)", "type": "constructor", "idx": 26142, "Desc": "constructs an malformedinputexception with the given length ."}{"node_name": "CharsetProvider()", "type": "constructor", "idx": 26147, "Desc": "initializes a new charset provider ."}{"node_name": "UnmappableCharacterException(int)", "type": "constructor", "idx": 26159, "Desc": "constructs an unmappablecharacterexception with the given length ."}{"node_name": "UnsupportedCharsetException(java.lang.String)", "type": "constructor", "idx": 26164, "Desc": "constructs an instance of this class ."}{"node_name": "AccessDeniedException(java.lang.String)", "type": "constructor", "idx": 26244, "Desc": "constructs an instance of this class ."}{"node_name": "AccessDeniedException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 26246, "Desc": "constructs an instance of this class ."}{"node_name": "AtomicMoveNotSupportedException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 26255, "Desc": "constructs an instance of this class ."}{"node_name": "UserPrincipalLookupService()", "type": "constructor", "idx": 26406, "Desc": "initializes a new instance of this class ."}{"node_name": "UserPrincipalNotFoundException(java.lang.String)", "type": "constructor", "idx": 26412, "Desc": "constructs an instance of this class ."}{"node_name": "ClosedDirectoryStreamException()", "type": "constructor", "idx": 26416, "Desc": "constructs an instance of this class ."}{"node_name": "ClosedFileSystemException()", "type": "constructor", "idx": 26418, "Desc": "constructs an instance of this class ."}{"node_name": "ClosedWatchServiceException()", "type": "constructor", "idx": 26420, "Desc": "constructs an instance of this class ."}{"node_name": "DirectoryIteratorException(java.io.IOException)", "type": "constructor", "idx": 26423, "Desc": "constructs an instance of this class ."}{"node_name": "DirectoryNotEmptyException(java.lang.String)", "type": "constructor", "idx": 26427, "Desc": "constructs an instance of this class ."}{"node_name": "FileAlreadyExistsException(java.lang.String)", "type": "constructor", "idx": 26435, "Desc": "constructs an instance of this class ."}{"node_name": "FileAlreadyExistsException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 26437, "Desc": "constructs an instance of this class ."}{"node_name": "FileStore()", "type": "constructor", "idx": 26663, "Desc": "initializes a new instance of this class ."}{"node_name": "FileSystem()", "type": "constructor", "idx": 26680, "Desc": "initializes a new instance of this class ."}{"node_name": "FileSystemAlreadyExistsException()", "type": "constructor", "idx": 26697, "Desc": "constructs an instance of this class ."}{"node_name": "FileSystemAlreadyExistsException(java.lang.String)", "type": "constructor", "idx": 26698, "Desc": "constructs an instance of this class ."}{"node_name": "FileSystemException(java.lang.String)", "type": "constructor", "idx": 26701, "Desc": "constructs an instance of this class . <init>(java.lang.String) should be used when an operation involving one file fails and there isn't any additional information to explain the reason ."}{"node_name": "FileSystemException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 26703, "Desc": "constructs an instance of this class . <init>(java.lang.String,java.lang.String,java.lang.String) should be used when an operation involving two files fails , or there is additional information to explain the reason ."}{"node_name": "FileSystemLoopException(java.lang.String)", "type": "constructor", "idx": 26712, "Desc": "constructs an instance of this class ."}{"node_name": "FileSystemNotFoundException()", "type": "constructor", "idx": 26715, "Desc": "constructs an instance of this class ."}{"node_name": "FileSystemNotFoundException(java.lang.String)", "type": "constructor", "idx": 26716, "Desc": "constructs an instance of this class ."}{"node_name": "InvalidPathException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 26763, "Desc": "constructs an instance from the given input string , reason , and error index ."}{"node_name": "InvalidPathException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 26767, "Desc": "constructs an instance from the given input string and reason . the resulting object will have an error index of -1 ."}{"node_name": "LinkPermission(java.lang.String)", "type": "constructor", "idx": 26779, "Desc": "constructs a linkpermission with the specified name ."}{"node_name": "LinkPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 26781, "Desc": "constructs a linkpermission with the specified name ."}{"node_name": "NoSuchFileException(java.lang.String)", "type": "constructor", "idx": 26785, "Desc": "constructs an instance of this class ."}{"node_name": "NoSuchFileException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 26787, "Desc": "constructs an instance of this class ."}{"node_name": "NotDirectoryException(java.lang.String)", "type": "constructor", "idx": 26792, "Desc": "constructs an instance of this class ."}{"node_name": "NotLinkException(java.lang.String)", "type": "constructor", "idx": 26795, "Desc": "constructs an instance of this class ."}{"node_name": "NotLinkException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 26797, "Desc": "constructs an instance of this class ."}{"node_name": "ProviderMismatchException()", "type": "constructor", "idx": 26867, "Desc": "constructs an instance of this class ."}{"node_name": "ProviderMismatchException(java.lang.String)", "type": "constructor", "idx": 26868, "Desc": "constructs an instance of this class ."}{"node_name": "ProviderNotFoundException()", "type": "constructor", "idx": 26871, "Desc": "constructs an instance of this class ."}{"node_name": "ProviderNotFoundException(java.lang.String)", "type": "constructor", "idx": 26872, "Desc": "constructs an instance of this class ."}{"node_name": "ReadOnlyFileSystemException()", "type": "constructor", "idx": 26875, "Desc": "constructs an instance of this class ."}{"node_name": "SimpleFileVisitor()", "type": "constructor", "idx": 26899, "Desc": "initializes a new instance of this class ."}{"node_name": "FileSystemProvider()", "type": "constructor", "idx": 26913, "Desc": "initializes a new instance of this class . during construction a provider may safely access files associated with the default provider but care needs to be taken to avoid circular loading of other installed providers . if circular loading of installed providers is detected then an unspecified error is thrown ."}{"node_name": "FileTypeDetector()", "type": "constructor", "idx": 27000, "Desc": "initializes a new instance of this class ."}{"node_name": "InvalidMarkException()", "type": "constructor", "idx": 27199, "Desc": "constructs an instance of this class ."}{"node_name": "ReadOnlyBufferException()", "type": "constructor", "idx": 27293, "Desc": "constructs an instance of this class ."}{"node_name": "AccessException(java.lang.String)", "type": "constructor", "idx": 27371, "Desc": "constructs an accessexception with the specified detail message ."}{"node_name": "AccessException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27373, "Desc": "constructs an accessexception with the specified detail message and nested exception ."}{"node_name": "Activatable(java.lang.String,java.rmi.MarshalledObject,boolean,int)", "type": "constructor", "idx": 27377, "Desc": "constructs an activatable remote object by registering an activation descriptor ( with the specified location , data , and restart mode ) for this object , and exporting the object with the specified port . note : using the activatable constructors that both register and export an activatable remote object is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic . instead , an application should register an activation descriptor and export a remote object separately , so that exceptions can be handled properly . this method invokes the exportobject method with this object , and the specified location , data , restart mode , and port . subsequent calls to getid() will return the activation identifier returned from the call to exportobject ."}{"node_name": "Activatable(java.lang.String,java.rmi.MarshalledObject,boolean,int,java.rmi.server.RMIClientSocketFactory,java.rmi.server.RMIServerSocketFactory)", "type": "constructor", "idx": 27382, "Desc": "constructs an activatable remote object by registering an activation descriptor ( with the specified location , data , and restart mode ) for this object , and exporting the object with the specified port , and specified client and server socket factories . note : using the activatable constructors that both register and export an activatable remote object is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic . instead , an application should register an activation descriptor and export a remote object separately , so that exceptions can be handled properly . this method invokes the exportobject method with this object , and the specified location , data , restart mode , port , and client and server socket factories . subsequent calls to getid() will return the activation identifier returned from the call to exportobject ."}{"node_name": "Activatable(java.rmi.activation.ActivationID,int)", "type": "constructor", "idx": 27389, "Desc": "constructor used to activate / export the object on a specified port . an \" activatable \" remote object must have a constructor that takes two arguments : the object's activation identifier ( activationid ) , and the object's initialization data ( a marshalledobject ) . a concrete subclass of this class must call <init>(java.rmi.activation.ActivationID,int) when it is activated via the two parameter constructor described above . as a side-effect of construction , the remote object is \" exported \" to the rmi runtime ( on the specified port ) and is available to accept incoming calls from clients ."}{"node_name": "Activatable(java.rmi.activation.ActivationID,int,java.rmi.server.RMIClientSocketFactory,java.rmi.server.RMIServerSocketFactory)", "type": "constructor", "idx": 27392, "Desc": "constructor used to activate / export the object on a specified port . an \" activatable \" remote object must have a constructor that takes two arguments : the object's activation identifier ( activationid ) , and the object's initialization data ( a marshalledobject ) . a concrete subclass of this class must call <init>(java.rmi.activation.ActivationID,int,java.rmi.server.RMIClientSocketFactory,java.rmi.server.RMIServerSocketFactory) when it is activated via the two parameter constructor described above . as a side-effect of construction , the remote object is \" exported \" to the rmi runtime ( on the specified port ) and is available to accept incoming calls from clients ."}{"node_name": "ActivateFailedException(java.lang.String)", "type": "constructor", "idx": 27432, "Desc": "constructs an activatefailedexception with the specified detail message ."}{"node_name": "ActivateFailedException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27434, "Desc": "constructs an activatefailedexception with the specified detail message and nested exception ."}{"node_name": "ActivationDesc(java.lang.String,java.lang.String,java.rmi.MarshalledObject)", "type": "constructor", "idx": 27438, "Desc": "constructs an object descriptor for an object whose class name is classname , that can be loaded from the code location and whose initialization information is data . if this form of <init>(java.lang.String,java.lang.String,java.rmi.MarshalledObject) is used , the groupid defaults to the current id for activationgroup for this vm . all objects with the same activationgroupid are activated in the same vm . note that objects specified by a descriptor created with <init>(java.lang.String,java.lang.String,java.rmi.MarshalledObject) will only be activated on demand ( by default , the restart mode is false ) . if an activatable object requires restart services , use one of the activationdesc constructors that takes a boolean parameter , restart . <init>(java.lang.String,java.lang.String,java.rmi.MarshalledObject) will throw activationexception if there is no current activation group for this vm . to create an activationgroup use the activationgroup.creategroup method ."}{"node_name": "ActivationDesc(java.lang.String,java.lang.String,java.rmi.MarshalledObject,boolean)", "type": "constructor", "idx": 27442, "Desc": "constructs an object descriptor for an object whose class name is classname , that can be loaded from the code location and whose initialization information is data . if this form of <init>(java.lang.String,java.lang.String,java.rmi.MarshalledObject,boolean) is used , the groupid defaults to the current id for activationgroup for this vm . all objects with the same activationgroupid are activated in the same vm . <init>(java.lang.String,java.lang.String,java.rmi.MarshalledObject,boolean) will throw activationexception if there is no current activation group for this vm . to create an activationgroup use the activationgroup.creategroup method ."}{"node_name": "ActivationDesc(java.rmi.activation.ActivationGroupID,java.lang.String,java.lang.String,java.rmi.MarshalledObject)", "type": "constructor", "idx": 27447, "Desc": "constructs an object descriptor for an object whose class name is classname that can be loaded from the code location and whose initialization information is data . all objects with the same groupid are activated in the same java vm . note that objects specified by a descriptor created with <init>(java.rmi.activation.ActivationGroupID,java.lang.String,java.lang.String,java.rmi.MarshalledObject) will only be activated on demand ( by default , the restart mode is false ) . if an activatable object requires restart services , use one of the activationdesc constructors that takes a boolean parameter , restart ."}{"node_name": "ActivationDesc(java.rmi.activation.ActivationGroupID,java.lang.String,java.lang.String,java.rmi.MarshalledObject,boolean)", "type": "constructor", "idx": 27452, "Desc": "constructs an object descriptor for an object whose class name is classname that can be loaded from the code location and whose initialization information is data . all objects with the same groupid are activated in the same java vm ."}{"node_name": "ActivationException()", "type": "constructor", "idx": 27468, "Desc": "constructs an activationexception ."}{"node_name": "ActivationException(java.lang.String)", "type": "constructor", "idx": 27469, "Desc": "constructs an activationexception with the specified detail message ."}{"node_name": "ActivationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 27471, "Desc": "constructs an activationexception with the specified detail message and cause . <init>(java.lang.String,java.lang.Throwable) sets the detail field to the specified throwable ."}{"node_name": "ActivationGroup(java.rmi.activation.ActivationGroupID)", "type": "constructor", "idx": 27477, "Desc": "constructs an activation group with the given activation group identifier . the group is exported as a java.rmi.server.unicastremoteobject ."}{"node_name": "CommandEnvironment(java.lang.String,java.lang.String[])", "type": "constructor", "idx": 27497, "Desc": "create a commandenvironment with all the necessary information ."}{"node_name": "ActivationGroupDesc(java.util.Properties,java.rmi.activation.ActivationGroupDesc.CommandEnvironment)", "type": "constructor", "idx": 27506, "Desc": "constructs a group descriptor that uses the system defaults for group implementation and code location . properties specify java environment overrides ( which will override system properties in the group implementation's vm ) . the command environment can control the exact command / options used in starting the child vm , or can be null to accept rmid's default . <init>(java.util.Properties,java.rmi.activation.ActivationGroupDesc.CommandEnvironment) will create an activationgroupdesc with a null group class name , which indicates the system's default activationgroup implementation ."}{"node_name": "ActivationGroupDesc(java.lang.String,java.lang.String,java.rmi.MarshalledObject,java.util.Properties,java.rmi.activation.ActivationGroupDesc.CommandEnvironment)", "type": "constructor", "idx": 27509, "Desc": "specifies an alternate group implementation and execution environment to be used for the group ."}{"node_name": "ActivationGroupID(java.rmi.activation.ActivationSystem)", "type": "constructor", "idx": 27524, "Desc": "constructs a unique group id ."}{"node_name": "ActivationGroup_Stub(java.rmi.server.RemoteRef)", "type": "constructor", "idx": 27531, "Desc": "constructs a stub for the activationgroup class . it invokes the superclass remotestub ( remoteref ) constructor with its argument , ref ."}{"node_name": "ActivationID(java.rmi.activation.Activator)", "type": "constructor", "idx": 27537, "Desc": "<init>(java.rmi.activation.Activator) for activationid takes a single argument , activator , that specifies a remote reference to the activator responsible for activating the object associated with this identifier . an instance of activationid is globally unique ."}{"node_name": "UnknownGroupException(java.lang.String)", "type": "constructor", "idx": 27587, "Desc": "constructs an unknowngroupexception with the specified detail message ."}{"node_name": "UnknownObjectException(java.lang.String)", "type": "constructor", "idx": 27590, "Desc": "constructs an unknownobjectexception with the specified detail message ."}{"node_name": "AlreadyBoundException()", "type": "constructor", "idx": 27593, "Desc": "constructs an alreadyboundexception with no specified detail message ."}{"node_name": "AlreadyBoundException(java.lang.String)", "type": "constructor", "idx": 27594, "Desc": "constructs an alreadyboundexception with the specified detail message ."}{"node_name": "ConnectException(java.lang.String)", "type": "constructor", "idx": 27597, "Desc": "constructs a connectexception with the specified detail message ."}{"node_name": "ConnectException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27599, "Desc": "constructs a connectexception with the specified detail message and nested exception ."}{"node_name": "ConnectIOException(java.lang.String)", "type": "constructor", "idx": 27603, "Desc": "constructs a connectioexception with the specified detail message ."}{"node_name": "ConnectIOException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27605, "Desc": "constructs a connectioexception with the specified detail message and nested exception ."}{"node_name": "Lease(java.rmi.dgc.VMID,long)", "type": "constructor", "idx": 27619, "Desc": "constructs a lease with a specific vmid and lease duration . the vmid may be null ."}{"node_name": "VMID()", "type": "constructor", "idx": 27625, "Desc": "create a new vmid . each new vmid returned from <init>() is unique for all java virtual machines under the following conditions : a ) the conditions for uniqueness for objects of the class java.rmi.server.uid are satisfied , and b ) an address can be obtained for this host that is unique and constant for the lifetime of this object ."}{"node_name": "MarshalException(java.lang.String)", "type": "constructor", "idx": 27631, "Desc": "constructs a marshalexception with the specified detail message ."}{"node_name": "MarshalException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27633, "Desc": "constructs a marshalexception with the specified detail message and nested exception ."}{"node_name": "MarshalledObject(java.lang.Object)", "type": "constructor", "idx": 27637, "Desc": "creates a new marshalledobject that contains the serialized representation of the current state of the supplied object . the object is serialized with the semantics used for marshaling parameters for rmi calls ."}{"node_name": "NoSuchObjectException(java.lang.String)", "type": "constructor", "idx": 27657, "Desc": "constructs a nosuchobjectexception with the specified detail message ."}{"node_name": "NotBoundException()", "type": "constructor", "idx": 27660, "Desc": "constructs a notboundexception with no specified detail message ."}{"node_name": "NotBoundException(java.lang.String)", "type": "constructor", "idx": 27661, "Desc": "constructs a notboundexception with the specified detail message ."}{"node_name": "RemoteException()", "type": "constructor", "idx": 27699, "Desc": "constructs a remoteexception ."}{"node_name": "RemoteException(java.lang.String)", "type": "constructor", "idx": 27700, "Desc": "constructs a remoteexception with the specified detail message ."}{"node_name": "RemoteException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 27702, "Desc": "constructs a remoteexception with the specified detail message and cause . <init>(java.lang.String,java.lang.Throwable) sets the detail field to the specified throwable ."}{"node_name": "ExportException(java.lang.String)", "type": "constructor", "idx": 27710, "Desc": "constructs an exportexception with the specified detail message ."}{"node_name": "ExportException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27712, "Desc": "constructs an exportexception with the specified detail message and nested exception ."}{"node_name": "ObjID()", "type": "constructor", "idx": 27721, "Desc": "generates a unique object identifier . if the system property java.rmi.server.randomids is defined to equal the string \" true \" ( case insensitive ) , then <init>() will use a cryptographically strong random number generator to choose the object number of the returned objid ."}{"node_name": "ObjID(int)", "type": "constructor", "idx": 27722, "Desc": "creates a \" well-known \" object identifier . an objid created via <init>(int) will not clash with any objids generated via the no-arg constructor ."}{"node_name": "RemoteObject()", "type": "constructor", "idx": 27736, "Desc": "creates a remote object ."}{"node_name": "RemoteObject(java.rmi.server.RemoteRef)", "type": "constructor", "idx": 27737, "Desc": "creates a remote object , initialized with the specified remote reference ."}{"node_name": "RemoteObjectInvocationHandler(java.rmi.server.RemoteRef)", "type": "constructor", "idx": 27747, "Desc": "creates a new remoteobjectinvocationhandler constructed with the specified remoteref ."}{"node_name": "RemoteServer()", "type": "constructor", "idx": 27767, "Desc": "constructs a remoteserver ."}{"node_name": "RemoteServer(java.rmi.server.RemoteRef)", "type": "constructor", "idx": 27768, "Desc": "constructs a remoteserver with the given reference type ."}{"node_name": "RMIClassLoaderSpi()", "type": "constructor", "idx": 27796, "Desc": ""}{"node_name": "RMISocketFactory()", "type": "constructor", "idx": 27820, "Desc": "constructs an rmisocketfactory ."}{"node_name": "ServerCloneException(java.lang.String)", "type": "constructor", "idx": 27835, "Desc": "constructs a servercloneexception with the specified detail message ."}{"node_name": "ServerCloneException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27837, "Desc": "constructs a servercloneexception with the specified detail message and cause ."}{"node_name": "ServerNotActiveException()", "type": "constructor", "idx": 27843, "Desc": "constructs an servernotactiveexception with no specified detail message ."}{"node_name": "ServerNotActiveException(java.lang.String)", "type": "constructor", "idx": 27844, "Desc": "constructs an servernotactiveexception with the specified detail message ."}{"node_name": "UID()", "type": "constructor", "idx": 27852, "Desc": "generates a uid that is unique over time with respect to the host that it was generated on ."}{"node_name": "UID(short)", "type": "constructor", "idx": 27853, "Desc": "creates a \" well-known \" uid . there are 216 possible such well-known ids . a uid created via <init>(short) will not clash with any uids generated via the no-arg constructor ."}{"node_name": "UnicastRemoteObject()", "type": "constructor", "idx": 27864, "Desc": "creates and exports a new unicastremoteobject object using an anonymous port . the object is exported with a server socket created using the rmisocketfactory class ."}{"node_name": "UnicastRemoteObject(int)", "type": "constructor", "idx": 27865, "Desc": "creates and exports a new unicastremoteobject object using the particular supplied port . the object is exported with a server socket created using the rmisocketfactory class ."}{"node_name": "UnicastRemoteObject(int,java.rmi.server.RMIClientSocketFactory,java.rmi.server.RMIServerSocketFactory)", "type": "constructor", "idx": 27867, "Desc": "creates and exports a new unicastremoteobject object using the particular supplied port and socket factories . either socket factory may be null , in which case the corresponding client or server socket creation method of rmisocketfactory is used instead ."}{"node_name": "ServerError(java.lang.String,java.lang.Error)", "type": "constructor", "idx": 27896, "Desc": "constructs a servererror with the specified detail message and nested error ."}{"node_name": "ServerException(java.lang.String)", "type": "constructor", "idx": 27900, "Desc": "constructs a serverexception with the specified detail message ."}{"node_name": "ServerException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27902, "Desc": "constructs a serverexception with the specified detail message and nested exception ."}{"node_name": "StubNotFoundException(java.lang.String)", "type": "constructor", "idx": 27907, "Desc": "constructs a stubnotfoundexception with the specified detail message ."}{"node_name": "StubNotFoundException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27909, "Desc": "constructs a stubnotfoundexception with the specified detail message and nested exception ."}{"node_name": "UnexpectedException(java.lang.String)", "type": "constructor", "idx": 27913, "Desc": "constructs an unexpectedexception with the specified detail message ."}{"node_name": "UnexpectedException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27915, "Desc": "constructs a unexpectedexception with the specified detail message and nested exception ."}{"node_name": "UnknownHostException(java.lang.String)", "type": "constructor", "idx": 27919, "Desc": "constructs an unknownhostexception with the specified detail message ."}{"node_name": "UnknownHostException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27921, "Desc": "constructs an unknownhostexception with the specified detail message and nested exception ."}{"node_name": "UnmarshalException(java.lang.String)", "type": "constructor", "idx": 27925, "Desc": "constructs an unmarshalexception with the specified detail message ."}{"node_name": "UnmarshalException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 27927, "Desc": "constructs an unmarshalexception with the specified detail message and nested exception ."}{"node_name": "AccessControlContext(java.security.ProtectionDomain[])", "type": "constructor", "idx": 27931, "Desc": "create an accesscontrolcontext with the given array of protectiondomains . context must not be null . duplicate domains will be removed from the context ."}{"node_name": "AccessControlContext(java.security.AccessControlContext,java.security.DomainCombiner)", "type": "constructor", "idx": 27933, "Desc": "create a new accesscontrolcontext with the given accesscontrolcontext and domaincombiner . <init>(java.security.AccessControlContext,java.security.DomainCombiner) associates the provided domaincombiner with the provided accesscontrolcontext ."}{"node_name": "AccessControlException(java.lang.String)", "type": "constructor", "idx": 27943, "Desc": "constructs an accesscontrolexception with the specified , detailed message ."}{"node_name": "AccessControlException(java.lang.String,java.security.Permission)", "type": "constructor", "idx": 27945, "Desc": "constructs an accesscontrolexception with the specified , detailed message , and the requested permission that caused the exception ."}{"node_name": "AlgorithmParameterGenerator(java.security.AlgorithmParameterGeneratorSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 28005, "Desc": "creates an algorithmparametergenerator object ."}{"node_name": "AlgorithmParameterGeneratorSpi()", "type": "constructor", "idx": 28031, "Desc": ""}{"node_name": "AlgorithmParameters(java.security.AlgorithmParametersSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 28040, "Desc": "creates an algorithmparameters object ."}{"node_name": "AlgorithmParametersSpi()", "type": "constructor", "idx": 28068, "Desc": ""}{"node_name": "AllPermission()", "type": "constructor", "idx": 28083, "Desc": "creates a new allpermission object ."}{"node_name": "AllPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 28084, "Desc": "creates a new allpermission object . <init>(java.lang.String,java.lang.String) exists for use by the policy object to instantiate new permission objects ."}{"node_name": "AuthProvider(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 28095, "Desc": "constructs a provider with the specified name , version string , and information ."}{"node_name": "BasicPermission(java.lang.String)", "type": "constructor", "idx": 28106, "Desc": "creates a new basicpermission with the specified name . name is the symbolic name of the permission , such as \" setfactory \" , \" print.queuejob \" , or \" toplevelwindow \" , etc ."}{"node_name": "BasicPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 28108, "Desc": "creates a new basicpermission object with the specified name . the name is the symbolic name of the basicpermission , and the actions string is currently unused ."}{"node_name": "CertificateRep(java.lang.String,byte[])", "type": "constructor", "idx": 28119, "Desc": "construct the alternate certificate class with the certificate type and certificate encoding bytes ."}{"node_name": "Certificate(java.lang.String)", "type": "constructor", "idx": 28124, "Desc": "creates a certificate of the specified type ."}{"node_name": "CertificateEncodingException()", "type": "constructor", "idx": 28143, "Desc": "constructs a certificateencodingexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateEncodingException(java.lang.String)", "type": "constructor", "idx": 28144, "Desc": "constructs a certificateencodingexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateEncodingException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28146, "Desc": "creates a certificateencodingexception with the specified detail message and cause ."}{"node_name": "CertificateEncodingException(java.lang.Throwable)", "type": "constructor", "idx": 28149, "Desc": "creates a certificateencodingexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "CertificateException()", "type": "constructor", "idx": 28152, "Desc": "constructs a certificate exception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateException(java.lang.String)", "type": "constructor", "idx": 28153, "Desc": "constructs a certificate exception with the given detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28155, "Desc": "creates a certificateexception with the specified detail message and cause ."}{"node_name": "CertificateException(java.lang.Throwable)", "type": "constructor", "idx": 28158, "Desc": "creates a certificateexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "CertificateExpiredException()", "type": "constructor", "idx": 28161, "Desc": "constructs a certificateexpiredexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateExpiredException(java.lang.String)", "type": "constructor", "idx": 28162, "Desc": "constructs a certificateexpiredexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateFactory(java.security.cert.CertificateFactorySpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 28165, "Desc": "creates a certificatefactory object of the given type , and encapsulates the given provider implementation ( spi object ) in it ."}{"node_name": "CertificateFactorySpi()", "type": "constructor", "idx": 28196, "Desc": ""}{"node_name": "CertificateNotYetValidException()", "type": "constructor", "idx": 28214, "Desc": "constructs a certificatenotyetvalidexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateNotYetValidException(java.lang.String)", "type": "constructor", "idx": 28215, "Desc": "constructs a certificatenotyetvalidexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateParsingException()", "type": "constructor", "idx": 28218, "Desc": "constructs a certificateparsingexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateParsingException(java.lang.String)", "type": "constructor", "idx": 28219, "Desc": "constructs a certificateparsingexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertificateParsingException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28221, "Desc": "creates a certificateparsingexception with the specified detail message and cause ."}{"node_name": "CertificateParsingException(java.lang.Throwable)", "type": "constructor", "idx": 28224, "Desc": "creates a certificateparsingexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "CertificateRevokedException(java.util.Date,java.security.cert.CRLReason,javax.security.auth.x500.X500Principal,java.util.Map)", "type": "constructor", "idx": 28227, "Desc": "constructs a certificaterevokedexception with the specified revocation date , reason code , authority name , and map of extensions ."}{"node_name": "CertPathRep(java.lang.String,byte[])", "type": "constructor", "idx": 28238, "Desc": "creates a certpathrep with the specified type and encoded form of a certification path ."}{"node_name": "CertPath(java.lang.String)", "type": "constructor", "idx": 28243, "Desc": "creates a certpath of the specified type . <init>(java.lang.String) is protected because most users should use a certificatefactory to create certpaths ."}{"node_name": "CertPathBuilder(java.security.cert.CertPathBuilderSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 28257, "Desc": "creates a certpathbuilder object of the given algorithm , and encapsulates the given provider implementation ( spi object ) in it ."}{"node_name": "CertPathBuilderException()", "type": "constructor", "idx": 28276, "Desc": "creates a certpathbuilderexception with null as its detail message ."}{"node_name": "CertPathBuilderException(java.lang.String)", "type": "constructor", "idx": 28277, "Desc": "creates a certpathbuilderexception with the given detail message . the detail message is a string that describes this particular exception in more detail ."}{"node_name": "CertPathBuilderException(java.lang.Throwable)", "type": "constructor", "idx": 28279, "Desc": "creates a certpathbuilderexception that wraps the specified throwable . this allows any exception to be converted into a certpathbuilderexception , while retaining information about the wrapped exception , which may be useful for debugging . the detail message is set to ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "CertPathBuilderException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28281, "Desc": "creates a certpathbuilderexception with the specified detail message and cause ."}{"node_name": "CertPathBuilderSpi()", "type": "constructor", "idx": 28288, "Desc": "the default constructor ."}{"node_name": "CertPathValidator(java.security.cert.CertPathValidatorSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 28301, "Desc": "creates a certpathvalidator object of the given algorithm , and encapsulates the given provider implementation ( spi object ) in it ."}{"node_name": "CertPathValidatorException()", "type": "constructor", "idx": 28325, "Desc": "creates a certpathvalidatorexception with no detail message ."}{"node_name": "CertPathValidatorException(java.lang.String)", "type": "constructor", "idx": 28326, "Desc": "creates a certpathvalidatorexception with the given detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertPathValidatorException(java.lang.Throwable)", "type": "constructor", "idx": 28328, "Desc": "creates a certpathvalidatorexception that wraps the specified throwable . this allows any exception to be converted into a certpathvalidatorexception , while retaining information about the wrapped exception , which may be useful for debugging . the detail message is set to ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "CertPathValidatorException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28330, "Desc": "creates a certpathvalidatorexception with the specified detail message and cause ."}{"node_name": "CertPathValidatorException(java.lang.String,java.lang.Throwable,java.security.cert.CertPath,int)", "type": "constructor", "idx": 28333, "Desc": "creates a certpathvalidatorexception with the specified detail message , cause , certification path , and index ."}{"node_name": "CertPathValidatorException(java.lang.String,java.lang.Throwable,java.security.cert.CertPath,int,java.security.cert.CertPathValidatorException.Reason)", "type": "constructor", "idx": 28338, "Desc": "creates a certpathvalidatorexception with the specified detail message , cause , certification path , index , and reason ."}{"node_name": "CertPathValidatorSpi()", "type": "constructor", "idx": 28351, "Desc": "the default constructor ."}{"node_name": "CertStore(java.security.cert.CertStoreSpi,java.security.Provider,java.lang.String,java.security.cert.CertStoreParameters)", "type": "constructor", "idx": 28361, "Desc": "creates a certstore object of the given type , and encapsulates the given provider implementation ( spi object ) in it ."}{"node_name": "CertStoreException()", "type": "constructor", "idx": 28386, "Desc": "creates a certstoreexception with null as its detail message ."}{"node_name": "CertStoreException(java.lang.String)", "type": "constructor", "idx": 28387, "Desc": "creates a certstoreexception with the given detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CertStoreException(java.lang.Throwable)", "type": "constructor", "idx": 28389, "Desc": "creates a certstoreexception that wraps the specified throwable . this allows any exception to be converted into a certstoreexception , while retaining information about the cause , which may be useful for debugging . the detail message is set to ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "CertStoreException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28391, "Desc": "creates a certstoreexception with the specified detail message and cause ."}{"node_name": "CertStoreSpi(java.security.cert.CertStoreParameters)", "type": "constructor", "idx": 28397, "Desc": "the sole constructor ."}{"node_name": "CollectionCertStoreParameters(java.util.Collection)", "type": "constructor", "idx": 28404, "Desc": "creates an instance of collectioncertstoreparameters which will allow certificates and crls to be retrieved from the specified collection . if the specified collection contains an object that is not a certificate or crl , that object will be ignored by the collection certstore . the collection is not copied . instead , a reference is used . this allows the caller to subsequently add or remove certificates or crls from the collection , thus changing the set of certificates or crls available to the collection certstore . the collection certstore will not modify the contents of the collection . if the collection will be modified by one thread while another thread is calling a method of a collection certstore that has been initialized with this collection , the collection must have fail-fast iterators ."}{"node_name": "CollectionCertStoreParameters()", "type": "constructor", "idx": 28406, "Desc": "creates an instance of collectioncertstoreparameters with the default parameter values ( an empty and immutable collection ) ."}{"node_name": "CRL(java.lang.String)", "type": "constructor", "idx": 28411, "Desc": "creates a crl of the specified type ."}{"node_name": "CRLException()", "type": "constructor", "idx": 28418, "Desc": "constructs a crlexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CRLException(java.lang.String)", "type": "constructor", "idx": 28419, "Desc": "constructs a crlexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CRLException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28421, "Desc": "creates a crlexception with the specified detail message and cause ."}{"node_name": "CRLException(java.lang.Throwable)", "type": "constructor", "idx": 28424, "Desc": "creates a crlexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "LDAPCertStoreParameters(java.lang.String,int)", "type": "constructor", "idx": 28441, "Desc": "creates an instance of ldapcertstoreparameters with the specified parameter values ."}{"node_name": "LDAPCertStoreParameters(java.lang.String)", "type": "constructor", "idx": 28444, "Desc": "creates an instance of ldapcertstoreparameters with the specified server name and a default port of 389 ."}{"node_name": "LDAPCertStoreParameters()", "type": "constructor", "idx": 28446, "Desc": "creates an instance of ldapcertstoreparameters with the default parameter values ( server name \" localhost \" , port 389 ) ."}{"node_name": "PKIXBuilderParameters(java.util.Set,java.security.cert.CertSelector)", "type": "constructor", "idx": 28452, "Desc": "creates an instance of pkixbuilderparameters with the specified set of most-trusted cas . each element of the set is a trustanchor . note that the set is copied to protect against subsequent modifications ."}{"node_name": "PKIXBuilderParameters(java.security.KeyStore,java.security.cert.CertSelector)", "type": "constructor", "idx": 28455, "Desc": "creates an instance of pkixbuilderparameters that populates the set of most-trusted cas from the trusted certificate entries contained in the specified keystore . only keystore entries that contain trusted x509certificates are considered ; all other certificate types are ignored ."}{"node_name": "PKIXCertPathBuilderResult(java.security.cert.CertPath,java.security.cert.TrustAnchor,java.security.cert.PolicyNode,java.security.PublicKey)", "type": "constructor", "idx": 28463, "Desc": "creates an instance of pkixcertpathbuilderresult containing the specified parameters ."}{"node_name": "PKIXCertPathChecker()", "type": "constructor", "idx": 28471, "Desc": "default constructor ."}{"node_name": "PKIXCertPathValidatorResult(java.security.cert.TrustAnchor,java.security.cert.PolicyNode,java.security.PublicKey)", "type": "constructor", "idx": 28483, "Desc": "creates an instance of pkixcertpathvalidatorresult containing the specified parameters ."}{"node_name": "PKIXParameters(java.util.Set)", "type": "constructor", "idx": 28493, "Desc": "creates an instance of pkixparameters with the specified set of most-trusted cas . each element of the set is a trustanchor . note that the set is copied to protect against subsequent modifications ."}{"node_name": "PKIXParameters(java.security.KeyStore)", "type": "constructor", "idx": 28495, "Desc": "creates an instance of pkixparameters that populates the set of most-trusted cas from the trusted certificate entries contained in the specified keystore . only keystore entries that contain trusted x509certificates are considered ; all other certificate types are ignored ."}{"node_name": "PKIXRevocationChecker()", "type": "constructor", "idx": 28544, "Desc": "default constructor ."}{"node_name": "PolicyQualifierInfo(byte[])", "type": "constructor", "idx": 28575, "Desc": "creates an instance of policyqualifierinfo from the encoded bytes . the encoded byte array is copied on construction ."}{"node_name": "TrustAnchor(java.security.cert.X509Certificate,byte[])", "type": "constructor", "idx": 28582, "Desc": "creates an instance of trustanchor with the specified x509certificate and optional name constraints , which are intended to be used as additional constraints when validating an x.509 certification path . the name constraints are specified as a byte array . this byte array should contain the der encoded form of the name constraints , as they would appear in the nameconstraints structure defined in rfc 5280 and x.509 . the asn.1 definition of this structure appears below . nameconstraints :: = sequence { permittedsubtrees [ 0 ] generalsubtrees optional , excludedsubtrees [ 1 ] generalsubtrees optional } generalsubtrees :: = sequence size ( 1 .. max ) of generalsubtree generalsubtree :: = sequence { base generalname , minimum [ 0 ] basedistance default 0 , maximum [ 1 ] basedistance optional } basedistance :: = integer ( 0 .. max ) generalname :: = choice { othername [ 0 ] othername , rfc822name [ 1 ] ia5string , dnsname [ 2 ] ia5string , x400address [ 3 ] oraddress , directoryname [ 4 ] name , edipartyname [ 5 ] edipartyname , uniformresourceidentifier [ 6 ] ia5string , ipaddress [ 7 ] octet string , registeredid [ 8 ] object identifier } note that the name constraints byte array supplied is cloned to protect against subsequent modifications ."}{"node_name": "TrustAnchor(javax.security.auth.x500.X500Principal,java.security.PublicKey,byte[])", "type": "constructor", "idx": 28585, "Desc": "creates an instance of trustanchor where the most-trusted ca is specified as an x500principal and public key . name constraints are an optional parameter , and are intended to be used as additional constraints when validating an x.509 certification path . the name constraints are specified as a byte array . this byte array contains the der encoded form of the name constraints , as they would appear in the nameconstraints structure defined in rfc 5280 and x.509 . the asn.1 notation for this structure is supplied in the documentation for trustanchor ( x509certificate trustedcert , byte [ ] nameconstraints ) . note that the name constraints byte array supplied here is cloned to protect against subsequent modifications ."}{"node_name": "TrustAnchor(java.lang.String,java.security.PublicKey,byte[])", "type": "constructor", "idx": 28589, "Desc": "creates an instance of trustanchor where the most-trusted ca is specified as a distinguished name and public key . name constraints are an optional parameter , and are intended to be used as additional constraints when validating an x.509 certification path . the name constraints are specified as a byte array . this byte array contains the der encoded form of the name constraints , as they would appear in the nameconstraints structure defined in rfc 5280 and x.509 . the asn.1 notation for this structure is supplied in the documentation for trustanchor ( x509certificate trustedcert , byte [ ] nameconstraints ) . note that the name constraints byte array supplied here is cloned to protect against subsequent modifications ."}{"node_name": "URICertStoreParameters(java.net.URI)", "type": "constructor", "idx": 28600, "Desc": "creates an instance of uricertstoreparameters with the specified uri ."}{"node_name": "X509Certificate()", "type": "constructor", "idx": 28609, "Desc": "constructor for x.509 certificates ."}{"node_name": "X509CertSelector()", "type": "constructor", "idx": 28637, "Desc": "creates an x509certselector . initially , no criteria are set so any x509certificate will match ."}{"node_name": "X509CRL()", "type": "constructor", "idx": 28723, "Desc": "constructor for x.509 crls ."}{"node_name": "X509CRLEntry()", "type": "constructor", "idx": 28752, "Desc": ""}{"node_name": "X509CRLSelector()", "type": "constructor", "idx": 28764, "Desc": "creates an x509crlselector . initially , no criteria are set so any x509crl will match ."}{"node_name": "CodeSigner(java.security.cert.CertPath,java.security.Timestamp)", "type": "constructor", "idx": 28801, "Desc": "constructs a codesigner object ."}{"node_name": "CodeSource(java.net.URL,java.security.cert.Certificate[])", "type": "constructor", "idx": 28811, "Desc": "constructs a codesource and associates it with the specified location and set of certificates ."}{"node_name": "CodeSource(java.net.URL,java.security.CodeSigner[])", "type": "constructor", "idx": 28814, "Desc": "constructs a codesource and associates it with the specified location and set of code signers ."}{"node_name": "DigestException()", "type": "constructor", "idx": 28831, "Desc": "constructs a digestexception with no detail message . ( a detail message is a string that describes this particular exception . )"}{"node_name": "DigestException(java.lang.String)", "type": "constructor", "idx": 28832, "Desc": "constructs a digestexception with the specified detail message . ( a detail message is a string that describes this particular exception . )"}{"node_name": "DigestException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28834, "Desc": "creates a digestexception with the specified detail message and cause ."}{"node_name": "DigestException(java.lang.Throwable)", "type": "constructor", "idx": 28837, "Desc": "creates a digestexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "DigestInputStream(java.io.InputStream,java.security.MessageDigest)", "type": "constructor", "idx": 28841, "Desc": "creates a digest input stream , using the specified input stream and message digest ."}{"node_name": "DigestOutputStream(java.io.OutputStream,java.security.MessageDigest)", "type": "constructor", "idx": 28857, "Desc": "creates a digest output stream , using the specified output stream and message digest ."}{"node_name": "DomainLoadStoreParameter(java.net.URI,java.util.Map)", "type": "constructor", "idx": 28877, "Desc": "constructs a domainloadstoreparameter for a keystore domain with the parameters used to protect keystore data ."}{"node_name": "GeneralSecurityException()", "type": "constructor", "idx": 28914, "Desc": "constructs a generalsecurityexception with no detail message ."}{"node_name": "GeneralSecurityException(java.lang.String)", "type": "constructor", "idx": 28915, "Desc": "constructs a generalsecurityexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "GeneralSecurityException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28917, "Desc": "creates a generalsecurityexception with the specified detail message and cause ."}{"node_name": "GeneralSecurityException(java.lang.Throwable)", "type": "constructor", "idx": 28920, "Desc": "creates a generalsecurityexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "GuardedObject(java.lang.Object,java.security.Guard)", "type": "constructor", "idx": 28926, "Desc": "constructs a guardedobject using the specified object and guard . if the guard object is null , then no restrictions will be placed on who can access the object ."}{"node_name": "InvalidAlgorithmParameterException()", "type": "constructor", "idx": 28985, "Desc": "constructs an invalidalgorithmparameterexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidAlgorithmParameterException(java.lang.String)", "type": "constructor", "idx": 28986, "Desc": "constructs an invalidalgorithmparameterexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidAlgorithmParameterException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28988, "Desc": "creates an invalidalgorithmparameterexception with the specified detail message and cause ."}{"node_name": "InvalidAlgorithmParameterException(java.lang.Throwable)", "type": "constructor", "idx": 28991, "Desc": "creates an invalidalgorithmparameterexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "InvalidKeyException()", "type": "constructor", "idx": 28994, "Desc": "constructs an invalidkeyexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidKeyException(java.lang.String)", "type": "constructor", "idx": 28995, "Desc": "constructs an invalidkeyexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidKeyException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 28997, "Desc": "creates an invalidkeyexception with the specified detail message and cause ."}{"node_name": "InvalidKeyException(java.lang.Throwable)", "type": "constructor", "idx": 29000, "Desc": "creates an invalidkeyexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "InvalidParameterException()", "type": "constructor", "idx": 29003, "Desc": "constructs an invalidparameterexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidParameterException(java.lang.String)", "type": "constructor", "idx": 29004, "Desc": "constructs an invalidparameterexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "KeyException()", "type": "constructor", "idx": 29011, "Desc": "constructs a keyexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "KeyException(java.lang.String)", "type": "constructor", "idx": 29012, "Desc": "constructs a keyexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "KeyException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29014, "Desc": "creates a keyexception with the specified detail message and cause ."}{"node_name": "KeyException(java.lang.Throwable)", "type": "constructor", "idx": 29017, "Desc": "creates a keyexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "KeyFactory(java.security.KeyFactorySpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 29020, "Desc": "creates a keyfactory object ."}{"node_name": "KeyFactorySpi()", "type": "constructor", "idx": 29044, "Desc": ""}{"node_name": "KeyManagementException()", "type": "constructor", "idx": 29055, "Desc": "constructs a keymanagementexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "KeyManagementException(java.lang.String)", "type": "constructor", "idx": 29056, "Desc": "constructs a keymanagementexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "KeyManagementException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29058, "Desc": "creates a keymanagementexception with the specified detail message and cause ."}{"node_name": "KeyManagementException(java.lang.Throwable)", "type": "constructor", "idx": 29061, "Desc": "creates a keymanagementexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "KeyPair(java.security.PublicKey,java.security.PrivateKey)", "type": "constructor", "idx": 29064, "Desc": "constructs a key pair from the given public key and private key . note that <init>(java.security.PublicKey,java.security.PrivateKey) only stores references to the public and private key components in the generated key pair . this is safe , because key objects are immutable ."}{"node_name": "KeyPairGenerator(java.lang.String)", "type": "constructor", "idx": 29070, "Desc": "creates a keypairgenerator object for the specified algorithm ."}{"node_name": "KeyPairGeneratorSpi()", "type": "constructor", "idx": 29095, "Desc": ""}{"node_name": "KeyRep(java.security.KeyRep.Type,java.lang.String,java.lang.String,byte[])", "type": "constructor", "idx": 29104, "Desc": "construct the alternate key class ."}{"node_name": "Builder()", "type": "constructor", "idx": 29115, "Desc": "construct a new builder ."}{"node_name": "CallbackHandlerProtection(javax.security.auth.callback.CallbackHandler)", "type": "constructor", "idx": 29135, "Desc": "constructs a new callbackhandlerprotection from a callbackhandler ."}{"node_name": "KeyStore(java.security.KeyStoreSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 29144, "Desc": "creates a keystore object of the given type , and encapsulates the given provider implementation ( spi object ) in it ."}{"node_name": "PasswordProtection(char[])", "type": "constructor", "idx": 29221, "Desc": "creates a password parameter . the specified password is cloned before it is stored in the new passwordprotection object ."}{"node_name": "PasswordProtection(char[],java.lang.String,java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 29223, "Desc": "creates a password parameter and specifies the protection algorithm and associated parameters to use when encrypting a keystore entry . the specified password is cloned before it is stored in the new passwordprotection object ."}{"node_name": "PrivateKeyEntry(java.security.PrivateKey,java.security.cert.Certificate[])", "type": "constructor", "idx": 29233, "Desc": "constructs a privatekeyentry with a privatekey and corresponding certificate chain . the specified chain is cloned before it is stored in the new privatekeyentry object ."}{"node_name": "PrivateKeyEntry(java.security.PrivateKey,java.security.cert.Certificate[],java.util.Set)", "type": "constructor", "idx": 29236, "Desc": "constructs a privatekeyentry with a privatekey and corresponding certificate chain and associated entry attributes . the specified chain and attributes are cloned before they are stored in the new privatekeyentry object ."}{"node_name": "SecretKeyEntry(javax.crypto.SecretKey)", "type": "constructor", "idx": 29247, "Desc": "constructs a secretkeyentry with a secretkey ."}{"node_name": "SecretKeyEntry(javax.crypto.SecretKey,java.util.Set)", "type": "constructor", "idx": 29249, "Desc": "constructs a secretkeyentry with a secretkey and associated entry attributes . the specified attributes is cloned before it is stored in the new secretkeyentry object ."}{"node_name": "TrustedCertificateEntry(java.security.cert.Certificate)", "type": "constructor", "idx": 29256, "Desc": "constructs a trustedcertificateentry with a trusted certificate ."}{"node_name": "TrustedCertificateEntry(java.security.cert.Certificate,java.util.Set)", "type": "constructor", "idx": 29258, "Desc": "constructs a trustedcertificateentry with a trusted certificate and associated entry attributes . the specified attributes is cloned before it is stored in the new trustedcertificateentry object ."}{"node_name": "KeyStoreException()", "type": "constructor", "idx": 29265, "Desc": "constructs a keystoreexception with no detail message . ( a detail message is a string that describes this particular exception . )"}{"node_name": "KeyStoreException(java.lang.String)", "type": "constructor", "idx": 29266, "Desc": "constructs a keystoreexception with the specified detail message . ( a detail message is a string that describes this particular exception . )"}{"node_name": "KeyStoreException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29268, "Desc": "creates a keystoreexception with the specified detail message and cause ."}{"node_name": "KeyStoreException(java.lang.Throwable)", "type": "constructor", "idx": 29271, "Desc": "creates a keystoreexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "KeyStoreSpi()", "type": "constructor", "idx": 29274, "Desc": ""}{"node_name": "MessageDigest(java.lang.String)", "type": "constructor", "idx": 29331, "Desc": "creates a message digest with the specified algorithm name ."}{"node_name": "MessageDigestSpi()", "type": "constructor", "idx": 29368, "Desc": ""}{"node_name": "NoSuchAlgorithmException()", "type": "constructor", "idx": 29386, "Desc": "constructs a nosuchalgorithmexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "NoSuchAlgorithmException(java.lang.String)", "type": "constructor", "idx": 29387, "Desc": "constructs a nosuchalgorithmexception with the specified detail message . a detail message is a string that describes this particular exception , which may , for example , specify which algorithm is not available ."}{"node_name": "NoSuchAlgorithmException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29389, "Desc": "creates a nosuchalgorithmexception with the specified detail message and cause ."}{"node_name": "NoSuchAlgorithmException(java.lang.Throwable)", "type": "constructor", "idx": 29392, "Desc": "creates a nosuchalgorithmexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "NoSuchProviderException()", "type": "constructor", "idx": 29395, "Desc": "constructs a nosuchproviderexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "NoSuchProviderException(java.lang.String)", "type": "constructor", "idx": 29396, "Desc": "constructs a nosuchproviderexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "Permission(java.lang.String)", "type": "constructor", "idx": 29399, "Desc": "constructs a permission with the specified name ."}{"node_name": "PermissionCollection()", "type": "constructor", "idx": 29413, "Desc": ""}{"node_name": "Permissions()", "type": "constructor", "idx": 29424, "Desc": "creates a new permissions object containing no permissioncollections ."}{"node_name": "PKCS12Attribute(java.lang.String,java.lang.String)", "type": "constructor", "idx": 29431, "Desc": "constructs a pkcs12 attribute from its name and value . the name is an asn.1 object identifier represented as a list of dot-separated integers . a string value is represented as the string itself . a binary value is represented as a string of colon-separated pairs of hexadecimal digits . multi-valued attributes are represented as a comma-separated list of values , enclosed in square brackets . see arrays.tostring ( java.lang.object [ ]) . a string value will be der-encoded as an asn.1 utf8string and a binary value will be der-encoded as an asn.1 octet string ."}{"node_name": "PKCS12Attribute(byte[])", "type": "constructor", "idx": 29434, "Desc": "constructs a pkcs12 attribute from its asn.1 der encoding . the der encoding is specified by the following asn.1 definition : attribute :: = sequence { type attributetype , values set of attributevalue } attributetype :: = object identifier attributevalue :: = any defined by type"}{"node_name": "Policy()", "type": "constructor", "idx": 29445, "Desc": ""}{"node_name": "PolicySpi()", "type": "constructor", "idx": 29473, "Desc": ""}{"node_name": "PrivilegedActionException(java.lang.Exception)", "type": "constructor", "idx": 29494, "Desc": "constructs a new privilegedactionexception \" wrapping \" the specific exception ."}{"node_name": "ProtectionDomain(java.security.CodeSource,java.security.PermissionCollection)", "type": "constructor", "idx": 29500, "Desc": "creates a new protectiondomain with the given codesource and permissions . if the permissions object is not null , then setreadonly() will be called on the passed in permissions object . the permissions granted to this domain are static , i.e. invoking the staticpermissionsonly() method returns true . they contain only the ones passed to <init>(java.security.CodeSource,java.security.PermissionCollection) and the current policy will not be consulted ."}{"node_name": "ProtectionDomain(java.security.CodeSource,java.security.PermissionCollection,java.lang.ClassLoader,java.security.Principal[])", "type": "constructor", "idx": 29503, "Desc": "creates a new protectiondomain qualified by the given codesource , permissions , classloader and array of principals . if the permissions object is not null , then setreadonly() will be called on the passed in permissions object . the permissions granted to this domain are dynamic , i.e. invoking the staticpermissionsonly() method returns false . they include both the static permissions passed to <init>(java.security.CodeSource,java.security.PermissionCollection,java.lang.ClassLoader,java.security.Principal[]) , and any permissions granted to this domain by the current policy at the time a permission is checked . <init>(java.security.CodeSource,java.security.PermissionCollection,java.lang.ClassLoader,java.security.Principal[]) is typically used by classloaders and domaincombiners which delegate to policy to actively associate the permissions granted to this domain . <init>(java.security.CodeSource,java.security.PermissionCollection,java.lang.ClassLoader,java.security.Principal[]) affords the policy provider the opportunity to augment the supplied permissioncollection to reflect policy changes ."}{"node_name": "Provider(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 29517, "Desc": "constructs a provider with the specified name , version string , and information . the version string contains a version number optionally followed by other information separated by one of the characters of ' + ' , ' - ' . the format for the version number is : ^ [ 0-9 ] + ( \\ . [ 0-9 ] + ) * in order to return the version number in a double , when there are more than two components ( separated by ' . ' as defined above ) , only the first two components are retained . the resulting string is then passed to double.valueof ( string ) to generate version number , i.e. getversion() . if the conversion failed , value 0 will be used ."}{"node_name": "Service(java.security.Provider,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.Map)", "type": "constructor", "idx": 29583, "Desc": "construct a new service ."}{"node_name": "ProviderException()", "type": "constructor", "idx": 29602, "Desc": "constructs a providerexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "ProviderException(java.lang.String)", "type": "constructor", "idx": 29603, "Desc": "constructs a providerexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "ProviderException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29605, "Desc": "creates a providerexception with the specified detail message and cause ."}{"node_name": "ProviderException(java.lang.Throwable)", "type": "constructor", "idx": 29608, "Desc": "creates a providerexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "SecureClassLoader(java.lang.ClassLoader)", "type": "constructor", "idx": 29612, "Desc": "creates a new secureclassloader using the specified parent class loader for delegation . if there is a security manager , this method first calls the security manager's checkcreateclassloader method to ensure creation of a class loader is allowed ."}{"node_name": "SecureClassLoader()", "type": "constructor", "idx": 29614, "Desc": "creates a new secureclassloader using the default parent class loader for delegation . if there is a security manager , this method first calls the security manager's checkcreateclassloader method to ensure creation of a class loader is allowed ."}{"node_name": "SecureClassLoader(java.lang.String,java.lang.ClassLoader)", "type": "constructor", "idx": 29615, "Desc": "creates a new secureclassloader of the specified name and using the specified parent class loader for delegation ."}{"node_name": "SecureRandom()", "type": "constructor", "idx": 29631, "Desc": "constructs a secure random number generator ( rng ) implementing the default random number algorithm . <init>() traverses the list of registered security providers , starting with the most preferred provider . a new securerandom object encapsulating the securerandomspi implementation from the first provider that supports a securerandom ( rng ) algorithm is returned . if none of the providers support a rng algorithm , then an implementation-specific default is returned . note that the list of registered providers may be retrieved via the security.getproviders() method . see the securerandom section in the java security standard algorithm names specification for information about standard rng algorithm names ."}{"node_name": "SecureRandom(byte[])", "type": "constructor", "idx": 29632, "Desc": "constructs a secure random number generator ( rng ) implementing the default random number algorithm . the securerandom instance is seeded with the specified seed bytes . <init>(byte[]) traverses the list of registered security providers , starting with the most preferred provider . a new securerandom object encapsulating the securerandomspi implementation from the first provider that supports a securerandom ( rng ) algorithm is returned . if none of the providers support a rng algorithm , then an implementation-specific default is returned . note that the list of registered providers may be retrieved via the security.getproviders() method . see the securerandom section in the java security standard algorithm names specification for information about standard rng algorithm names ."}{"node_name": "SecureRandom(java.security.SecureRandomSpi,java.security.Provider)", "type": "constructor", "idx": 29634, "Desc": "creates a securerandom object ."}{"node_name": "SecureRandomSpi()", "type": "constructor", "idx": 29681, "Desc": "constructor without a parameter ."}{"node_name": "SecureRandomSpi(java.security.SecureRandomParameters)", "type": "constructor", "idx": 29682, "Desc": "constructor with a parameter ."}{"node_name": "SecurityPermission(java.lang.String)", "type": "constructor", "idx": 29720, "Desc": "creates a new securitypermission with the specified name . the name is the symbolic name of the securitypermission . an asterisk may appear at the end of the name , following a \" . \" , or by itself , to signify a wildcard match ."}{"node_name": "SecurityPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 29722, "Desc": "creates a new securitypermission object with the specified name . the name is the symbolic name of the securitypermission , and the actions string is currently unused and should be null ."}{"node_name": "Signature(java.lang.String)", "type": "constructor", "idx": 29730, "Desc": "creates a signature object for the specified algorithm ."}{"node_name": "SignatureException()", "type": "constructor", "idx": 29778, "Desc": "constructs a signatureexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "SignatureException(java.lang.String)", "type": "constructor", "idx": 29779, "Desc": "constructs a signatureexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "SignatureException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29781, "Desc": "creates a signatureexception with the specified detail message and cause ."}{"node_name": "SignatureException(java.lang.Throwable)", "type": "constructor", "idx": 29784, "Desc": "creates a signatureexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "SignatureSpi()", "type": "constructor", "idx": 29788, "Desc": ""}{"node_name": "SignedObject(java.io.Serializable,java.security.PrivateKey,java.security.Signature)", "type": "constructor", "idx": 29820, "Desc": "constructs a signedobject from any serializable object . the given object is signed with the given signing key , using the designated signature engine ."}{"node_name": "DSAGenParameterSpec(int,int)", "type": "constructor", "idx": 29833, "Desc": "creates a domain parameter specification for dsa parameter generation using primeplen and subprimeqlen . the value of subprimeqlen is also used as the default length of the domain parameter seed in bits ."}{"node_name": "DSAGenParameterSpec(int,int,int)", "type": "constructor", "idx": 29836, "Desc": "creates a domain parameter specification for dsa parameter generation using primeplen , subprimeqlen , and seedlen ."}{"node_name": "DSAParameterSpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 29844, "Desc": "creates a new dsaparameterspec with the specified parameter values ."}{"node_name": "DSAPrivateKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 29852, "Desc": "creates a new dsaprivatekeyspec with the specified parameter values ."}{"node_name": "DSAPublicKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 29862, "Desc": "creates a new dsapublickeyspec with the specified parameter values ."}{"node_name": "ECFieldF2m(int)", "type": "constructor", "idx": 29874, "Desc": "creates an elliptic curve characteristic 2 finite field which has 2^m elements with normal basis ."}{"node_name": "ECFieldF2m(int,java.math.BigInteger)", "type": "constructor", "idx": 29876, "Desc": "creates an elliptic curve characteristic 2 finite field which has 2^m elements with polynomial basis . the reduction polynomial for this field is based on rp whose i-th bit corresponds to the i-th coefficient of the reduction polynomial . note : a valid reduction polynomial is either a trinomial ( x^m + x^k + 1 with m > k > = 1 ) or a pentanomial ( x^m + x^k3 + x^k2 + x^k1 + 1 with m > k3 > k2 > k1 > = 1 ) ."}{"node_name": "ECFieldF2m(int,int[])", "type": "constructor", "idx": 29879, "Desc": "creates an elliptic curve characteristic 2 finite field which has 2^m elements with polynomial basis . the reduction polynomial for this field is based on ks whose content contains the order of the middle term ( s ) of the reduction polynomial . note : a valid reduction polynomial is either a trinomial ( x^m + x^k + 1 with m > k > = 1 ) or a pentanomial ( x^m + x^k3 + x^k2 + x^k1 + 1 with m > k3 > k2 > k1 > = 1 ) , so ks should have length 1 or 3 ."}{"node_name": "ECFieldFp(java.math.BigInteger)", "type": "constructor", "idx": 29890, "Desc": "creates an elliptic curve prime finite field with the specified prime p ."}{"node_name": "ECGenParameterSpec(java.lang.String)", "type": "constructor", "idx": 29898, "Desc": "creates a parameter specification for ec parameter generation using a standard ( or predefined ) name stdname in order to generate the corresponding ( precomputed ) elliptic curve domain parameters . for the list of supported names , please consult the documentation of the provider whose implementation will be used ."}{"node_name": "ECParameterSpec(java.security.spec.EllipticCurve,java.security.spec.ECPoint,java.math.BigInteger,int)", "type": "constructor", "idx": 29901, "Desc": "creates elliptic curve domain parameters based on the specified values ."}{"node_name": "ECPoint(java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 29912, "Desc": "creates an ecpoint from the specified affine x-coordinate x and affine y-coordinate y ."}{"node_name": "ECPrivateKeySpec(java.math.BigInteger,java.security.spec.ECParameterSpec)", "type": "constructor", "idx": 29921, "Desc": "creates a new ecprivatekeyspec with the specified parameter values ."}{"node_name": "ECPublicKeySpec(java.security.spec.ECPoint,java.security.spec.ECParameterSpec)", "type": "constructor", "idx": 29927, "Desc": "creates a new ecpublickeyspec with the specified parameter values ."}{"node_name": "EllipticCurve(java.security.spec.ECField,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 29933, "Desc": "creates an elliptic curve with the specified elliptic field field and the coefficients a and b ."}{"node_name": "EllipticCurve(java.security.spec.ECField,java.math.BigInteger,java.math.BigInteger,byte[])", "type": "constructor", "idx": 29937, "Desc": "creates an elliptic curve with the specified elliptic field field , the coefficients a and b , and the seed used for curve generation ."}{"node_name": "EncodedKeySpec(byte[])", "type": "constructor", "idx": 29950, "Desc": "creates a new encodedkeyspec with the given encoded key ."}{"node_name": "EncodedKeySpec(byte[],java.lang.String)", "type": "constructor", "idx": 29952, "Desc": "creates a new encodedkeyspec with the given encoded key . <init>(byte[],java.lang.String) is useful when subsequent callers of the encodedkeyspec object might not know the algorithm of the key ."}{"node_name": "InvalidKeySpecException()", "type": "constructor", "idx": 29959, "Desc": "constructs an invalidkeyspecexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidKeySpecException(java.lang.String)", "type": "constructor", "idx": 29960, "Desc": "constructs an invalidkeyspecexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidKeySpecException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 29962, "Desc": "creates an invalidkeyspecexception with the specified detail message and cause ."}{"node_name": "InvalidKeySpecException(java.lang.Throwable)", "type": "constructor", "idx": 29965, "Desc": "creates an invalidkeyspecexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "InvalidParameterSpecException()", "type": "constructor", "idx": 29968, "Desc": "constructs an invalidparameterspecexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "InvalidParameterSpecException(java.lang.String)", "type": "constructor", "idx": 29969, "Desc": "constructs an invalidparameterspecexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "MGF1ParameterSpec(java.lang.String)", "type": "constructor", "idx": 29980, "Desc": "constructs a parameter set for mask generation function mgf1 as defined in the pkcs #1 standard ."}{"node_name": "NamedParameterSpec(java.lang.String)", "type": "constructor", "idx": 29986, "Desc": "creates a parameter specification using a standard ( or predefined ) name stdname . for the list of supported names , please consult the documentation of the provider whose implementation will be used ."}{"node_name": "PKCS8EncodedKeySpec(byte[])", "type": "constructor", "idx": 29990, "Desc": "creates a new pkcs8encodedkeyspec with the given encoded key ."}{"node_name": "PKCS8EncodedKeySpec(byte[],java.lang.String)", "type": "constructor", "idx": 29992, "Desc": "creates a new pkcs8encodedkeyspec with the given encoded key and algorithm . <init>(byte[],java.lang.String) is useful when subsequent callers of the pkcs8encodedkeyspec object might not know the algorithm of the private key ."}{"node_name": "PSSParameterSpec(java.lang.String,java.lang.String,java.security.spec.AlgorithmParameterSpec,int,int)", "type": "constructor", "idx": 30000, "Desc": "creates a new pssparameterspec as defined in the pkcs #1 standard using the specified message digest , mask generation function , parameters for mask generation function , salt length , and trailer field values ."}{"node_name": "PSSParameterSpec(int)", "type": "constructor", "idx": 30006, "Desc": "creates a new pssparameterspec using the specified salt length and other default values as defined in pkcs #1 ."}{"node_name": "RSAKeyGenParameterSpec(int,java.math.BigInteger)", "type": "constructor", "idx": 30016, "Desc": "constructs a new rsakeygenparameterspec object from the given keysize , public-exponent value , and null key parameters ."}{"node_name": "RSAKeyGenParameterSpec(int,java.math.BigInteger,java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 30019, "Desc": "constructs a new rsakeygenparameterspec object from the given keysize , public-exponent value , and key parameters ."}{"node_name": "RSAMultiPrimePrivateCrtKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.security.spec.RSAOtherPrimeInfo[])", "type": "constructor", "idx": 30027, "Desc": "creates a new rsamultiprimeprivatecrtkeyspec . note that the contents of otherprimeinfo are copied to protect against subsequent modification when constructing this object ."}{"node_name": "RSAMultiPrimePrivateCrtKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.security.spec.RSAOtherPrimeInfo[],java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 30037, "Desc": "creates a new rsamultiprimeprivatecrtkeyspec with additional key parameters . note that the contents of otherprimeinfo are copied to protect against subsequent modification when constructing this object ."}{"node_name": "RSAOtherPrimeInfo(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 30056, "Desc": "creates a new rsaotherprimeinfo given the prime , primeexponent , and crtcoefficient as defined in pkcs #1 ."}{"node_name": "RSAPrivateCrtKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 30064, "Desc": "creates a new rsaprivatecrtkeyspec ."}{"node_name": "RSAPrivateCrtKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.math.BigInteger,java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 30073, "Desc": "creates a new rsaprivatecrtkeyspec with additional key parameters ."}{"node_name": "RSAPrivateKeySpec(java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 30090, "Desc": "creates a new rsaprivatekeyspec ."}{"node_name": "RSAPrivateKeySpec(java.math.BigInteger,java.math.BigInteger,java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 30093, "Desc": "creates a new rsaprivatekeyspec with additional key parameters ."}{"node_name": "RSAPublicKeySpec(java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 30101, "Desc": "creates a new rsapublickeyspec ."}{"node_name": "RSAPublicKeySpec(java.math.BigInteger,java.math.BigInteger,java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 30104, "Desc": "creates a new rsapublickeyspec with additional key parameters ."}{"node_name": "X509EncodedKeySpec(byte[])", "type": "constructor", "idx": 30112, "Desc": "creates a new x509encodedkeyspec with the given encoded key ."}{"node_name": "X509EncodedKeySpec(byte[],java.lang.String)", "type": "constructor", "idx": 30114, "Desc": "creates a new x509encodedkeyspec with the given encoded key . <init>(byte[],java.lang.String) is useful when subsequent callers of the x509encodedkeyspec object might not know the algorithm of the key ."}{"node_name": "XECPrivateKeySpec(java.security.spec.AlgorithmParameterSpec,byte[])", "type": "constructor", "idx": 30120, "Desc": "construct a private key spec using the supplied parameters and encoded scalar value ."}{"node_name": "XECPublicKeySpec(java.security.spec.AlgorithmParameterSpec,java.math.BigInteger)", "type": "constructor", "idx": 30126, "Desc": "construct a public key spec using the supplied parameters and u coordinate ."}{"node_name": "Timestamp(java.util.Date,java.security.cert.CertPath)", "type": "constructor", "idx": 30132, "Desc": "constructs a timestamp ."}{"node_name": "UnrecoverableEntryException()", "type": "constructor", "idx": 30142, "Desc": "constructs an unrecoverableentryexception with no detail message ."}{"node_name": "UnrecoverableEntryException(java.lang.String)", "type": "constructor", "idx": 30143, "Desc": "constructs an unrecoverableentryexception with the specified detail message , which provides more information about why this exception has been thrown ."}{"node_name": "UnrecoverableKeyException()", "type": "constructor", "idx": 30146, "Desc": "constructs an unrecoverablekeyexception with no detail message ."}{"node_name": "UnrecoverableKeyException(java.lang.String)", "type": "constructor", "idx": 30147, "Desc": "constructs an unrecoverablekeyexception with the specified detail message , which provides more information about why this exception has been thrown ."}{"node_name": "UnresolvedPermission(java.lang.String,java.lang.String,java.lang.String,java.security.cert.Certificate[])", "type": "constructor", "idx": 30150, "Desc": "creates a new unresolvedpermission containing the permission information needed later to actually create a permission of the specified class , when the permission is resolved ."}{"node_name": "URIParameter(java.net.URI)", "type": "constructor", "idx": 30168, "Desc": "constructs a uriparameter with the uri pointing to data intended for an spi implementation ."}{"node_name": "BatchUpdateException(java.lang.String,java.lang.String,int,int[])", "type": "constructor", "idx": 30196, "Desc": "constructs a batchupdateexception object initialized with a given reason , sqlstate , vendorcode and updatecounts . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . note : there is no validation of updatecounts for overflow and because of this it is recommended that you use <init>(java.lang.String,java.lang.String,int,int[]) batchupdateexception ( string reason , string sqlstate , int vendorcode , long [ ] updatecounts , throwable cause ) ."}{"node_name": "BatchUpdateException(java.lang.String,java.lang.String,int[])", "type": "constructor", "idx": 30201, "Desc": "constructs a batchupdateexception object initialized with a given reason , sqlstate and updatecounts . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 . note : there is no validation of updatecounts for overflow and because of this it is recommended that you use <init>(java.lang.String,java.lang.String,int[]) batchupdateexception ( string reason , string sqlstate , int vendorcode , long [ ] updatecounts , throwable cause ) ."}{"node_name": "BatchUpdateException(java.lang.String,int[])", "type": "constructor", "idx": 30205, "Desc": "constructs a batchupdateexception object initialized with a given reason and updatecounts . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the sqlstate is initialized to null and the vendor code is initialized to 0 . note : there is no validation of updatecounts for overflow and because of this it is recommended that you use <init>(java.lang.String,int[]) batchupdateexception ( string reason , string sqlstate , int vendorcode , long [ ] updatecounts , throwable cause ) ."}{"node_name": "BatchUpdateException(int[])", "type": "constructor", "idx": 30208, "Desc": "constructs a batchupdateexception object initialized with a given updatecounts . initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the reason and sqlstate are initialized to null and the vendor code is initialized to 0 . note : there is no validation of updatecounts for overflow and because of this it is recommended that you use <init>(int[]) batchupdateexception ( string reason , string sqlstate , int vendorcode , long [ ] updatecounts , throwable cause ) ."}{"node_name": "BatchUpdateException()", "type": "constructor", "idx": 30210, "Desc": "constructs a batchupdateexception object . the reason , sqlstate and updatecounts are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "BatchUpdateException(java.lang.Throwable)", "type": "constructor", "idx": 30211, "Desc": "constructs a batchupdateexception object initialized with a given cause . the sqlstate and updatecounts are initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "BatchUpdateException(int[],java.lang.Throwable)", "type": "constructor", "idx": 30213, "Desc": "constructs a batchupdateexception object initialized with a given cause and updatecounts . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null . note : there is no validation of updatecounts for overflow and because of this it is recommended that you use <init>(int[],java.lang.Throwable) batchupdateexception ( string reason , string sqlstate , int vendorcode , long [ ] updatecounts , throwable cause ) ."}{"node_name": "BatchUpdateException(java.lang.String,int[],java.lang.Throwable)", "type": "constructor", "idx": 30216, "Desc": "constructs a batchupdateexception object initialized with a given reason , cause and updatecounts . the sqlstate is initialized to null and the vendor code is initialized to 0 . note : there is no validation of updatecounts for overflow and because of this it is recommended that you use <init>(java.lang.String,int[],java.lang.Throwable) batchupdateexception ( string reason , string sqlstate , int vendorcode , long [ ] updatecounts , throwable cause ) ."}{"node_name": "BatchUpdateException(java.lang.String,java.lang.String,int[],java.lang.Throwable)", "type": "constructor", "idx": 30220, "Desc": "constructs a batchupdateexception object initialized with a given reason , sqlstate , cause , and updatecounts . the vendor code is initialized to 0 ."}{"node_name": "BatchUpdateException(java.lang.String,java.lang.String,int,int[],java.lang.Throwable)", "type": "constructor", "idx": 30225, "Desc": "constructs a batchupdateexception object initialized with a given reason , sqlstate , vendorcode cause and updatecounts ."}{"node_name": "BatchUpdateException(java.lang.String,java.lang.String,int,long[],java.lang.Throwable)", "type": "constructor", "idx": 30231, "Desc": "constructs a batchupdateexception object initialized with a given reason , sqlstate , vendorcode cause and updatecounts . <init>(java.lang.String,java.lang.String,int,long[],java.lang.Throwable) should be used when the returned update count may exceed integer.max_value ."}{"node_name": "DataTruncation(int,boolean,boolean,int,int)", "type": "constructor", "idx": 31104, "Desc": "creates a datatruncation object with the sqlstate initialized to 01004 when read is set to true and 22001 when read is set to false , the reason set to \" data truncation \" , the vendor code set to 0 , and the other fields set to the given values . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "DataTruncation(int,boolean,boolean,int,int,java.lang.Throwable)", "type": "constructor", "idx": 31110, "Desc": "creates a datatruncation object with the sqlstate initialized to 01004 when read is set to true and 22001 when read is set to false , the reason set to \" data truncation \" , the vendor code set to 0 , and the other fields set to the given values ."}{"node_name": "Date(long)", "type": "constructor", "idx": 31123, "Desc": "constructs a date object using the given milliseconds time value . if the given milliseconds value contains time information , the driver will set the time components to the time in the default time zone ( the time zone of the java virtual machine running the application ) that corresponds to zero gmt ."}{"node_name": "DriverPropertyInfo(java.lang.String,java.lang.String)", "type": "constructor", "idx": 31184, "Desc": "constructs a driverpropertyinfo object with a given name and value . the description and choices are initialized to null and required is initialized to false ."}{"node_name": "SQLClientInfoException()", "type": "constructor", "idx": 31951, "Desc": "constructs a sqlclientinfoexception object . the reason , sqlstate , and failedproperties list are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLClientInfoException(java.util.Map)", "type": "constructor", "idx": 31952, "Desc": "constructs a sqlclientinfoexception object initialized with a given failedproperties . the reason and sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLClientInfoException(java.util.Map,java.lang.Throwable)", "type": "constructor", "idx": 31954, "Desc": "constructs a sqlclientinfoexception object initialized with a given cause and failedproperties . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null and the vendor code is initialized to 0 ."}{"node_name": "SQLClientInfoException(java.lang.String,java.util.Map)", "type": "constructor", "idx": 31957, "Desc": "constructs a sqlclientinfoexception object initialized with a given reason and failedproperties . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLClientInfoException(java.lang.String,java.util.Map,java.lang.Throwable)", "type": "constructor", "idx": 31960, "Desc": "constructs a sqlclientinfoexception object initialized with a given reason , cause and failedproperties . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLClientInfoException(java.lang.String,java.lang.String,java.util.Map)", "type": "constructor", "idx": 31964, "Desc": "constructs a sqlclientinfoexception object initialized with a given reason , sqlstate and failedproperties . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLClientInfoException(java.lang.String,java.lang.String,java.util.Map,java.lang.Throwable)", "type": "constructor", "idx": 31968, "Desc": "constructs a sqlclientinfoexception object initialized with a given reason , sqlstate , cause and failedproperties . the vendor code is initialized to 0 ."}{"node_name": "SQLClientInfoException(java.lang.String,java.lang.String,int,java.util.Map)", "type": "constructor", "idx": 31973, "Desc": "constructs a sqlclientinfoexception object initialized with a given reason , sqlstate , vendorcode and failedproperties . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLClientInfoException(java.lang.String,java.lang.String,int,java.util.Map,java.lang.Throwable)", "type": "constructor", "idx": 31978, "Desc": "constructs a sqlclientinfoexception object initialized with a given reason , sqlstate , cause , vendorcode and failedproperties ."}{"node_name": "SQLDataException()", "type": "constructor", "idx": 31993, "Desc": "constructs a sqldataexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLDataException(java.lang.String)", "type": "constructor", "idx": 31994, "Desc": "constructs a sqldataexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLDataException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 31996, "Desc": "constructs a sqldataexception object with a given reason and sqlstate . the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLDataException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 31999, "Desc": "constructs a sqldataexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLDataException(java.lang.Throwable)", "type": "constructor", "idx": 32003, "Desc": "constructs a sqldataexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLDataException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32005, "Desc": "constructs a sqldataexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLDataException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32008, "Desc": "constructs a sqldataexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLDataException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32012, "Desc": "constructs a sqldataexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32018, "Desc": "constructs a sqlexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32022, "Desc": "constructs a sqlexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLException(java.lang.String)", "type": "constructor", "idx": 32025, "Desc": "constructs a sqlexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLException()", "type": "constructor", "idx": 32027, "Desc": "constructs a sqlexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLException(java.lang.Throwable)", "type": "constructor", "idx": 32028, "Desc": "constructs a sqlexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32030, "Desc": "constructs a sqlexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32033, "Desc": "constructs a sqlexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32037, "Desc": "constructs a sqlexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLFeatureNotSupportedException()", "type": "constructor", "idx": 32049, "Desc": "constructs a sqlfeaturenotsupportedexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.String)", "type": "constructor", "idx": 32050, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32052, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32055, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.Throwable)", "type": "constructor", "idx": 32059, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32061, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32064, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLFeatureNotSupportedException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32068, "Desc": "constructs a sqlfeaturenotsupportedexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLIntegrityConstraintViolationException()", "type": "constructor", "idx": 32104, "Desc": "constructs a sqlintegrityconstraintviolationexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.String)", "type": "constructor", "idx": 32105, "Desc": "constructs a sqlintegrityconstraintviolationexception with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32107, "Desc": "constructs a sqlintegrityconstraintviolationexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32110, "Desc": "constructs a sqlintegrityconstraintviolationexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.Throwable)", "type": "constructor", "idx": 32114, "Desc": "constructs an sqlintegrityconstraintviolationexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32116, "Desc": "constructs a sqlintegrityconstraintviolationexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32119, "Desc": "constructs a sqlintegrityconstraintviolationexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLIntegrityConstraintViolationException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32123, "Desc": "constructs a sqlintegrityconstraintviolationexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLInvalidAuthorizationSpecException()", "type": "constructor", "idx": 32129, "Desc": "constructs a sqlinvalidauthorizationspecexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.String)", "type": "constructor", "idx": 32130, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32132, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32135, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.Throwable)", "type": "constructor", "idx": 32139, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32141, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32144, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLInvalidAuthorizationSpecException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32148, "Desc": "constructs a sqlinvalidauthorizationspecexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLNonTransientConnectionException()", "type": "constructor", "idx": 32154, "Desc": "constructs a sqlnontransientconnectionexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLNonTransientConnectionException(java.lang.String)", "type": "constructor", "idx": 32155, "Desc": "constructs a sqlnontransientconnectionexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLNonTransientConnectionException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32157, "Desc": "constructs a sqlnontransientconnectionexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLNonTransientConnectionException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32160, "Desc": "constructs a sqlnontransientconnectionexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLNonTransientConnectionException(java.lang.Throwable)", "type": "constructor", "idx": 32164, "Desc": "constructs a sqlnontransientconnectionexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLNonTransientConnectionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32166, "Desc": "constructs a sqltransientexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLNonTransientConnectionException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32169, "Desc": "constructs a sqlnontransientconnectionexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLNonTransientConnectionException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32173, "Desc": "constructs a sqlnontransientconnectionexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLNonTransientException()", "type": "constructor", "idx": 32179, "Desc": "constructs a sqlnontransientexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLNonTransientException(java.lang.String)", "type": "constructor", "idx": 32180, "Desc": "constructs a sqlnontransientexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLNonTransientException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32182, "Desc": "constructs a sqlnontransientexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLNonTransientException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32185, "Desc": "constructs a sqlnontransientexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLNonTransientException(java.lang.Throwable)", "type": "constructor", "idx": 32189, "Desc": "constructs a sqlnontransientexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLNonTransientException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32191, "Desc": "constructs a sqltransientexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLNonTransientException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32194, "Desc": "constructs a sqlnontransientexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLNonTransientException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32198, "Desc": "constructs a sqlnontransientexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLPermission(java.lang.String)", "type": "constructor", "idx": 32262, "Desc": "creates a new sqlpermission object with the specified name . the name is the symbolic name of the sqlpermission ."}{"node_name": "SQLPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32264, "Desc": "creates a new sqlpermission object with the specified name . the name is the symbolic name of the sqlpermission ; the actions string is currently unused and should be null ."}{"node_name": "SQLRecoverableException()", "type": "constructor", "idx": 32268, "Desc": "constructs a sqlrecoverableexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLRecoverableException(java.lang.String)", "type": "constructor", "idx": 32269, "Desc": "constructs a sqlrecoverableexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLRecoverableException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32271, "Desc": "constructs a sqlrecoverableexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLRecoverableException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32274, "Desc": "constructs a sqlrecoverableexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLRecoverableException(java.lang.Throwable)", "type": "constructor", "idx": 32278, "Desc": "constructs a sqlrecoverableexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLRecoverableException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32280, "Desc": "constructs a sqlrecoverableexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLRecoverableException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32283, "Desc": "constructs a sqlrecoverableexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLRecoverableException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32287, "Desc": "constructs a sqlrecoverableexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLSyntaxErrorException()", "type": "constructor", "idx": 32293, "Desc": "constructs a sqlsyntaxerrorexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLSyntaxErrorException(java.lang.String)", "type": "constructor", "idx": 32294, "Desc": "constructs a sqlsyntaxerrorexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLSyntaxErrorException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32296, "Desc": "constructs a sqlsyntaxerrorexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLSyntaxErrorException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32299, "Desc": "constructs a sqlsyntaxerrorexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLSyntaxErrorException(java.lang.Throwable)", "type": "constructor", "idx": 32303, "Desc": "constructs a sqlsyntaxerrorexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLSyntaxErrorException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32305, "Desc": "constructs a sqlsyntaxerrorexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLSyntaxErrorException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32308, "Desc": "constructs a sqlsyntaxerrorexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLSyntaxErrorException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32312, "Desc": "constructs a sqlsyntaxerrorexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLTimeoutException()", "type": "constructor", "idx": 32318, "Desc": "constructs a sqltimeoutexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTimeoutException(java.lang.String)", "type": "constructor", "idx": 32319, "Desc": "constructs a sqltimeoutexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTimeoutException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32321, "Desc": "constructs a sqltimeoutexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLTimeoutException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32324, "Desc": "constructs a sqltimeoutexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTimeoutException(java.lang.Throwable)", "type": "constructor", "idx": 32328, "Desc": "constructs a sqltimeoutexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLTimeoutException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32330, "Desc": "constructs a sqltimeoutexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLTimeoutException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32333, "Desc": "constructs a sqltimeoutexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLTimeoutException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32337, "Desc": "constructs a sqltimeoutexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLTransactionRollbackException()", "type": "constructor", "idx": 32343, "Desc": "constructs a sqltransactionrollbackexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransactionRollbackException(java.lang.String)", "type": "constructor", "idx": 32344, "Desc": "constructs a sqltransactionrollbackexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransactionRollbackException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32346, "Desc": "constructs a sqltransactionrollbackexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLTransactionRollbackException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32349, "Desc": "constructs a sqltransactionrollbackexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransactionRollbackException(java.lang.Throwable)", "type": "constructor", "idx": 32353, "Desc": "constructs a sqltransactionrollbackexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLTransactionRollbackException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32355, "Desc": "constructs a sqltransactionrollbackexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLTransactionRollbackException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32358, "Desc": "constructs a sqltransactionrollbackexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLTransactionRollbackException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32362, "Desc": "constructs a sqltransactionrollbackexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLTransientConnectionException()", "type": "constructor", "idx": 32368, "Desc": "constructs a sqltransientconnectionexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransientConnectionException(java.lang.String)", "type": "constructor", "idx": 32369, "Desc": "constructs a sqltransientconnectionexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransientConnectionException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32371, "Desc": "constructs a sqltransientconnectionexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLTransientConnectionException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32374, "Desc": "constructs a sqltransientconnectionexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransientConnectionException(java.lang.Throwable)", "type": "constructor", "idx": 32378, "Desc": "constructs a sqltransientconnectionexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLTransientConnectionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32380, "Desc": "constructs a sqltransientconnectionexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLTransientConnectionException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32383, "Desc": "constructs a sqltransientconnectionexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLTransientConnectionException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32387, "Desc": "constructs a sqltransientconnectionexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLTransientException()", "type": "constructor", "idx": 32393, "Desc": "constructs a sqltransientexception object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransientException(java.lang.String)", "type": "constructor", "idx": 32394, "Desc": "constructs a sqltransientexception object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransientException(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32396, "Desc": "constructs a sqltransientexception object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLTransientException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32399, "Desc": "constructs a sqltransientexception object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLTransientException(java.lang.Throwable)", "type": "constructor", "idx": 32403, "Desc": "constructs a sqltransientexception object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLTransientException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32405, "Desc": "constructs a sqltransientexception object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLTransientException(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32408, "Desc": "constructs a sqltransientexception object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLTransientException(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32412, "Desc": "constructs a sqltransientexception object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "SQLWarning(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 32422, "Desc": "constructs a sqlwarning object with a given reason , sqlstate and vendorcode . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLWarning(java.lang.String,java.lang.String)", "type": "constructor", "idx": 32426, "Desc": "constructs a sqlwarning object with a given reason and sqlstate . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method . the vendor code is initialized to 0 ."}{"node_name": "SQLWarning(java.lang.String)", "type": "constructor", "idx": 32429, "Desc": "constructs a sqlwarning object with a given reason . the sqlstate is initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLWarning()", "type": "constructor", "idx": 32431, "Desc": "constructs a sqlwarning object . the reason , sqlstate are initialized to null and the vendor code is initialized to 0 . the cause is not initialized , and may subsequently be initialized by a call to the throwable.initcause ( java.lang.throwable ) method ."}{"node_name": "SQLWarning(java.lang.Throwable)", "type": "constructor", "idx": 32432, "Desc": "constructs a sqlwarning object with a given cause . the sqlstate is initialized to null and the vendor code is initialized to 0 . the reason is initialized to null if cause == null or to cause.tostring() if cause ! =null ."}{"node_name": "SQLWarning(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32434, "Desc": "constructs a sqlwarning object with a given reason and cause . the sqlstate is initialized to null and the vendor code is initialized to 0 ."}{"node_name": "SQLWarning(java.lang.String,java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 32437, "Desc": "constructs a sqlwarning object with a given reason , sqlstate and cause . the vendor code is initialized to 0 ."}{"node_name": "SQLWarning(java.lang.String,java.lang.String,int,java.lang.Throwable)", "type": "constructor", "idx": 32441, "Desc": "constructs asqlwarning object with a given reason , sqlstate , vendorcode and cause ."}{"node_name": "Time(long)", "type": "constructor", "idx": 32568, "Desc": "constructs a time object using a milliseconds time value ."}{"node_name": "Timestamp(long)", "type": "constructor", "idx": 32580, "Desc": "constructs a timestamp object using a milliseconds time value . the integral seconds are stored in the underlying date value ; the fractional seconds are stored in the nanos field of the timestamp object ."}{"node_name": "Annotation(java.lang.Object)", "type": "constructor", "idx": 32656, "Desc": "constructs an annotation record with the given value , which may be null ."}{"node_name": "Attribute(java.lang.String)", "type": "constructor", "idx": 32664, "Desc": "constructs an attribute with the given name ."}{"node_name": "AttributedString(java.lang.String)", "type": "constructor", "idx": 32688, "Desc": "constructs an attributedstring instance with the given text ."}{"node_name": "AttributedString(java.lang.String,java.util.Map)", "type": "constructor", "idx": 32690, "Desc": "constructs an attributedstring instance with the given text and attributes ."}{"node_name": "AttributedString(java.text.AttributedCharacterIterator)", "type": "constructor", "idx": 32693, "Desc": "constructs an attributedstring instance with the given attributed text represented by attributedcharacteriterator ."}{"node_name": "AttributedString(java.text.AttributedCharacterIterator,int,int)", "type": "constructor", "idx": 32695, "Desc": "constructs an attributedstring instance with the subrange of the given attributed text represented by attributedcharacteriterator . if the given range produces an empty text , all attributes will be discarded . note that any attributes wrapped by an annotation object are discarded for a subrange of the original attribute range ."}{"node_name": "AttributedString(java.text.AttributedCharacterIterator,int,int,java.text.AttributedCharacterIterator.Attribute[])", "type": "constructor", "idx": 32699, "Desc": "constructs an attributedstring instance with the subrange of the given attributed text represented by attributedcharacteriterator . only attributes that match the given attributes will be incorporated into the instance . if the given range produces an empty text , all attributes will be discarded . note that any attributes wrapped by an annotation object are discarded for a subrange of the original attribute range ."}{"node_name": "Bidi(java.lang.String,int)", "type": "constructor", "idx": 32728, "Desc": "create bidi from the given paragraph of text and base direction ."}{"node_name": "Bidi(java.text.AttributedCharacterIterator)", "type": "constructor", "idx": 32731, "Desc": "create bidi from the given paragraph of text . the run_direction attribute in the text , if present , determines the base direction ( left-to-right or right-to-left ) . if not present , the base direction is computes using the unicode bidirectional algorithm , defaulting to left-to-right if there are no strong directional characters in the text . this attribute , if present , must be applied to all the text in the paragraph . the bidi_embedding attribute in the text , if present , represents embedding level information . negative values from -1 to -62 indicate overrides at the absolute value of the level . positive values from 1 to 62 indicate embeddings . where values are zero or not defined , the base embedding level as determined by the base direction is assumed . the numeric_shaping attribute in the text , if present , converts european digits to other decimal digits before running the bidi algorithm . this attribute , if present , must be applied to all the text in the paragraph ."}{"node_name": "Bidi(char[],int,byte[],int,int,int)", "type": "constructor", "idx": 32733, "Desc": "create bidi from the given text , embedding , and direction information . the embeddings array may be null . if present , the values represent embedding level information . negative values from -1 to -61 indicate overrides at the absolute value of the level . positive values from 1 to 61 indicate embeddings . where values are zero , the base embedding level as determined by the base direction is assumed ."}{"node_name": "BreakIterator()", "type": "constructor", "idx": 32771, "Desc": "constructor . breakiterator is stateless and has no default behavior ."}{"node_name": "ChoiceFormat(java.lang.String)", "type": "constructor", "idx": 32818, "Desc": "constructs with limits and corresponding formats based on the pattern ."}{"node_name": "ChoiceFormat(double[],java.lang.String[])", "type": "constructor", "idx": 32820, "Desc": "constructs with the limits and the corresponding formats ."}{"node_name": "CollationKey(java.lang.String)", "type": "constructor", "idx": 32874, "Desc": "collationkey constructor ."}{"node_name": "Collator()", "type": "constructor", "idx": 32888, "Desc": "default constructor . <init>() is protected so subclasses can get access to it . users typically create a collator sub-class by calling the factory method getinstance ."}{"node_name": "CompactNumberFormat(java.lang.String,java.text.DecimalFormatSymbols,java.lang.String[])", "type": "constructor", "idx": 32915, "Desc": "creates a compactnumberformat using the given decimal pattern , decimal format symbols and compact patterns . to obtain the instance of compactnumberformat with the standard compact patterns for a locale and style , it is recommended to use the factory methods given by numberformat for compact number formatting . for example , numberformat.getcompactnumberinstance ( locale , style ) ."}{"node_name": "Field(java.lang.String,int)", "type": "constructor", "idx": 32982, "Desc": "creates a field ."}{"node_name": "DateFormat()", "type": "constructor", "idx": 33015, "Desc": "create a new date format ."}{"node_name": "DateFormatSymbols()", "type": "constructor", "idx": 33073, "Desc": "construct a dateformatsymbols object by loading format data from resources for the default format locale . <init>() can only construct instances for the locales supported by the java runtime environment , not for those supported by installed dateformatsymbolsprovider implementations . for full locale coverage , use the getinstance method . this is equivalent to calling dateformatsymbols ( locale.getdefault ( locale.category.format )) ."}{"node_name": "DateFormatSymbols(java.util.Locale)", "type": "constructor", "idx": 33074, "Desc": "construct a dateformatsymbols object by loading format data from resources for the given locale . <init>(java.util.Locale) can only construct instances for the locales supported by the java runtime environment , not for those supported by installed dateformatsymbolsprovider implementations . for full locale coverage , use the getinstance method ."}{"node_name": "DecimalFormat()", "type": "constructor", "idx": 33109, "Desc": "creates a decimalformat using the default pattern and symbols for the default format locale . this is a convenient way to obtain a decimalformat when internationalization is not the main concern . to obtain standard formats for a given locale , use the factory methods on numberformat such as getnumberinstance . these factories will return the most appropriate sub-class of numberformat for a given locale ."}{"node_name": "DecimalFormat(java.lang.String)", "type": "constructor", "idx": 33110, "Desc": "creates a decimalformat using the given pattern and the symbols for the default format locale . this is a convenient way to obtain a decimalformat when internationalization is not the main concern . to obtain standard formats for a given locale , use the factory methods on numberformat such as getnumberinstance . these factories will return the most appropriate sub-class of numberformat for a given locale ."}{"node_name": "DecimalFormat(java.lang.String,java.text.DecimalFormatSymbols)", "type": "constructor", "idx": 33112, "Desc": "creates a decimalformat using the given pattern and symbols . use <init>(java.lang.String,java.text.DecimalFormatSymbols) when you need to completely customize the behavior of the format . to obtain standard formats for a given locale , use the factory methods on numberformat such as getinstance or getcurrencyinstance . if you need only minor adjustments to a standard format , you can modify the format returned by a numberformat factory method ."}{"node_name": "DecimalFormatSymbols()", "type": "constructor", "idx": 33188, "Desc": "create a decimalformatsymbols object for the default format locale . <init>() can only construct instances for the locales supported by the java runtime environment , not for those supported by installed decimalformatsymbolsprovider implementations . for full locale coverage , use the getinstance method . this is equivalent to calling decimalformatsymbols ( locale.getdefault ( locale.category.format )) ."}{"node_name": "DecimalFormatSymbols(java.util.Locale)", "type": "constructor", "idx": 33189, "Desc": "create a decimalformatsymbols object for the given locale . <init>(java.util.Locale) can only construct instances for the locales supported by the java runtime environment , not for those supported by installed decimalformatsymbolsprovider implementations . for full locale coverage , use the getinstance method . if the specified locale contains the locale.unicode_locale_extension for the numbering system , the instance is initialized with the specified numbering system if the jre implementation supports it . for example , numberformat.getnumberinstance ( locale.forlanguagetag ( \" th-th-u-nu-thai \")) this may return a numberformat instance with the thai numbering system , instead of the latin numbering system ."}{"node_name": "FieldPosition(int)", "type": "constructor", "idx": 33245, "Desc": "creates a fieldposition object for the given field . fields are identified by constants , whose names typically end with _field , in the various subclasses of format ."}{"node_name": "FieldPosition(java.text.Format.Field)", "type": "constructor", "idx": 33247, "Desc": "creates a fieldposition object for the given field constant . fields are identified by constants defined in the various format subclasses . this is equivalent to calling new fieldposition ( attribute , -1 ) ."}{"node_name": "FieldPosition(java.text.Format.Field,int)", "type": "constructor", "idx": 33249, "Desc": "creates a fieldposition object for the given field . the field is identified by an attribute constant from one of the field subclasses as well as an integer field id defined by the format subclasses . format subclasses that are aware of field should give precedence to attribute and ignore fieldid if attribute is not null . however , older format subclasses may not be aware of field and rely on fieldid . if the field has no corresponding integer constant , fieldid should be -1 ."}{"node_name": "Field(java.lang.String)", "type": "constructor", "idx": 33265, "Desc": "creates a field with the specified name ."}{"node_name": "Format()", "type": "constructor", "idx": 33268, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "Field(java.lang.String)", "type": "constructor", "idx": 33285, "Desc": "creates a field with the specified name ."}{"node_name": "MessageFormat(java.lang.String)", "type": "constructor", "idx": 33289, "Desc": "constructs a messageformat for the default format locale and the specified pattern . <init>(java.lang.String) first sets the locale , then parses the pattern and creates a list of subformats for the format elements contained in it . patterns and their interpretation are specified in the class description ."}{"node_name": "MessageFormat(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 33291, "Desc": "constructs a messageformat for the specified locale and pattern . <init>(java.lang.String,java.util.Locale) first sets the locale , then parses the pattern and creates a list of subformats for the format elements contained in it . patterns and their interpretation are specified in the class description ."}{"node_name": "Field(java.lang.String)", "type": "constructor", "idx": 33362, "Desc": "creates a field instance with the specified name ."}{"node_name": "NumberFormat()", "type": "constructor", "idx": 33368, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "ParseException(java.lang.String,int)", "type": "constructor", "idx": 33446, "Desc": "constructs a parseexception with the specified detail message and offset . a detail message is a string that describes this particular exception ."}{"node_name": "ParsePosition(int)", "type": "constructor", "idx": 33451, "Desc": "create a new parseposition with the given initial index ."}{"node_name": "RuleBasedCollator(java.lang.String)", "type": "constructor", "idx": 33464, "Desc": "rulebasedcollator constructor . this takes the table rules and builds a collation table out of them . please see rulebasedcollator class description for more details on the collation rule syntax ."}{"node_name": "SimpleDateFormat()", "type": "constructor", "idx": 33481, "Desc": "constructs a simpledateformat using the default pattern and date format symbols for the default format locale . note : <init>() may not support all locales . for full coverage , use the factory methods in the dateformat class ."}{"node_name": "SimpleDateFormat(java.lang.String)", "type": "constructor", "idx": 33482, "Desc": "constructs a simpledateformat using the given pattern and the default date format symbols for the default format locale . note : <init>(java.lang.String) may not support all locales . for full coverage , use the factory methods in the dateformat class . this is equivalent to calling simpledateformat ( pattern , locale.getdefault ( locale.category.format )) ."}{"node_name": "SimpleDateFormat(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 33484, "Desc": "constructs a simpledateformat using the given pattern and the default date format symbols for the given locale . note : <init>(java.lang.String,java.util.Locale) may not support all locales . for full coverage , use the factory methods in the dateformat class ."}{"node_name": "SimpleDateFormat(java.lang.String,java.text.DateFormatSymbols)", "type": "constructor", "idx": 33487, "Desc": "constructs a simpledateformat using the given pattern and date format symbols ."}{"node_name": "BreakIteratorProvider()", "type": "constructor", "idx": 33516, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "CollatorProvider()", "type": "constructor", "idx": 33526, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "DateFormatProvider()", "type": "constructor", "idx": 33530, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "DateFormatSymbolsProvider()", "type": "constructor", "idx": 33542, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "DecimalFormatSymbolsProvider()", "type": "constructor", "idx": 33546, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "NumberFormatProvider()", "type": "constructor", "idx": 33550, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "StringCharacterIterator(java.lang.String)", "type": "constructor", "idx": 33563, "Desc": "constructs an iterator with an initial index of 0 ."}{"node_name": "StringCharacterIterator(java.lang.String,int)", "type": "constructor", "idx": 33565, "Desc": "constructs an iterator with the specified initial index ."}{"node_name": "StringCharacterIterator(java.lang.String,int,int,int)", "type": "constructor", "idx": 33568, "Desc": "constructs an iterator over the given range of the given string , with the index set at the specified position ."}{"node_name": "AbstractChronology()", "type": "constructor", "idx": 33590, "Desc": "creates an instance ."}{"node_name": "Clock()", "type": "constructor", "idx": 34334, "Desc": "constructor accessible by subclasses ."}{"node_name": "DateTimeException(java.lang.String)", "type": "constructor", "idx": 34363, "Desc": "constructs a new date-time exception with the specified message ."}{"node_name": "DateTimeException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 34365, "Desc": "constructs a new date-time exception with the specified message and cause ."}{"node_name": "DateTimeFormatterBuilder()", "type": "constructor", "idx": 34578, "Desc": "constructs a new instance of the builder ."}{"node_name": "DateTimeParseException(java.lang.String,java.lang.CharSequence,int)", "type": "constructor", "idx": 34673, "Desc": "constructs a new exception with the specified message ."}{"node_name": "DateTimeParseException(java.lang.String,java.lang.CharSequence,int,java.lang.Throwable)", "type": "constructor", "idx": 34677, "Desc": "constructs a new exception with the specified message and cause ."}{"node_name": "UnsupportedTemporalTypeException(java.lang.String)", "type": "constructor", "idx": 35817, "Desc": "constructs a new unsupportedtemporaltypeexception with the specified message ."}{"node_name": "UnsupportedTemporalTypeException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 35819, "Desc": "constructs a new unsupportedtemporaltypeexception with the specified message and cause ."}{"node_name": "ZoneRulesException(java.lang.String)", "type": "constructor", "idx": 36135, "Desc": "constructs a new date-time exception with the specified message ."}{"node_name": "ZoneRulesException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 36137, "Desc": "constructs a new date-time exception with the specified message and cause ."}{"node_name": "ZoneRulesProvider()", "type": "constructor", "idx": 36141, "Desc": "constructor ."}{"node_name": "AbstractCollection()", "type": "constructor", "idx": 36376, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "AbstractList()", "type": "constructor", "idx": 36400, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "AbstractMap()", "type": "constructor", "idx": 36435, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "SimpleEntry(java.lang.Object,java.lang.Object)", "type": "constructor", "idx": 36460, "Desc": "creates an entry representing a mapping from the specified key to the specified value ."}{"node_name": "SimpleEntry(java.util.Map.Entry)", "type": "constructor", "idx": 36463, "Desc": "creates an entry representing the same mapping as the specified entry ."}{"node_name": "SimpleImmutableEntry(java.lang.Object,java.lang.Object)", "type": "constructor", "idx": 36474, "Desc": "creates an entry representing a mapping from the specified key to the specified value ."}{"node_name": "SimpleImmutableEntry(java.util.Map.Entry)", "type": "constructor", "idx": 36477, "Desc": "creates an entry representing the same mapping as the specified entry ."}{"node_name": "AbstractQueue()", "type": "constructor", "idx": 36488, "Desc": "constructor for use by subclasses ."}{"node_name": "AbstractSequentialList()", "type": "constructor", "idx": 36497, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "AbstractSet()", "type": "constructor", "idx": 36515, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "ArrayDeque()", "type": "constructor", "idx": 36522, "Desc": "constructs an empty array deque with an initial capacity sufficient to hold 16 elements ."}{"node_name": "ArrayDeque(int)", "type": "constructor", "idx": 36523, "Desc": "constructs an empty array deque with an initial capacity sufficient to hold the specified number of elements ."}{"node_name": "ArrayDeque(java.util.Collection)", "type": "constructor", "idx": 36525, "Desc": "constructs a deque containing the elements of the specified collection , in the order they are returned by the collection's iterator . ( the first element returned by the collection's iterator becomes the first element , or front of the deque . )"}{"node_name": "ArrayList(int)", "type": "constructor", "idx": 36578, "Desc": "constructs an empty list with the specified initial capacity ."}{"node_name": "ArrayList()", "type": "constructor", "idx": 36580, "Desc": "constructs an empty list with an initial capacity of ten ."}{"node_name": "ArrayList(java.util.Collection)", "type": "constructor", "idx": 36581, "Desc": "constructs a list containing the elements of the specified collection , in the order they are returned by the collection's iterator ."}{"node_name": "BitSet()", "type": "constructor", "idx": 37499, "Desc": "creates a new bit set . all bits are initially false ."}{"node_name": "BitSet(int)", "type": "constructor", "idx": 37500, "Desc": "creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range 0 through nbits-1 . all bits are initially false ."}{"node_name": "Builder()", "type": "constructor", "idx": 37569, "Desc": "constructs a calendar.builder ."}{"node_name": "Calendar()", "type": "constructor", "idx": 37664, "Desc": "constructs a calendar with the default time zone and the default format locale ."}{"node_name": "Calendar(java.util.TimeZone,java.util.Locale)", "type": "constructor", "idx": 37665, "Desc": "constructs a calendar with the specified time zone and locale ."}{"node_name": "AbstractExecutorService()", "type": "constructor", "idx": 38005, "Desc": ""}{"node_name": "ArrayBlockingQueue(int)", "type": "constructor", "idx": 38019, "Desc": "creates an arrayblockingqueue with the given ( fixed ) capacity and default access policy ."}{"node_name": "ArrayBlockingQueue(int,boolean)", "type": "constructor", "idx": 38021, "Desc": "creates an arrayblockingqueue with the given ( fixed ) capacity and the specified access policy ."}{"node_name": "ArrayBlockingQueue(int,boolean,java.util.Collection)", "type": "constructor", "idx": 38024, "Desc": "creates an arrayblockingqueue with the given ( fixed ) capacity , the specified access policy and initially containing the elements of the given collection , added in traversal order of the collection's iterator ."}{"node_name": "AtomicBoolean(boolean)", "type": "constructor", "idx": 38064, "Desc": "creates a new atomicboolean with the given initial value ."}{"node_name": "AtomicBoolean()", "type": "constructor", "idx": 38066, "Desc": "creates a new atomicboolean with initial value false ."}{"node_name": "AtomicInteger(int)", "type": "constructor", "idx": 38109, "Desc": "creates a new atomicinteger with the given initial value ."}{"node_name": "AtomicInteger()", "type": "constructor", "idx": 38111, "Desc": "creates a new atomicinteger with initial value 0 ."}{"node_name": "AtomicIntegerArray(int)", "type": "constructor", "idx": 38176, "Desc": "creates a new atomicintegerarray of the given length , with all elements initially zero ."}{"node_name": "AtomicIntegerArray(int[])", "type": "constructor", "idx": 38178, "Desc": "creates a new atomicintegerarray with the same length as , and all elements copied from , the given array ."}{"node_name": "AtomicIntegerFieldUpdater()", "type": "constructor", "idx": 38269, "Desc": "protected do-nothing constructor for use by subclasses ."}{"node_name": "AtomicLong(long)", "type": "constructor", "idx": 38321, "Desc": "creates a new atomiclong with the given initial value ."}{"node_name": "AtomicLong()", "type": "constructor", "idx": 38323, "Desc": "creates a new atomiclong with initial value 0 ."}{"node_name": "AtomicLongArray(int)", "type": "constructor", "idx": 38388, "Desc": "creates a new atomiclongarray of the given length , with all elements initially zero ."}{"node_name": "AtomicLongArray(long[])", "type": "constructor", "idx": 38390, "Desc": "creates a new atomiclongarray with the same length as , and all elements copied from , the given array ."}{"node_name": "AtomicLongFieldUpdater()", "type": "constructor", "idx": 38481, "Desc": "protected do-nothing constructor for use by subclasses ."}{"node_name": "AtomicMarkableReference(java.lang.Object,boolean)", "type": "constructor", "idx": 38533, "Desc": "creates a new atomicmarkablereference with the given initial values ."}{"node_name": "AtomicReference(java.lang.Object)", "type": "constructor", "idx": 38557, "Desc": "creates a new atomicreference with the given initial value ."}{"node_name": "AtomicReference()", "type": "constructor", "idx": 38559, "Desc": "creates a new atomicreference with null initial value ."}{"node_name": "AtomicReferenceArray(int)", "type": "constructor", "idx": 38612, "Desc": "creates a new atomicreferencearray of the given length , with all elements initially null ."}{"node_name": "AtomicReferenceArray(java.lang.Object[])", "type": "constructor", "idx": 38614, "Desc": "creates a new atomicreferencearray with the same length as , and all elements copied from , the given array ."}{"node_name": "AtomicReferenceFieldUpdater()", "type": "constructor", "idx": 38691, "Desc": "protected do-nothing constructor for use by subclasses ."}{"node_name": "AtomicStampedReference(java.lang.Object,int)", "type": "constructor", "idx": 38730, "Desc": "creates a new atomicstampedreference with the given initial values ."}{"node_name": "DoubleAccumulator(java.util.function.DoubleBinaryOperator,double)", "type": "constructor", "idx": 38754, "Desc": "creates a new instance using the given accumulator function and identity element ."}{"node_name": "DoubleAdder()", "type": "constructor", "idx": 38768, "Desc": "creates a new adder with initial sum of zero ."}{"node_name": "LongAccumulator(java.util.function.LongBinaryOperator,long)", "type": "constructor", "idx": 38780, "Desc": "creates a new instance using the given accumulator function and identity element ."}{"node_name": "LongAdder()", "type": "constructor", "idx": 38794, "Desc": "creates a new adder with initial sum of zero ."}{"node_name": "BrokenBarrierException()", "type": "constructor", "idx": 38892, "Desc": "constructs a brokenbarrierexception with no specified detail message ."}{"node_name": "BrokenBarrierException(java.lang.String)", "type": "constructor", "idx": 38893, "Desc": "constructs a brokenbarrierexception with the specified detail message ."}{"node_name": "CancellationException()", "type": "constructor", "idx": 38898, "Desc": "constructs a cancellationexception with no detail message ."}{"node_name": "CancellationException(java.lang.String)", "type": "constructor", "idx": 38899, "Desc": "constructs a cancellationexception with the specified detail message ."}{"node_name": "CompletableFuture()", "type": "constructor", "idx": 38903, "Desc": "creates a new incomplete completablefuture ."}{"node_name": "CompletionException()", "type": "constructor", "idx": 39027, "Desc": "constructs a completionexception with no detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ."}{"node_name": "CompletionException(java.lang.String)", "type": "constructor", "idx": 39028, "Desc": "constructs a completionexception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ."}{"node_name": "CompletionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 39030, "Desc": "constructs a completionexception with the specified detail message and cause ."}{"node_name": "CompletionException(java.lang.Throwable)", "type": "constructor", "idx": 39033, "Desc": "constructs a completionexception with the specified cause . the detail message is set to ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "ConcurrentHashMap()", "type": "constructor", "idx": 39165, "Desc": "creates a new , empty map with the default initial table size ( 16 ) ."}{"node_name": "ConcurrentHashMap(int)", "type": "constructor", "idx": 39166, "Desc": "creates a new , empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize ."}{"node_name": "ConcurrentHashMap(java.util.Map)", "type": "constructor", "idx": 39168, "Desc": "creates a new map with the same mappings as the given map ."}{"node_name": "ConcurrentHashMap(int,float)", "type": "constructor", "idx": 39170, "Desc": "creates a new , empty map with an initial table size based on the given number of elements ( initialcapacity ) and initial table density ( loadfactor ) ."}{"node_name": "ConcurrentHashMap(int,float,int)", "type": "constructor", "idx": 39173, "Desc": "creates a new , empty map with an initial table size based on the given number of elements ( initialcapacity ) , initial table density ( loadfactor ) , and number of concurrently updating threads ( concurrencylevel ) ."}{"node_name": "ConcurrentLinkedDeque()", "type": "constructor", "idx": 39388, "Desc": "constructs an empty deque ."}{"node_name": "ConcurrentLinkedDeque(java.util.Collection)", "type": "constructor", "idx": 39389, "Desc": "constructs a deque initially containing the elements of the given collection , added in traversal order of the collection's iterator ."}{"node_name": "ConcurrentLinkedQueue()", "type": "constructor", "idx": 39440, "Desc": "creates a concurrentlinkedqueue that is initially empty ."}{"node_name": "ConcurrentLinkedQueue(java.util.Collection)", "type": "constructor", "idx": 39441, "Desc": "creates a concurrentlinkedqueue initially containing the elements of the given collection , added in traversal order of the collection's iterator ."}{"node_name": "ConcurrentSkipListMap()", "type": "constructor", "idx": 39526, "Desc": "constructs a new , empty map , sorted according to the natural ordering of the keys ."}{"node_name": "ConcurrentSkipListMap(java.util.Comparator)", "type": "constructor", "idx": 39527, "Desc": "constructs a new , empty map , sorted according to the specified comparator ."}{"node_name": "ConcurrentSkipListMap(java.util.Map)", "type": "constructor", "idx": 39529, "Desc": "constructs a new map containing the same mappings as the given map , sorted according to the natural ordering of the keys ."}{"node_name": "ConcurrentSkipListMap(java.util.SortedMap)", "type": "constructor", "idx": 39531, "Desc": "constructs a new map containing the same mappings and using the same ordering as the specified sorted map ."}{"node_name": "ConcurrentSkipListSet()", "type": "constructor", "idx": 39621, "Desc": "constructs a new , empty set that orders its elements according to their natural ordering ."}{"node_name": "ConcurrentSkipListSet(java.util.Comparator)", "type": "constructor", "idx": 39622, "Desc": "constructs a new , empty set that orders its elements according to the specified comparator ."}{"node_name": "ConcurrentSkipListSet(java.util.Collection)", "type": "constructor", "idx": 39624, "Desc": "constructs a new set containing the elements in the specified collection , that orders its elements according to their natural ordering ."}{"node_name": "ConcurrentSkipListSet(java.util.SortedSet)", "type": "constructor", "idx": 39626, "Desc": "constructs a new set containing the same elements and using the same ordering as the specified sorted set ."}{"node_name": "CopyOnWriteArrayList()", "type": "constructor", "idx": 39675, "Desc": "creates an empty list ."}{"node_name": "CopyOnWriteArrayList(java.util.Collection)", "type": "constructor", "idx": 39676, "Desc": "creates a list containing the elements of the specified collection , in the order they are returned by the collection's iterator ."}{"node_name": "CopyOnWriteArrayList(java.lang.Object[])", "type": "constructor", "idx": 39678, "Desc": "creates a list holding a copy of the given array ."}{"node_name": "CopyOnWriteArraySet()", "type": "constructor", "idx": 39741, "Desc": "creates an empty set ."}{"node_name": "CopyOnWriteArraySet(java.util.Collection)", "type": "constructor", "idx": 39742, "Desc": "creates a set containing all of the elements of the specified collection ."}{"node_name": "CountDownLatch(int)", "type": "constructor", "idx": 39773, "Desc": "constructs a countdownlatch initialized with the given count ."}{"node_name": "CountedCompleter(java.util.concurrent.CountedCompleter,int)", "type": "constructor", "idx": 39783, "Desc": "creates a new countedcompleter with the given completer and initial pending count ."}{"node_name": "CountedCompleter(java.util.concurrent.CountedCompleter)", "type": "constructor", "idx": 39786, "Desc": "creates a new countedcompleter with the given completer and an initial pending count of zero ."}{"node_name": "CountedCompleter()", "type": "constructor", "idx": 39788, "Desc": "creates a new countedcompleter with no completer and an initial pending count of zero ."}{"node_name": "CyclicBarrier(int,java.lang.Runnable)", "type": "constructor", "idx": 39820, "Desc": "creates a new cyclicbarrier that will trip when the given number of parties ( threads ) are waiting upon it , and which will execute the given barrier action when the barrier is tripped , performed by the last thread entering the barrier ."}{"node_name": "CyclicBarrier(int)", "type": "constructor", "idx": 39823, "Desc": "creates a new cyclicbarrier that will trip when the given number of parties ( threads ) are waiting upon it , and does not perform a predefined action when the barrier is tripped ."}{"node_name": "DelayQueue()", "type": "constructor", "idx": 39837, "Desc": "creates a new delayqueue that is initially empty ."}{"node_name": "DelayQueue(java.util.Collection)", "type": "constructor", "idx": 39838, "Desc": "creates a delayqueue initially containing the elements of the given collection of delayed instances ."}{"node_name": "Exchanger()", "type": "constructor", "idx": 39870, "Desc": "creates a new exchanger ."}{"node_name": "ExecutionException()", "type": "constructor", "idx": 39878, "Desc": "constructs an executionexception with no detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ."}{"node_name": "ExecutionException(java.lang.String)", "type": "constructor", "idx": 39879, "Desc": "constructs an executionexception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ."}{"node_name": "ExecutionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 39881, "Desc": "constructs an executionexception with the specified detail message and cause ."}{"node_name": "ExecutionException(java.lang.Throwable)", "type": "constructor", "idx": 39884, "Desc": "constructs an executionexception with the specified cause . the detail message is set to ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "ExecutorCompletionService(java.util.concurrent.Executor)", "type": "constructor", "idx": 39890, "Desc": "creates an executorcompletionservice using the supplied executor for base task execution and a linkedblockingqueue as a completion queue ."}{"node_name": "ExecutorCompletionService(java.util.concurrent.Executor,java.util.concurrent.BlockingQueue)", "type": "constructor", "idx": 39892, "Desc": "creates an executorcompletionservice using the supplied executor for base task execution and the supplied queue as its completion queue ."}{"node_name": "ForkJoinPool()", "type": "constructor", "idx": 39992, "Desc": "creates a forkjoinpool with parallelism equal to runtime.availableprocessors() , using defaults for all other parameters ( see forkjoinpool ( int , forkjoinworkerthreadfactory , uncaughtexceptionhandler , boolean , int , int , int , predicate , long , timeunit )) ."}{"node_name": "ForkJoinPool(int)", "type": "constructor", "idx": 39993, "Desc": "creates a forkjoinpool with the indicated parallelism level , using defaults for all other parameters ( see forkjoinpool ( int , forkjoinworkerthreadfactory , uncaughtexceptionhandler , boolean , int , int , int , predicate , long , timeunit )) ."}{"node_name": "ForkJoinPool(int,java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory,java.lang.Thread.UncaughtExceptionHandler,boolean)", "type": "constructor", "idx": 39995, "Desc": "creates a forkjoinpool with the given parameters ( using defaults for others -- see forkjoinpool ( int , forkjoinworkerthreadfactory , uncaughtexceptionhandler , boolean , int , int , int , predicate , long , timeunit )) ."}{"node_name": "ForkJoinPool(int,java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory,java.lang.Thread.UncaughtExceptionHandler,boolean,int,int,int,java.util.function.Predicate,long,java.util.concurrent.TimeUnit)", "type": "constructor", "idx": 40000, "Desc": "creates a forkjoinpool with the given parameters ."}{"node_name": "ForkJoinTask()", "type": "constructor", "idx": 40063, "Desc": ""}{"node_name": "ForkJoinWorkerThread(java.util.concurrent.ForkJoinPool)", "type": "constructor", "idx": 40119, "Desc": "creates a forkjoinworkerthread operating in the given pool ."}{"node_name": "FutureTask(java.util.concurrent.Callable)", "type": "constructor", "idx": 40137, "Desc": "creates a futuretask that will , upon running , execute the given callable ."}{"node_name": "FutureTask(java.lang.Runnable,java.lang.Object)", "type": "constructor", "idx": 40139, "Desc": "creates a futuretask that will , upon running , execute the given runnable , and arrange that get will return the given result on successful completion ."}{"node_name": "LinkedBlockingDeque()", "type": "constructor", "idx": 40154, "Desc": "creates a linkedblockingdeque with a capacity of integer.max_value ."}{"node_name": "LinkedBlockingDeque(int)", "type": "constructor", "idx": 40155, "Desc": "creates a linkedblockingdeque with the given ( fixed ) capacity ."}{"node_name": "LinkedBlockingDeque(java.util.Collection)", "type": "constructor", "idx": 40157, "Desc": "creates a linkedblockingdeque with a capacity of integer.max_value , initially containing the elements of the given collection , added in traversal order of the collection's iterator ."}{"node_name": "LinkedBlockingQueue()", "type": "constructor", "idx": 40227, "Desc": "creates a linkedblockingqueue with a capacity of integer.max_value ."}{"node_name": "LinkedBlockingQueue(int)", "type": "constructor", "idx": 40228, "Desc": "creates a linkedblockingqueue with the given ( fixed ) capacity ."}{"node_name": "LinkedBlockingQueue(java.util.Collection)", "type": "constructor", "idx": 40230, "Desc": "creates a linkedblockingqueue with a capacity of integer.max_value , initially containing the elements of the given collection , added in traversal order of the collection's iterator ."}{"node_name": "LinkedTransferQueue()", "type": "constructor", "idx": 40266, "Desc": "creates an initially empty linkedtransferqueue ."}{"node_name": "LinkedTransferQueue(java.util.Collection)", "type": "constructor", "idx": 40267, "Desc": "creates a linkedtransferqueue initially containing the elements of the given collection , added in traversal order of the collection's iterator ."}{"node_name": "AbstractOwnableSynchronizer()", "type": "constructor", "idx": 40313, "Desc": "empty constructor for use by subclasses ."}{"node_name": "ConditionObject()", "type": "constructor", "idx": 40318, "Desc": "creates a new conditionobject instance ."}{"node_name": "AbstractQueuedLongSynchronizer()", "type": "constructor", "idx": 40334, "Desc": "creates a new abstractqueuedlongsynchronizer instance with initial synchronization state of zero ."}{"node_name": "ConditionObject()", "type": "constructor", "idx": 40388, "Desc": "creates a new conditionobject instance ."}{"node_name": "AbstractQueuedSynchronizer()", "type": "constructor", "idx": 40404, "Desc": "creates a new abstractqueuedsynchronizer instance with initial synchronization state of zero ."}{"node_name": "ReentrantLock()", "type": "constructor", "idx": 40500, "Desc": "creates an instance of reentrantlock . this is equivalent to using reentrantlock ( false ) ."}{"node_name": "ReentrantLock(boolean)", "type": "constructor", "idx": 40501, "Desc": "creates an instance of reentrantlock with the given fairness policy ."}{"node_name": "ReentrantReadWriteLock()", "type": "constructor", "idx": 40529, "Desc": "creates a new reentrantreadwritelock with default ( nonfair ) ordering properties ."}{"node_name": "ReentrantReadWriteLock(boolean)", "type": "constructor", "idx": 40530, "Desc": "creates a new reentrantreadwritelock with the given fairness policy ."}{"node_name": "ReadLock(java.util.concurrent.locks.ReentrantReadWriteLock)", "type": "constructor", "idx": 40556, "Desc": "constructor for use by subclasses ."}{"node_name": "WriteLock(java.util.concurrent.locks.ReentrantReadWriteLock)", "type": "constructor", "idx": 40568, "Desc": "constructor for use by subclasses ."}{"node_name": "StampedLock()", "type": "constructor", "idx": 40582, "Desc": "creates a new lock , initially in unlocked state ."}{"node_name": "Phaser()", "type": "constructor", "idx": 40628, "Desc": "creates a new phaser with no initially registered parties , no parent , and initial phase number 0 . any thread using this phaser will need to first register for it ."}{"node_name": "Phaser(int)", "type": "constructor", "idx": 40629, "Desc": "creates a new phaser with the given number of registered unarrived parties , no parent , and initial phase number 0 ."}{"node_name": "Phaser(java.util.concurrent.Phaser)", "type": "constructor", "idx": 40631, "Desc": "equivalent to phaser ( parent , 0 ) ."}{"node_name": "Phaser(java.util.concurrent.Phaser,int)", "type": "constructor", "idx": 40633, "Desc": "creates a new phaser with the given parent and number of registered unarrived parties . when the given parent is non-null and the given number of parties is greater than zero , this child phaser is registered with its parent ."}{"node_name": "PriorityBlockingQueue()", "type": "constructor", "idx": 40663, "Desc": "creates a priorityblockingqueue with the default initial capacity ( 11 ) that orders its elements according to their natural ordering ."}{"node_name": "PriorityBlockingQueue(int)", "type": "constructor", "idx": 40664, "Desc": "creates a priorityblockingqueue with the specified initial capacity that orders its elements according to their natural ordering ."}{"node_name": "PriorityBlockingQueue(int,java.util.Comparator)", "type": "constructor", "idx": 40666, "Desc": "creates a priorityblockingqueue with the specified initial capacity that orders its elements according to the specified comparator ."}{"node_name": "PriorityBlockingQueue(java.util.Collection)", "type": "constructor", "idx": 40669, "Desc": "creates a priorityblockingqueue containing the elements in the specified collection . if the specified collection is a sortedset or a priorityqueue , this priority queue will be ordered according to the same ordering . otherwise , this priority queue will be ordered according to the natural ordering of its elements ."}{"node_name": "RecursiveAction()", "type": "constructor", "idx": 40707, "Desc": ""}{"node_name": "RecursiveTask()", "type": "constructor", "idx": 40714, "Desc": ""}{"node_name": "RejectedExecutionException()", "type": "constructor", "idx": 40718, "Desc": "constructs a rejectedexecutionexception with no detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ."}{"node_name": "RejectedExecutionException(java.lang.String)", "type": "constructor", "idx": 40719, "Desc": "constructs a rejectedexecutionexception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to initcause ."}{"node_name": "RejectedExecutionException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 40721, "Desc": "constructs a rejectedexecutionexception with the specified detail message and cause ."}{"node_name": "RejectedExecutionException(java.lang.Throwable)", "type": "constructor", "idx": 40724, "Desc": "constructs a rejectedexecutionexception with the specified cause . the detail message is set to ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "ScheduledThreadPoolExecutor(int)", "type": "constructor", "idx": 40755, "Desc": "creates a new scheduledthreadpoolexecutor with the given core pool size ."}{"node_name": "ScheduledThreadPoolExecutor(int,java.util.concurrent.ThreadFactory)", "type": "constructor", "idx": 40757, "Desc": "creates a new scheduledthreadpoolexecutor with the given initial parameters ."}{"node_name": "ScheduledThreadPoolExecutor(int,java.util.concurrent.RejectedExecutionHandler)", "type": "constructor", "idx": 40760, "Desc": "creates a new scheduledthreadpoolexecutor with the given initial parameters ."}{"node_name": "ScheduledThreadPoolExecutor(int,java.util.concurrent.ThreadFactory,java.util.concurrent.RejectedExecutionHandler)", "type": "constructor", "idx": 40763, "Desc": "creates a new scheduledthreadpoolexecutor with the given initial parameters ."}{"node_name": "Semaphore(int)", "type": "constructor", "idx": 40813, "Desc": "creates a semaphore with the given number of permits and nonfair fairness setting ."}{"node_name": "Semaphore(int,boolean)", "type": "constructor", "idx": 40815, "Desc": "creates a semaphore with the given number of permits and the given fairness setting ."}{"node_name": "SubmissionPublisher(java.util.concurrent.Executor,int,java.util.function.BiConsumer)", "type": "constructor", "idx": 40847, "Desc": "creates a new submissionpublisher using the given executor for async delivery to subscribers , with the given maximum buffer size for each subscriber , and , if non-null , the given handler invoked when any subscriber throws an exception in method onnext ."}{"node_name": "SubmissionPublisher(java.util.concurrent.Executor,int)", "type": "constructor", "idx": 40851, "Desc": "creates a new submissionpublisher using the given executor for async delivery to subscribers , with the given maximum buffer size for each subscriber , and no handler for subscriber exceptions in method onnext ."}{"node_name": "SubmissionPublisher()", "type": "constructor", "idx": 40854, "Desc": "creates a new submissionpublisher using the forkjoinpool.commonpool() for async delivery to subscribers ( unless it does not support a parallelism level of at least two , in which case , a new thread is created to run each task ) , with maximum buffer capacity of flow.defaultbuffersize() , and no handler for subscriber exceptions in method onnext ."}{"node_name": "SynchronousQueue()", "type": "constructor", "idx": 40884, "Desc": "creates a synchronousqueue with nonfair access policy ."}{"node_name": "SynchronousQueue(boolean)", "type": "constructor", "idx": 40885, "Desc": "creates a synchronousqueue with the specified fairness policy ."}{"node_name": "AbortPolicy()", "type": "constructor", "idx": 40986, "Desc": "creates an abortpolicy ."}{"node_name": "CallerRunsPolicy()", "type": "constructor", "idx": 40991, "Desc": "creates a callerrunspolicy ."}{"node_name": "DiscardOldestPolicy()", "type": "constructor", "idx": 40996, "Desc": "creates a discardoldestpolicy for the given executor ."}{"node_name": "DiscardPolicy()", "type": "constructor", "idx": 41001, "Desc": "creates a discardpolicy ."}{"node_name": "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue)", "type": "constructor", "idx": 41006, "Desc": "creates a new threadpoolexecutor with the given initial parameters , the default thread factory and the default rejected execution handler . it may be more convenient to use one of the executors factory methods instead of this general purpose constructor ."}{"node_name": "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory)", "type": "constructor", "idx": 41012, "Desc": "creates a new threadpoolexecutor with the given initial parameters and default rejected execution handler ."}{"node_name": "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.RejectedExecutionHandler)", "type": "constructor", "idx": 41019, "Desc": "creates a new threadpoolexecutor with the given initial parameters and default thread factory ."}{"node_name": "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue,java.util.concurrent.ThreadFactory,java.util.concurrent.RejectedExecutionHandler)", "type": "constructor", "idx": 41026, "Desc": "creates a new threadpoolexecutor with the given initial parameters ."}{"node_name": "TimeoutException()", "type": "constructor", "idx": 41079, "Desc": "constructs a timeoutexception with no specified detail message ."}{"node_name": "TimeoutException(java.lang.String)", "type": "constructor", "idx": 41080, "Desc": "constructs a timeoutexception with the specified detail message ."}{"node_name": "ConcurrentModificationException()", "type": "constructor", "idx": 41128, "Desc": "constructs a concurrentmodificationexception with no detail message ."}{"node_name": "ConcurrentModificationException(java.lang.String)", "type": "constructor", "idx": 41129, "Desc": "constructs a concurrentmodificationexception with the specified detail message ."}{"node_name": "ConcurrentModificationException(java.lang.Throwable)", "type": "constructor", "idx": 41131, "Desc": "constructs a new exception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ."}{"node_name": "ConcurrentModificationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 41133, "Desc": "constructs a new exception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "Date()", "type": "constructor", "idx": 41154, "Desc": "allocates a date object and initializes it so that it represents the time at which it was allocated , measured to the nearest millisecond ."}{"node_name": "Date(long)", "type": "constructor", "idx": 41155, "Desc": "allocates a date object and initializes it to represent the specified number of milliseconds since the standard base time known as \" the epoch \" , namely january 1 , 1970 , 00:00 : 00 gmt ."}{"node_name": "Dictionary()", "type": "constructor", "idx": 41216, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "DoubleSummaryStatistics()", "type": "constructor", "idx": 41229, "Desc": "constructs an empty instance with zero count , zero sum , double.positive_infinity min , double.negative_infinity max and zero average ."}{"node_name": "DoubleSummaryStatistics(long,double,double,double)", "type": "constructor", "idx": 41230, "Desc": "constructs a non-empty instance with the specified count , min , max , and sum . if count is zero then the remaining arguments are ignored and an empty instance is constructed . if the arguments are inconsistent then an illegalargumentexception is thrown . the necessary consistent argument conditions are : count > = 0 ( min <= max && ! isnan ( sum )) || ( isnan ( min ) && isnan ( max ) && isnan ( sum ))"}{"node_name": "DuplicateFormatFlagsException(java.lang.String)", "type": "constructor", "idx": 41246, "Desc": "constructs an instance of this class with the specified flags ."}{"node_name": "EmptyStackException()", "type": "constructor", "idx": 41250, "Desc": "constructs a new emptystackexception with null as its error message string ."}{"node_name": "EnumMap(java.lang.Class)", "type": "constructor", "idx": 41256, "Desc": "creates an empty enum map with the specified key type ."}{"node_name": "EnumMap(java.util.EnumMap)", "type": "constructor", "idx": 41258, "Desc": "creates an enum map with the same key type as the specified enum map , initially containing the same mappings ( if any ) ."}{"node_name": "EnumMap(java.util.Map)", "type": "constructor", "idx": 41260, "Desc": "creates an enum map initialized from the specified map . if the specified map is an enummap instance , <init>(java.util.Map) behaves identically to enummap ( enummap ) . otherwise , the specified map must contain at least one mapping ( in order to determine the new enum map's key type ) ."}{"node_name": "EventListenerProxy(java.util.EventListener)", "type": "constructor", "idx": 41324, "Desc": "creates a proxy for the specified listener ."}{"node_name": "EventObject(java.lang.Object)", "type": "constructor", "idx": 41329, "Desc": "constructs a prototypical event ."}{"node_name": "FormatFlagsConversionMismatchException(java.lang.String,char)", "type": "constructor", "idx": 41334, "Desc": "constructs an instance of this class with the specified flag and conversion ."}{"node_name": "Formatter()", "type": "constructor", "idx": 41354, "Desc": "constructs a new formatter . the destination of the formatted output is a stringbuilder which may be retrieved by invoking out() and whose current content may be converted into a string by invoking tostring() . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.lang.Appendable)", "type": "constructor", "idx": 41355, "Desc": "constructs a new formatter with the specified destination . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.util.Locale)", "type": "constructor", "idx": 41357, "Desc": "constructs a new formatter with the specified locale . the destination of the formatted output is a stringbuilder which may be retrieved by invoking out() and whose current content may be converted into a string by invoking tostring() ."}{"node_name": "Formatter(java.lang.Appendable,java.util.Locale)", "type": "constructor", "idx": 41359, "Desc": "constructs a new formatter with the specified destination and locale ."}{"node_name": "Formatter(java.lang.String)", "type": "constructor", "idx": 41362, "Desc": "constructs a new formatter with the specified file name . the charset used is the default charset for this instance of the java virtual machine . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.lang.String,java.lang.String)", "type": "constructor", "idx": 41364, "Desc": "constructs a new formatter with the specified file name and charset . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.lang.String,java.lang.String,java.util.Locale)", "type": "constructor", "idx": 41367, "Desc": "constructs a new formatter with the specified file name , charset , and locale ."}{"node_name": "Formatter(java.lang.String,java.nio.charset.Charset,java.util.Locale)", "type": "constructor", "idx": 41371, "Desc": "constructs a new formatter with the specified file name , charset , and locale ."}{"node_name": "Formatter(java.io.File)", "type": "constructor", "idx": 41375, "Desc": "constructs a new formatter with the specified file . the charset used is the default charset for this instance of the java virtual machine . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.io.File,java.lang.String)", "type": "constructor", "idx": 41377, "Desc": "constructs a new formatter with the specified file and charset . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.io.File,java.lang.String,java.util.Locale)", "type": "constructor", "idx": 41380, "Desc": "constructs a new formatter with the specified file , charset , and locale ."}{"node_name": "Formatter(java.io.File,java.nio.charset.Charset,java.util.Locale)", "type": "constructor", "idx": 41384, "Desc": "constructs a new formatter with the specified file , charset , and locale ."}{"node_name": "Formatter(java.io.PrintStream)", "type": "constructor", "idx": 41388, "Desc": "constructs a new formatter with the specified print stream . the locale used is the default locale for formatting for this instance of the java virtual machine . characters are written to the given printstream object and are therefore encoded using that object's charset ."}{"node_name": "Formatter(java.io.OutputStream)", "type": "constructor", "idx": 41390, "Desc": "constructs a new formatter with the specified output stream . the charset used is the default charset for this instance of the java virtual machine . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.io.OutputStream,java.lang.String)", "type": "constructor", "idx": 41392, "Desc": "constructs a new formatter with the specified output stream and charset . the locale used is the default locale for formatting for this instance of the java virtual machine ."}{"node_name": "Formatter(java.io.OutputStream,java.lang.String,java.util.Locale)", "type": "constructor", "idx": 41395, "Desc": "constructs a new formatter with the specified output stream , charset , and locale ."}{"node_name": "Formatter(java.io.OutputStream,java.nio.charset.Charset,java.util.Locale)", "type": "constructor", "idx": 41399, "Desc": "constructs a new formatter with the specified output stream , charset , and locale ."}{"node_name": "FormatterClosedException()", "type": "constructor", "idx": 41417, "Desc": "constructs an instance of this class ."}{"node_name": "GregorianCalendar()", "type": "constructor", "idx": 41619, "Desc": "constructs a default gregoriancalendar using the current time in the default time zone with the default format locale ."}{"node_name": "GregorianCalendar(java.util.TimeZone)", "type": "constructor", "idx": 41620, "Desc": "constructs a gregoriancalendar based on the current time in the given time zone with the default format locale ."}{"node_name": "GregorianCalendar(java.util.Locale)", "type": "constructor", "idx": 41622, "Desc": "constructs a gregoriancalendar based on the current time in the default time zone with the given locale ."}{"node_name": "GregorianCalendar(java.util.TimeZone,java.util.Locale)", "type": "constructor", "idx": 41624, "Desc": "constructs a gregoriancalendar based on the current time in the given time zone with the given locale ."}{"node_name": "GregorianCalendar(int,int,int)", "type": "constructor", "idx": 41627, "Desc": "constructs a gregoriancalendar with the given date set in the default time zone with the default locale ."}{"node_name": "GregorianCalendar(int,int,int,int,int)", "type": "constructor", "idx": 41631, "Desc": "constructs a gregoriancalendar with the given date and time set for the default time zone with the default locale ."}{"node_name": "GregorianCalendar(int,int,int,int,int,int)", "type": "constructor", "idx": 41637, "Desc": "constructs a gregoriancalendar with the given date and time set for the default time zone with the default locale ."}{"node_name": "HashMap(int,float)", "type": "constructor", "idx": 41687, "Desc": "constructs an empty hashmap with the specified initial capacity and load factor ."}{"node_name": "HashMap(int)", "type": "constructor", "idx": 41690, "Desc": "constructs an empty hashmap with the specified initial capacity and the default load factor ( 0.75 ) ."}{"node_name": "HashMap()", "type": "constructor", "idx": 41692, "Desc": "constructs an empty hashmap with the default initial capacity ( 16 ) and the default load factor ( 0.75 ) ."}{"node_name": "HashMap(java.util.Map)", "type": "constructor", "idx": 41693, "Desc": "constructs a new hashmap with the same mappings as the specified map . the hashmap is created with default load factor ( 0.75 ) and an initial capacity sufficient to hold the mappings in the specified map ."}{"node_name": "HashSet()", "type": "constructor", "idx": 41729, "Desc": "constructs a new , empty set ; the backing hashmap instance has default initial capacity ( 16 ) and load factor ( 0.75 ) ."}{"node_name": "HashSet(java.util.Collection)", "type": "constructor", "idx": 41730, "Desc": "constructs a new set containing the elements in the specified collection . the hashmap is created with default load factor ( 0.75 ) and an initial capacity sufficient to contain the elements in the specified collection ."}{"node_name": "HashSet(int,float)", "type": "constructor", "idx": 41732, "Desc": "constructs a new , empty set ; the backing hashmap instance has the specified initial capacity and the specified load factor ."}{"node_name": "HashSet(int)", "type": "constructor", "idx": 41735, "Desc": "constructs a new , empty set ; the backing hashmap instance has the specified initial capacity and default load factor ( 0.75 ) ."}{"node_name": "Hashtable(int,float)", "type": "constructor", "idx": 41750, "Desc": "constructs a new , empty hashtable with the specified initial capacity and the specified load factor ."}{"node_name": "Hashtable(int)", "type": "constructor", "idx": 41753, "Desc": "constructs a new , empty hashtable with the specified initial capacity and default load factor ( 0.75 ) ."}{"node_name": "Hashtable()", "type": "constructor", "idx": 41755, "Desc": "constructs a new , empty hashtable with a default initial capacity ( 11 ) and load factor ( 0.75 ) ."}{"node_name": "Hashtable(java.util.Map)", "type": "constructor", "idx": 41756, "Desc": "constructs a new hashtable with the same mappings as the given map . the hashtable is created with an initial capacity sufficient to hold the mappings in the given map and a default load factor ( 0.75 ) ."}{"node_name": "IdentityHashMap()", "type": "constructor", "idx": 41801, "Desc": "constructs a new , empty identity hash map with a default expected maximum size ( 21 ) ."}{"node_name": "IdentityHashMap(int)", "type": "constructor", "idx": 41802, "Desc": "constructs a new , empty map with the specified expected maximum size . putting more than the expected number of key-value mappings into the map may cause the internal data structure to grow , which may be somewhat time-consuming ."}{"node_name": "IdentityHashMap(java.util.Map)", "type": "constructor", "idx": 41804, "Desc": "constructs a new identity hash map containing the keys-value mappings in the specified map ."}{"node_name": "IllegalFormatCodePointException(int)", "type": "constructor", "idx": 41830, "Desc": "constructs an instance of this class with the specified illegal code point as defined by character.isvalidcodepoint ( int ) ."}{"node_name": "IllegalFormatConversionException(char,java.lang.Class)", "type": "constructor", "idx": 41834, "Desc": "constructs an instance of this class with the mismatched conversion and the corresponding argument class ."}{"node_name": "IllegalFormatFlagsException(java.lang.String)", "type": "constructor", "idx": 41841, "Desc": "constructs an instance of this class with the specified flags ."}{"node_name": "IllegalFormatPrecisionException(int)", "type": "constructor", "idx": 41845, "Desc": "constructs an instance of this class with the specified precision ."}{"node_name": "IllegalFormatWidthException(int)", "type": "constructor", "idx": 41849, "Desc": "constructs an instance of this class with the specified width ."}{"node_name": "IllformedLocaleException()", "type": "constructor", "idx": 41853, "Desc": "constructs a new illformedlocaleexception with no detail message and -1 as the error index ."}{"node_name": "IllformedLocaleException(java.lang.String)", "type": "constructor", "idx": 41854, "Desc": "constructs a new illformedlocaleexception with the given message and -1 as the error index ."}{"node_name": "IllformedLocaleException(java.lang.String,int)", "type": "constructor", "idx": 41856, "Desc": "constructs a new illformedlocaleexception with the given message and the error index . the error index is the approximate offset from the start of the ill-formed value to the point where the parse first detected an error . a negative error index value indicates either the error index is not applicable or unknown ."}{"node_name": "InputMismatchException()", "type": "constructor", "idx": 41861, "Desc": "constructs an inputmismatchexception with null as its error message string ."}{"node_name": "InputMismatchException(java.lang.String)", "type": "constructor", "idx": 41862, "Desc": "constructs an inputmismatchexception , saving a reference to the error message string s for later retrieval by the getmessage method ."}{"node_name": "IntSummaryStatistics()", "type": "constructor", "idx": 41865, "Desc": "constructs an empty instance with zero count , zero sum , integer.max_value min , integer.min_value max and zero average ."}{"node_name": "IntSummaryStatistics(long,int,int,long)", "type": "constructor", "idx": 41866, "Desc": "constructs a non-empty instance with the specified count , min , max , and sum . if count is zero then the remaining arguments are ignored and an empty instance is constructed . if the arguments are inconsistent then an illegalargumentexception is thrown . the necessary consistent argument conditions are : count > = 0 min <= max"}{"node_name": "InvalidPropertiesFormatException(java.lang.Throwable)", "type": "constructor", "idx": 41882, "Desc": "constructs an invalidpropertiesformatexception with the specified cause ."}{"node_name": "InvalidPropertiesFormatException(java.lang.String)", "type": "constructor", "idx": 41884, "Desc": "constructs an invalidpropertiesformatexception with the specified detail message ."}{"node_name": "Attributes()", "type": "constructor", "idx": 41894, "Desc": "constructs a new , empty attributes object with default size ."}{"node_name": "Attributes(int)", "type": "constructor", "idx": 41895, "Desc": "constructs a new , empty attributes object with the specified initial size ."}{"node_name": "Attributes(java.util.jar.Attributes)", "type": "constructor", "idx": 41897, "Desc": "constructs a new attributes object with the same attribute name-value mappings as in the specified attributes ."}{"node_name": "Name(java.lang.String)", "type": "constructor", "idx": 41945, "Desc": "constructs a new attribute name using the given string name ."}{"node_name": "JarEntry(java.lang.String)", "type": "constructor", "idx": 41992, "Desc": "creates a new jarentry for the specified jar file entry name ."}{"node_name": "JarEntry(java.util.zip.ZipEntry)", "type": "constructor", "idx": 41994, "Desc": "creates a new jarentry with fields taken from the specified zipentry object ."}{"node_name": "JarEntry(java.util.jar.JarEntry)", "type": "constructor", "idx": 41996, "Desc": "creates a new jarentry with fields taken from the specified jarentry object ."}{"node_name": "JarException()", "type": "constructor", "idx": 42003, "Desc": "constructs a jarexception with no detail message ."}{"node_name": "JarException(java.lang.String)", "type": "constructor", "idx": 42004, "Desc": "constructs a jarexception with the specified detail message ."}{"node_name": "JarFile(java.lang.String)", "type": "constructor", "idx": 42048, "Desc": "creates a new jarfile to read from the specified file name . the jarfile will be verified if it is signed ."}{"node_name": "JarFile(java.lang.String,boolean)", "type": "constructor", "idx": 42050, "Desc": "creates a new jarfile to read from the specified file name ."}{"node_name": "JarFile(java.io.File)", "type": "constructor", "idx": 42053, "Desc": "creates a new jarfile to read from the specified file object . the jarfile will be verified if it is signed ."}{"node_name": "JarFile(java.io.File,boolean)", "type": "constructor", "idx": 42055, "Desc": "creates a new jarfile to read from the specified file object ."}{"node_name": "JarFile(java.io.File,boolean,int)", "type": "constructor", "idx": 42058, "Desc": "creates a new jarfile to read from the specified file object in the specified mode . the mode argument must be either open_read or open_read | open_delete ."}{"node_name": "JarFile(java.io.File,boolean,int,java.lang.Runtime.Version)", "type": "constructor", "idx": 42062, "Desc": "creates a new jarfile to read from the specified file object in the specified mode . the mode argument must be either open_read or open_read | open_delete . the version argument , after being converted to a canonical form , is used to configure the jarfile for processing multi-release jar files . the canonical form derived from the version parameter is runtime.version.parse ( integer.tostring ( n )) where n is math.max ( version.feature() , jarfile.baseversion() .feature() ) ."}{"node_name": "JarInputStream(java.io.InputStream)", "type": "constructor", "idx": 42122, "Desc": "creates a new jarinputstream and reads the optional manifest . if a manifest is present , also attempts to verify the signatures if the jarinputstream is signed ."}{"node_name": "JarInputStream(java.io.InputStream,boolean)", "type": "constructor", "idx": 42124, "Desc": "creates a new jarinputstream and reads the optional manifest . if a manifest is present and verify is true , also attempts to verify the signatures if the jarinputstream is signed ."}{"node_name": "JarOutputStream(java.io.OutputStream,java.util.jar.Manifest)", "type": "constructor", "idx": 42177, "Desc": "creates a new jaroutputstream with the specified manifest . the manifest is written as the first entry to the output stream ."}{"node_name": "JarOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 42180, "Desc": "creates a new jaroutputstream with no manifest ."}{"node_name": "Manifest()", "type": "constructor", "idx": 42185, "Desc": "constructs a new , empty manifest ."}{"node_name": "Manifest(java.io.InputStream)", "type": "constructor", "idx": 42186, "Desc": "constructs a new manifest from the specified input stream ."}{"node_name": "Manifest(java.util.jar.Manifest)", "type": "constructor", "idx": 42188, "Desc": "constructs a new manifest that is a copy of the specified manifest ."}{"node_name": "LinkedHashMap(int,float)", "type": "constructor", "idx": 42207, "Desc": "constructs an empty insertion-ordered linkedhashmap instance with the specified initial capacity and load factor ."}{"node_name": "LinkedHashMap(int)", "type": "constructor", "idx": 42210, "Desc": "constructs an empty insertion-ordered linkedhashmap instance with the specified initial capacity and a default load factor ( 0.75 ) ."}{"node_name": "LinkedHashMap()", "type": "constructor", "idx": 42212, "Desc": "constructs an empty insertion-ordered linkedhashmap instance with the default initial capacity ( 16 ) and load factor ( 0.75 ) ."}{"node_name": "LinkedHashMap(java.util.Map)", "type": "constructor", "idx": 42213, "Desc": "constructs an insertion-ordered linkedhashmap instance with the same mappings as the specified map . the linkedhashmap instance is created with a default load factor ( 0.75 ) and an initial capacity sufficient to hold the mappings in the specified map ."}{"node_name": "LinkedHashMap(int,float,boolean)", "type": "constructor", "idx": 42215, "Desc": "constructs an empty linkedhashmap instance with the specified initial capacity , load factor and ordering mode ."}{"node_name": "LinkedHashSet(int,float)", "type": "constructor", "idx": 42229, "Desc": "constructs a new , empty linked hash set with the specified initial capacity and load factor ."}{"node_name": "LinkedHashSet(int)", "type": "constructor", "idx": 42232, "Desc": "constructs a new , empty linked hash set with the specified initial capacity and the default load factor ( 0.75 ) ."}{"node_name": "LinkedHashSet()", "type": "constructor", "idx": 42234, "Desc": "constructs a new , empty linked hash set with the default initial capacity ( 16 ) and load factor ( 0.75 ) ."}{"node_name": "LinkedHashSet(java.util.Collection)", "type": "constructor", "idx": 42235, "Desc": "constructs a new linked hash set with the same elements as the specified collection . the linked hash set is created with an initial capacity sufficient to hold the elements in the specified collection and the default load factor ( 0.75 ) ."}{"node_name": "LinkedList()", "type": "constructor", "idx": 42239, "Desc": "constructs an empty list ."}{"node_name": "LinkedList(java.util.Collection)", "type": "constructor", "idx": 42240, "Desc": "constructs a list containing the elements of the specified collection , in the order they are returned by the collection's iterator ."}{"node_name": "ListResourceBundle()", "type": "constructor", "idx": 42442, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "Builder()", "type": "constructor", "idx": 42447, "Desc": "constructs an empty builder . the default value of all fields , extensions , and private use information is the empty string ."}{"node_name": "Locale(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 42510, "Desc": "construct a locale from language , country and variant . <init>(java.lang.String,java.lang.String,java.lang.String) normalizes the language value to lowercase and the country value to uppercase . note : iso 639 is not a stable standard ; some of the language codes it defines ( specifically \" iw \" , \" ji \" , and \" in \") have changed . <init>(java.lang.String,java.lang.String,java.lang.String) accepts both the old codes ( \" iw \" , \" ji \" , and \" in \") and the new codes ( \" he \" , \" yi \" , and \" id \") , but all other api on locale will return only the old codes . for backward compatibility reasons , <init>(java.lang.String,java.lang.String,java.lang.String) does not make any syntactic checks on the input . the two cases ( \" ja \" , \" jp \" , \" jp \") and ( \" th \" , \" th \" , \" th \") are handled specially , see special cases for more information ."}{"node_name": "Locale(java.lang.String,java.lang.String)", "type": "constructor", "idx": 42514, "Desc": "construct a locale from language and country . <init>(java.lang.String,java.lang.String) normalizes the language value to lowercase and the country value to uppercase . note : iso 639 is not a stable standard ; some of the language codes it defines ( specifically \" iw \" , \" ji \" , and \" in \") have changed . <init>(java.lang.String,java.lang.String) accepts both the old codes ( \" iw \" , \" ji \" , and \" in \") and the new codes ( \" he \" , \" yi \" , and \" id \") , but all other api on locale will return only the old codes . for backward compatibility reasons , <init>(java.lang.String,java.lang.String) does not make any syntactic checks on the input ."}{"node_name": "Locale(java.lang.String)", "type": "constructor", "idx": 42517, "Desc": "construct a locale from a language code . <init>(java.lang.String) normalizes the language value to lowercase . note : iso 639 is not a stable standard ; some of the language codes it defines ( specifically \" iw \" , \" ji \" , and \" in \") have changed . <init>(java.lang.String) accepts both the old codes ( \" iw \" , \" ji \" , and \" in \") and the new codes ( \" he \" , \" yi \" , and \" id \") , but all other api on locale will return only the old codes . for backward compatibility reasons , <init>(java.lang.String) does not make any syntactic checks on the input ."}{"node_name": "LanguageRange(java.lang.String)", "type": "constructor", "idx": 42593, "Desc": "constructs a languagerange using the given range . note that no validation is done against the iana language subtag registry at time of construction . this is equivalent to languagerange ( range , max_weight ) ."}{"node_name": "LanguageRange(java.lang.String,double)", "type": "constructor", "idx": 42595, "Desc": "constructs a languagerange using the given range and weight . note that no validation is done against the iana language subtag registry at time of construction ."}{"node_name": "ConsoleHandler()", "type": "constructor", "idx": 42613, "Desc": "create a consolehandler for system.err . the consolehandler is configured based on logmanager properties ( or their default values ) ."}{"node_name": "ErrorManager()", "type": "constructor", "idx": 42624, "Desc": ""}{"node_name": "FileHandler()", "type": "constructor", "idx": 42630, "Desc": "construct a default filehandler . this will be configured entirely from logmanager properties ( or their default values ) ."}{"node_name": "FileHandler(java.lang.String)", "type": "constructor", "idx": 42631, "Desc": "initialize a filehandler to write to the given filename . the filehandler is configured based on logmanager properties ( or their default values ) except that the given pattern argument is used as the filename pattern , the file limit is set to no limit , and the file count is set to one . there is no limit on the amount of data that may be written , so use this with care ."}{"node_name": "FileHandler(java.lang.String,boolean)", "type": "constructor", "idx": 42633, "Desc": "initialize a filehandler to write to the given filename , with optional append . the filehandler is configured based on logmanager properties ( or their default values ) except that the given pattern argument is used as the filename pattern , the file limit is set to no limit , the file count is set to one , and the append mode is set to the given append argument . there is no limit on the amount of data that may be written , so use this with care ."}{"node_name": "FileHandler(java.lang.String,int,int)", "type": "constructor", "idx": 42636, "Desc": "initialize a filehandler to write to a set of files . when ( approximately ) the given limit has been written to one file , another file will be opened . the output will cycle through a set of count files . the filehandler is configured based on logmanager properties ( or their default values ) except that the given pattern argument is used as the filename pattern , the file limit is set to the limit argument , and the file count is set to the given count argument . the count must be at least 1 ."}{"node_name": "FileHandler(java.lang.String,int,int,boolean)", "type": "constructor", "idx": 42640, "Desc": "initialize a filehandler to write to a set of files with optional append . when ( approximately ) the given limit has been written to one file , another file will be opened . the output will cycle through a set of count files . the filehandler is configured based on logmanager properties ( or their default values ) except that the given pattern argument is used as the filename pattern , the file limit is set to the limit argument , and the file count is set to the given count argument , and the append mode is set to the given append argument . the count must be at least 1 ."}{"node_name": "FileHandler(java.lang.String,long,int,boolean)", "type": "constructor", "idx": 42645, "Desc": "initialize a filehandler to write to a set of files with optional append . when ( approximately ) the given limit has been written to one file , another file will be opened . the output will cycle through a set of count files . the filehandler is configured based on logmanager properties ( or their default values ) except that the given pattern argument is used as the filename pattern , the file limit is set to the limit argument , and the file count is set to the given count argument , and the append mode is set to the given append argument . the count must be at least 1 ."}{"node_name": "Formatter()", "type": "constructor", "idx": 42657, "Desc": "construct a new formatter ."}{"node_name": "Handler()", "type": "constructor", "idx": 42667, "Desc": "default constructor . the resulting handler has a log level of level.all , no formatter , and no filter . a default errormanager instance is installed as the errormanager ."}{"node_name": "Level(java.lang.String,int)", "type": "constructor", "idx": 42703, "Desc": "create a named level with a given integer value . note that <init>(java.lang.String,int) is \" protected \" to allow subclassing . in general clients of logging should use one of the constant level objects such as severe or finest . however , if clients need to add new logging levels , they may subclass level and define new constants ."}{"node_name": "Level(java.lang.String,int,java.lang.String)", "type": "constructor", "idx": 42706, "Desc": "create a named level with a given integer value and a given localization resource name ."}{"node_name": "Logger(java.lang.String,java.lang.String)", "type": "constructor", "idx": 42722, "Desc": "protected method to construct a logger for a named subsystem . the logger will be initially configured with a null level and with useparenthandlers set to true ."}{"node_name": "LoggingPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 42892, "Desc": "creates a new loggingpermission object ."}{"node_name": "LogManager()", "type": "constructor", "idx": 42897, "Desc": "protected constructor . this is protected so that container applications ( such as j2ee containers ) can subclass the object . it is non-public as it is intended that there only be one logmanager object , whose value is retrieved by calling logmanager.getlogmanager ."}{"node_name": "LogRecord(java.util.logging.Level,java.lang.String)", "type": "constructor", "idx": 42921, "Desc": "construct a logrecord with the given level and message values . the sequence property will be initialized with a new unique value . these sequence values are allocated in increasing order within a vm . since jdk 9 , the event time is represented by an instant . the instant property will be initialized to the current instant , using the best available clock on the system . the thread id property will be initialized with a unique id for the current thread . all other properties will be initialized to \" null \" ."}{"node_name": "MemoryHandler()", "type": "constructor", "idx": 42962, "Desc": "create a memoryhandler and configure it based on logmanager configuration properties ."}{"node_name": "MemoryHandler(java.util.logging.Handler,int,java.util.logging.Level)", "type": "constructor", "idx": 42963, "Desc": "create a memoryhandler . the memoryhandler is configured based on logmanager properties ( or their default values ) except that the given pushlevel argument and buffer size argument are used ."}{"node_name": "SimpleFormatter()", "type": "constructor", "idx": 42978, "Desc": ""}{"node_name": "SocketHandler()", "type": "constructor", "idx": 42982, "Desc": "create a sockethandler , using only logmanager properties ( or their defaults ) ."}{"node_name": "SocketHandler(java.lang.String,int)", "type": "constructor", "idx": 42983, "Desc": "construct a sockethandler using a specified host and port . the sockethandler is configured based on logmanager properties ( or their default values ) except that the given target host and port arguments are used . if the host argument is empty , but not null string then the localhost is used ."}{"node_name": "StreamHandler()", "type": "constructor", "idx": 42990, "Desc": "create a streamhandler , with no current output stream ."}{"node_name": "StreamHandler(java.io.OutputStream,java.util.logging.Formatter)", "type": "constructor", "idx": 42991, "Desc": "create a streamhandler with a given formatter and output stream ."}{"node_name": "XMLFormatter()", "type": "constructor", "idx": 43005, "Desc": "creates a new instance of xmlformatter ."}{"node_name": "LongSummaryStatistics()", "type": "constructor", "idx": 43013, "Desc": "constructs an empty instance with zero count , zero sum , long.max_value min , long.min_value max and zero average ."}{"node_name": "LongSummaryStatistics(long,long,long,long)", "type": "constructor", "idx": 43014, "Desc": "constructs a non-empty instance with the specified count , min , max , and sum . if count is zero then the remaining arguments are ignored and an empty instance is constructed . if the arguments are inconsistent then an illegalargumentexception is thrown . the necessary consistent argument conditions are : count > = 0 min <= max"}{"node_name": "MissingFormatArgumentException(java.lang.String)", "type": "constructor", "idx": 43230, "Desc": "constructs an instance of this class with the unmatched format specifier ."}{"node_name": "MissingFormatWidthException(java.lang.String)", "type": "constructor", "idx": 43234, "Desc": "constructs an instance of this class with the specified format specifier ."}{"node_name": "MissingResourceException(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 43238, "Desc": "constructs a missingresourceexception with the specified information . a detail message is a string that describes this particular exception ."}{"node_name": "NoSuchElementException()", "type": "constructor", "idx": 43319, "Desc": "constructs a nosuchelementexception with null as its error message string ."}{"node_name": "NoSuchElementException(java.lang.String)", "type": "constructor", "idx": 43320, "Desc": "constructs a nosuchelementexception , saving a reference to the error message string s for later retrieval by the getmessage method ."}{"node_name": "AbstractPreferences(java.util.prefs.AbstractPreferences,java.lang.String)", "type": "constructor", "idx": 43482, "Desc": "creates a preference node with the specified parent and the specified name relative to its parent ."}{"node_name": "BackingStoreException(java.lang.String)", "type": "constructor", "idx": 43567, "Desc": "constructs a backingstoreexception with the specified detail message ."}{"node_name": "BackingStoreException(java.lang.Throwable)", "type": "constructor", "idx": 43569, "Desc": "constructs a backingstoreexception with the specified cause ."}{"node_name": "InvalidPreferencesFormatException(java.lang.Throwable)", "type": "constructor", "idx": 43572, "Desc": "constructs an invalidpreferencesformatexception with the specified cause ."}{"node_name": "InvalidPreferencesFormatException(java.lang.String)", "type": "constructor", "idx": 43574, "Desc": "constructs an invalidpreferencesformatexception with the specified detail message ."}{"node_name": "InvalidPreferencesFormatException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 43576, "Desc": "constructs an invalidpreferencesformatexception with the specified detail message and cause ."}{"node_name": "NodeChangeEvent(java.util.prefs.Preferences,java.util.prefs.Preferences)", "type": "constructor", "idx": 43580, "Desc": "constructs a new nodechangeevent instance ."}{"node_name": "PreferenceChangeEvent(java.util.prefs.Preferences,java.lang.String,java.lang.String)", "type": "constructor", "idx": 43591, "Desc": "constructs a new preferencechangeevent instance ."}{"node_name": "Preferences()", "type": "constructor", "idx": 43605, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "PriorityQueue()", "type": "constructor", "idx": 43713, "Desc": "creates a priorityqueue with the default initial capacity ( 11 ) that orders its elements according to their natural ordering ."}{"node_name": "PriorityQueue(int)", "type": "constructor", "idx": 43714, "Desc": "creates a priorityqueue with the specified initial capacity that orders its elements according to their natural ordering ."}{"node_name": "PriorityQueue(java.util.Comparator)", "type": "constructor", "idx": 43716, "Desc": "creates a priorityqueue with the default initial capacity and whose elements are ordered according to the specified comparator ."}{"node_name": "PriorityQueue(int,java.util.Comparator)", "type": "constructor", "idx": 43718, "Desc": "creates a priorityqueue with the specified initial capacity that orders its elements according to the specified comparator ."}{"node_name": "PriorityQueue(java.util.Collection)", "type": "constructor", "idx": 43721, "Desc": "creates a priorityqueue containing the elements in the specified collection . if the specified collection is an instance of a sortedset or is another priorityqueue , this priority queue will be ordered according to the same ordering . otherwise , this priority queue will be ordered according to the natural ordering of its elements ."}{"node_name": "PriorityQueue(java.util.PriorityQueue)", "type": "constructor", "idx": 43723, "Desc": "creates a priorityqueue containing the elements in the specified priority queue . this priority queue will be ordered according to the same ordering as the given priority queue ."}{"node_name": "PriorityQueue(java.util.SortedSet)", "type": "constructor", "idx": 43725, "Desc": "creates a priorityqueue containing the elements in the specified sorted set . this priority queue will be ordered according to the same ordering as the given sorted set ."}{"node_name": "Properties()", "type": "constructor", "idx": 43752, "Desc": "creates an empty property list with no default values ."}{"node_name": "Properties(int)", "type": "constructor", "idx": 43753, "Desc": "creates an empty property list with no default values , and with an initial size accommodating the specified number of elements without the need to dynamically resize ."}{"node_name": "Properties(java.util.Properties)", "type": "constructor", "idx": 43755, "Desc": "creates an empty property list with the specified defaults ."}{"node_name": "PropertyPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 43795, "Desc": "creates a new propertypermission object with the specified name . the name is the name of the system property , and actions contains a comma-separated list of the desired actions granted on the property . possible actions are \" read \" and \" write \" ."}{"node_name": "PropertyResourceBundle(java.io.InputStream)", "type": "constructor", "idx": 43806, "Desc": "creates a property resource bundle from an inputstream . <init>(java.io.InputStream) reads the property file in utf-8 by default . if a malformedinputexception or an unmappablecharacterexception occurs on reading the input stream , then the propertyresourcebundle instance resets to the state before the exception , re-reads the input stream in iso-8859-1 and continues reading . if the system property java.util.propertyresourcebundle.encoding is set to either \" iso-8859-1 \" or \" utf-8 \" , the input stream is solely read in that encoding , and throws the exception if it encounters an invalid sequence . other encoding values are ignored for this system property . the system property is read and evaluated when initializing this class . changing or removing the property has no effect after the initialization ."}{"node_name": "PropertyResourceBundle(java.io.Reader)", "type": "constructor", "idx": 43808, "Desc": "creates a property resource bundle from a reader . unlike <init>(java.io.Reader) propertyresourcebundle ( inputstream ) , there is no limitation as to the encoding of the input property file ."}{"node_name": "Random()", "type": "constructor", "idx": 43822, "Desc": "creates a new random number generator . <init>() sets the seed of the random number generator to a value very likely to be distinct from any other invocation of <init>() ."}{"node_name": "Random(long)", "type": "constructor", "idx": 43823, "Desc": "creates a new random number generator using a single long seed . the seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method next ( int ) . the invocation new random ( seed ) is equivalent to : random rnd = new random() ; rnd.setseed ( seed );"}{"node_name": "PatternSyntaxException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 43980, "Desc": "constructs a new instance of this class ."}{"node_name": "Control()", "type": "constructor", "idx": 43994, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "ResourceBundle()", "type": "constructor", "idx": 44031, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "Scanner(java.lang.Readable)", "type": "constructor", "idx": 44081, "Desc": "constructs a new scanner that produces values scanned from the specified source ."}{"node_name": "Scanner(java.io.InputStream)", "type": "constructor", "idx": 44083, "Desc": "constructs a new scanner that produces values scanned from the specified input stream . bytes from the stream are converted into characters using the underlying platform's default charset ."}{"node_name": "Scanner(java.io.InputStream,java.lang.String)", "type": "constructor", "idx": 44085, "Desc": "constructs a new scanner that produces values scanned from the specified input stream . bytes from the stream are converted into characters using the specified charset ."}{"node_name": "Scanner(java.io.InputStream,java.nio.charset.Charset)", "type": "constructor", "idx": 44088, "Desc": "constructs a new scanner that produces values scanned from the specified input stream . bytes from the stream are converted into characters using the specified charset ."}{"node_name": "Scanner(java.io.File)", "type": "constructor", "idx": 44091, "Desc": "constructs a new scanner that produces values scanned from the specified file . bytes from the file are converted into characters using the underlying platform's default charset ."}{"node_name": "Scanner(java.io.File,java.lang.String)", "type": "constructor", "idx": 44093, "Desc": "constructs a new scanner that produces values scanned from the specified file . bytes from the file are converted into characters using the specified charset ."}{"node_name": "Scanner(java.io.File,java.nio.charset.Charset)", "type": "constructor", "idx": 44096, "Desc": "constructs a new scanner that produces values scanned from the specified file . bytes from the file are converted into characters using the specified charset ."}{"node_name": "Scanner(java.nio.file.Path)", "type": "constructor", "idx": 44099, "Desc": "constructs a new scanner that produces values scanned from the specified file . bytes from the file are converted into characters using the underlying platform's default charset ."}{"node_name": "Scanner(java.nio.file.Path,java.lang.String)", "type": "constructor", "idx": 44101, "Desc": "constructs a new scanner that produces values scanned from the specified file . bytes from the file are converted into characters using the specified charset ."}{"node_name": "Scanner(java.nio.file.Path,java.nio.charset.Charset)", "type": "constructor", "idx": 44104, "Desc": "constructs a new scanner that produces values scanned from the specified file . bytes from the file are converted into characters using the specified charset ."}{"node_name": "Scanner(java.lang.String)", "type": "constructor", "idx": 44107, "Desc": "constructs a new scanner that produces values scanned from the specified string ."}{"node_name": "Scanner(java.nio.channels.ReadableByteChannel)", "type": "constructor", "idx": 44109, "Desc": "constructs a new scanner that produces values scanned from the specified channel . bytes from the source are converted into characters using the underlying platform's default charset ."}{"node_name": "Scanner(java.nio.channels.ReadableByteChannel,java.lang.String)", "type": "constructor", "idx": 44111, "Desc": "constructs a new scanner that produces values scanned from the specified channel . bytes from the source are converted into characters using the specified charset ."}{"node_name": "Scanner(java.nio.channels.ReadableByteChannel,java.nio.charset.Charset)", "type": "constructor", "idx": 44114, "Desc": "constructs a new scanner that produces values scanned from the specified channel . bytes from the source are converted into characters using the specified charset ."}{"node_name": "ServiceConfigurationError(java.lang.String)", "type": "constructor", "idx": 44204, "Desc": "constructs a new instance with the specified message ."}{"node_name": "ServiceConfigurationError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 44206, "Desc": "constructs a new instance with the specified message and cause ."}{"node_name": "SimpleTimeZone(int,java.lang.String)", "type": "constructor", "idx": 44328, "Desc": "constructs a simpletimezone with the given base time zone offset from gmt and time zone id with no daylight saving time schedule ."}{"node_name": "SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int)", "type": "constructor", "idx": 44331, "Desc": "constructs a simpletimezone with the given base time zone offset from gmt , time zone id , and rules for starting and ending the daylight time . both starttime and endtime are specified to be represented in the wall clock time . the amount of daylight saving is assumed to be 3600000 milliseconds ( i.e. , one hour ) . <init>(int,java.lang.String,int,int,int,int,int,int,int,int) is equivalent to : simpletimezone ( rawoffset , id , startmonth , startday , startdayofweek , starttime , simpletimezone.wall_time , endmonth , endday , enddayofweek , endtime , simpletimezone.wall_time , 3600000 )"}{"node_name": "SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int,int)", "type": "constructor", "idx": 44342, "Desc": "constructs a simpletimezone with the given base time zone offset from gmt , time zone id , and rules for starting and ending the daylight time . both starttime and endtime are assumed to be represented in the wall clock time . <init>(int,java.lang.String,int,int,int,int,int,int,int,int,int) is equivalent to : simpletimezone ( rawoffset , id , startmonth , startday , startdayofweek , starttime , simpletimezone.wall_time , endmonth , endday , enddayofweek , endtime , simpletimezone.wall_time , dstsavings )"}{"node_name": "SimpleTimeZone(int,java.lang.String,int,int,int,int,int,int,int,int,int,int,int)", "type": "constructor", "idx": 44354, "Desc": "constructs a simpletimezone with the given base time zone offset from gmt , time zone id , and rules for starting and ending the daylight time . <init>(int,java.lang.String,int,int,int,int,int,int,int,int,int,int,int) takes the full set of the start and end rules parameters , including modes of starttime and endtime . the mode specifies either wall time or standard time or utc time ."}{"node_name": "AbstractResourceBundleProvider()", "type": "constructor", "idx": 44453, "Desc": "constructs an abstractresourcebundleprovider with the \" java.properties \" format . <init>() is equivalent to abstractresourcebundleprovider ( \" java.properties \") ."}{"node_name": "AbstractResourceBundleProvider(java.lang.String...)", "type": "constructor", "idx": 44454, "Desc": "constructs an abstractresourcebundleprovider with the specified formats . the getbundle ( string , locale ) method looks up resource bundles for the given formats . formats must be \" java.class \" or \" java.properties \" ."}{"node_name": "CalendarDataProvider()", "type": "constructor", "idx": 44463, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "CalendarNameProvider()", "type": "constructor", "idx": 44469, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "CurrencyNameProvider()", "type": "constructor", "idx": 44482, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "LocaleNameProvider()", "type": "constructor", "idx": 44490, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "LocaleServiceProvider()", "type": "constructor", "idx": 44511, "Desc": "initializes a new locale service provider ."}{"node_name": "TimeZoneNameProvider()", "type": "constructor", "idx": 44523, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "AbstractDoubleSpliterator(long,int)", "type": "constructor", "idx": 44586, "Desc": "creates a spliterator reporting the given estimated size and characteristics ."}{"node_name": "AbstractIntSpliterator(long,int)", "type": "constructor", "idx": 44593, "Desc": "creates a spliterator reporting the given estimated size and characteristics ."}{"node_name": "AbstractLongSpliterator(long,int)", "type": "constructor", "idx": 44600, "Desc": "creates a spliterator reporting the given estimated size and characteristics ."}{"node_name": "AbstractSpliterator(long,int)", "type": "constructor", "idx": 44607, "Desc": "creates a spliterator reporting the given estimated size and additionalcharacteristics ."}{"node_name": "SplittableRandom(long)", "type": "constructor", "idx": 44690, "Desc": "creates a new splittablerandom instance using the specified initial seed . splittablerandom instances created with the same seed in the same program generate identical sequences of values ."}{"node_name": "SplittableRandom()", "type": "constructor", "idx": 44692, "Desc": "creates a new splittablerandom instance that is likely to generate sequences of values that are statistically independent of those of any other instances in the current program ; and may , and typically does , vary across program invocations ."}{"node_name": "Stack()", "type": "constructor", "idx": 44746, "Desc": "creates an empty stack ."}{"node_name": "StringJoiner(java.lang.CharSequence)", "type": "constructor", "idx": 45274, "Desc": "constructs a stringjoiner with no characters in it , with no prefix or suffix , and a copy of the supplied delimiter . if no characters are added to the stringjoiner and methods accessing the value of it are invoked , it will not return a prefix or suffix ( or properties thereof ) in the result , unless setemptyvalue has first been called ."}{"node_name": "StringJoiner(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)", "type": "constructor", "idx": 45276, "Desc": "constructs a stringjoiner with no characters in it using copies of the supplied prefix , delimiter and suffix . if no characters are added to the stringjoiner and methods accessing the string value of it are invoked , it will return the prefix + suffix ( or properties thereof ) in the result , unless setemptyvalue has first been called ."}{"node_name": "StringTokenizer(java.lang.String,java.lang.String,boolean)", "type": "constructor", "idx": 45289, "Desc": "constructs a string tokenizer for the specified string . all characters in the delim argument are the delimiters for separating tokens . if the returndelims flag is true , then the delimiter characters are also returned as tokens . each delimiter is returned as a string of length one . if the flag is false , the delimiter characters are skipped and only serve as separators between tokens . note that if delim is null , <init>(java.lang.String,java.lang.String,boolean) does not throw an exception . however , trying to invoke other methods on the resulting stringtokenizer may result in a nullpointerexception ."}{"node_name": "StringTokenizer(java.lang.String,java.lang.String)", "type": "constructor", "idx": 45293, "Desc": "constructs a string tokenizer for the specified string . the characters in the delim argument are the delimiters for separating tokens . delimiter characters themselves will not be treated as tokens . note that if delim is null , <init>(java.lang.String,java.lang.String) does not throw an exception . however , trying to invoke other methods on the resulting stringtokenizer may result in a nullpointerexception ."}{"node_name": "StringTokenizer(java.lang.String)", "type": "constructor", "idx": 45296, "Desc": "constructs a string tokenizer for the specified string . the tokenizer uses the default delimiter set , which is \" \\t\\n\\r\\f \" : the space character , the tab character , the newline character , the carriage-return character , and the form-feed character . delimiter characters themselves will not be treated as tokens ."}{"node_name": "Timer()", "type": "constructor", "idx": 45306, "Desc": "creates a new timer . the associated thread does not run as a daemon ."}{"node_name": "Timer(boolean)", "type": "constructor", "idx": 45307, "Desc": "creates a new timer whose associated thread may be specified to run as a daemon . a daemon thread is called for if the timer will be used to schedule repeating \" maintenance activities \" , which must be performed as long as the application is running , but should not prolong the lifetime of the application ."}{"node_name": "Timer(java.lang.String)", "type": "constructor", "idx": 45309, "Desc": "creates a new timer whose associated thread has the specified name . the associated thread does not run as a daemon ."}{"node_name": "Timer(java.lang.String,boolean)", "type": "constructor", "idx": 45311, "Desc": "creates a new timer whose associated thread has the specified name , and may be specified to run as a daemon ."}{"node_name": "TimerTask()", "type": "constructor", "idx": 45339, "Desc": "creates a new timer task ."}{"node_name": "TimeZone()", "type": "constructor", "idx": 45346, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "TooManyListenersException()", "type": "constructor", "idx": 45392, "Desc": "constructs a toomanylistenersexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "TooManyListenersException(java.lang.String)", "type": "constructor", "idx": 45393, "Desc": "constructs a toomanylistenersexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "TreeMap()", "type": "constructor", "idx": 45396, "Desc": "constructs a new , empty tree map , using the natural ordering of its keys . all keys inserted into the map must implement the comparable interface . furthermore , all such keys must be mutually comparable : k1.compareto ( k2 ) must not throw a classcastexception for any keys k1 and k2 in the map . if the user attempts to put a key into the map that violates this constraint ( for example , the user attempts to put a string key into a map whose keys are integers ) , the put ( object key , object value ) call will throw a classcastexception ."}{"node_name": "TreeMap(java.util.Comparator)", "type": "constructor", "idx": 45397, "Desc": "constructs a new , empty tree map , ordered according to the given comparator . all keys inserted into the map must be mutually comparable by the given comparator : comparator.compare ( k1 , k2 ) must not throw a classcastexception for any keys k1 and k2 in the map . if the user attempts to put a key into the map that violates this constraint , the put ( object key , object value ) call will throw a classcastexception ."}{"node_name": "TreeMap(java.util.Map)", "type": "constructor", "idx": 45399, "Desc": "constructs a new tree map containing the same mappings as the given map , ordered according to the natural ordering of its keys . all keys inserted into the new map must implement the comparable interface . furthermore , all such keys must be mutually comparable : k1.compareto ( k2 ) must not throw a classcastexception for any keys k1 and k2 in the map . this method runs in n*log ( n ) time ."}{"node_name": "TreeMap(java.util.SortedMap)", "type": "constructor", "idx": 45401, "Desc": "constructs a new tree map containing the same mappings and using the same ordering as the specified sorted map . this method runs in linear time ."}{"node_name": "TreeSet()", "type": "constructor", "idx": 45466, "Desc": "constructs a new , empty tree set , sorted according to the natural ordering of its elements . all elements inserted into the set must implement the comparable interface . furthermore , all such elements must be mutually comparable : e1.compareto ( e2 ) must not throw a classcastexception for any elements e1 and e2 in the set . if the user attempts to add an element to the set that violates this constraint ( for example , the user attempts to add a string element to a set whose elements are integers ) , the add call will throw a classcastexception ."}{"node_name": "TreeSet(java.util.Comparator)", "type": "constructor", "idx": 45467, "Desc": "constructs a new , empty tree set , sorted according to the specified comparator . all elements inserted into the set must be mutually comparable by the specified comparator : comparator.compare ( e1 , e2 ) must not throw a classcastexception for any elements e1 and e2 in the set . if the user attempts to add an element to the set that violates this constraint , the add call will throw a classcastexception ."}{"node_name": "TreeSet(java.util.Collection)", "type": "constructor", "idx": 45469, "Desc": "constructs a new tree set containing the elements in the specified collection , sorted according to the natural ordering of its elements . all elements inserted into the set must implement the comparable interface . furthermore , all such elements must be mutually comparable : e1.compareto ( e2 ) must not throw a classcastexception for any elements e1 and e2 in the set ."}{"node_name": "TreeSet(java.util.SortedSet)", "type": "constructor", "idx": 45471, "Desc": "constructs a new tree set containing the same elements and using the same ordering as the specified sorted set ."}{"node_name": "UnknownFormatConversionException(java.lang.String)", "type": "constructor", "idx": 45520, "Desc": "constructs an instance of this class with the unknown conversion ."}{"node_name": "UnknownFormatFlagsException(java.lang.String)", "type": "constructor", "idx": 45524, "Desc": "constructs an instance of this class with the specified flags ."}{"node_name": "UUID(long,long)", "type": "constructor", "idx": 45528, "Desc": "constructs a new uuid using the specified data . mostsigbits is used for the most significant 64 bits of the uuid and leastsigbits becomes the least significant 64 bits of the uuid ."}{"node_name": "Vector(int,int)", "type": "constructor", "idx": 45553, "Desc": "constructs an empty vector with the specified initial capacity and capacity increment ."}{"node_name": "Vector(int)", "type": "constructor", "idx": 45556, "Desc": "constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero ."}{"node_name": "Vector()", "type": "constructor", "idx": 45558, "Desc": "constructs an empty vector so that its internal data array has size 10 and its standard capacity increment is zero ."}{"node_name": "Vector(java.util.Collection)", "type": "constructor", "idx": 45559, "Desc": "constructs a vector containing the elements of the specified collection , in the order they are returned by the collection's iterator ."}{"node_name": "WeakHashMap(int,float)", "type": "constructor", "idx": 45653, "Desc": "constructs a new , empty weakhashmap with the given initial capacity and the given load factor ."}{"node_name": "WeakHashMap(int)", "type": "constructor", "idx": 45656, "Desc": "constructs a new , empty weakhashmap with the given initial capacity and the default load factor ( 0.75 ) ."}{"node_name": "WeakHashMap()", "type": "constructor", "idx": 45658, "Desc": "constructs a new , empty weakhashmap with the default initial capacity ( 16 ) and load factor ( 0.75 ) ."}{"node_name": "WeakHashMap(java.util.Map)", "type": "constructor", "idx": 45659, "Desc": "constructs a new weakhashmap with the same mappings as the specified map . the weakhashmap is created with the default load factor ( 0.75 ) and an initial capacity sufficient to hold the mappings in the specified map ."}{"node_name": "Adler32()", "type": "constructor", "idx": 45681, "Desc": "creates a new adler32 object ."}{"node_name": "CheckedInputStream(java.io.InputStream,java.util.zip.Checksum)", "type": "constructor", "idx": 45693, "Desc": "creates an input stream using the specified checksum ."}{"node_name": "CheckedOutputStream(java.io.OutputStream,java.util.zip.Checksum)", "type": "constructor", "idx": 45705, "Desc": "creates an output stream with the specified checksum ."}{"node_name": "CRC32()", "type": "constructor", "idx": 45729, "Desc": "creates a new crc32 object ."}{"node_name": "CRC32C()", "type": "constructor", "idx": 45741, "Desc": "creates a new crc32c object ."}{"node_name": "DataFormatException()", "type": "constructor", "idx": 45753, "Desc": "constructs a dataformatexception with no detail message ."}{"node_name": "DataFormatException(java.lang.String)", "type": "constructor", "idx": 45754, "Desc": "constructs a dataformatexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "Deflater(int,boolean)", "type": "constructor", "idx": 45768, "Desc": "creates a new compressor using the specified compression level . if ' nowrap ' is true then the zlib header and checksum fields will not be used in order to support the compression format used in both gzip and pkzip ."}{"node_name": "Deflater(int)", "type": "constructor", "idx": 45771, "Desc": "creates a new compressor using the specified compression level . compressed data will be generated in zlib format ."}{"node_name": "Deflater()", "type": "constructor", "idx": 45773, "Desc": "creates a new compressor with the default compression level . compressed data will be generated in zlib format ."}{"node_name": "DeflaterInputStream(java.io.InputStream)", "type": "constructor", "idx": 45823, "Desc": "creates a new input stream with a default compressor and buffer size ."}{"node_name": "DeflaterInputStream(java.io.InputStream,java.util.zip.Deflater)", "type": "constructor", "idx": 45825, "Desc": "creates a new input stream with the specified compressor and a default buffer size ."}{"node_name": "DeflaterInputStream(java.io.InputStream,java.util.zip.Deflater,int)", "type": "constructor", "idx": 45828, "Desc": "creates a new input stream with the specified compressor and buffer size ."}{"node_name": "DeflaterOutputStream(java.io.OutputStream,java.util.zip.Deflater,int,boolean)", "type": "constructor", "idx": 45848, "Desc": "creates a new output stream with the specified compressor , buffer size and flush mode ."}{"node_name": "DeflaterOutputStream(java.io.OutputStream,java.util.zip.Deflater,int)", "type": "constructor", "idx": 45853, "Desc": "creates a new output stream with the specified compressor and buffer size . the new output stream instance is created as if by invoking the 4-argument constructor deflateroutputstream ( out , def , size , false ) ."}{"node_name": "DeflaterOutputStream(java.io.OutputStream,java.util.zip.Deflater,boolean)", "type": "constructor", "idx": 45857, "Desc": "creates a new output stream with the specified compressor , flush mode and a default buffer size ."}{"node_name": "DeflaterOutputStream(java.io.OutputStream,java.util.zip.Deflater)", "type": "constructor", "idx": 45861, "Desc": "creates a new output stream with the specified compressor and a default buffer size . the new output stream instance is created as if by invoking the 3-argument constructor deflateroutputstream ( out , def , false ) ."}{"node_name": "DeflaterOutputStream(java.io.OutputStream,boolean)", "type": "constructor", "idx": 45864, "Desc": "creates a new output stream with a default compressor , a default buffer size and the specified flush mode ."}{"node_name": "DeflaterOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 45867, "Desc": "creates a new output stream with a default compressor and buffer size . the new output stream instance is created as if by invoking the 2-argument constructor deflateroutputstream ( out , false ) ."}{"node_name": "GZIPInputStream(java.io.InputStream,int)", "type": "constructor", "idx": 45883, "Desc": "creates a new input stream with the specified buffer size ."}{"node_name": "GZIPInputStream(java.io.InputStream)", "type": "constructor", "idx": 45886, "Desc": "creates a new input stream with a default buffer size ."}{"node_name": "GZIPOutputStream(java.io.OutputStream,int)", "type": "constructor", "idx": 45895, "Desc": "creates a new output stream with the specified buffer size . the new output stream instance is created as if by invoking the 3-argument constructor gzipoutputstream ( out , size , false ) ."}{"node_name": "GZIPOutputStream(java.io.OutputStream,int,boolean)", "type": "constructor", "idx": 45898, "Desc": "creates a new output stream with the specified buffer size and flush mode ."}{"node_name": "GZIPOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 45902, "Desc": "creates a new output stream with a default buffer size . the new output stream instance is created as if by invoking the 2-argument constructor gzipoutputstream ( out , false ) ."}{"node_name": "GZIPOutputStream(java.io.OutputStream,boolean)", "type": "constructor", "idx": 45904, "Desc": "creates a new output stream with a default buffer size and the specified flush mode ."}{"node_name": "Inflater(boolean)", "type": "constructor", "idx": 45913, "Desc": "creates a new decompressor . if the parameter ' nowrap ' is true then the zlib header and checksum fields will not be used . this provides compatibility with the compression format used by both gzip and pkzip . note : when using the ' nowrap ' option it is also necessary to provide an extra \" dummy \" byte as input . this is required by the zlib native library in order to support certain optimizations ."}{"node_name": "Inflater()", "type": "constructor", "idx": 45915, "Desc": "creates a new decompressor ."}{"node_name": "InflaterInputStream(java.io.InputStream,java.util.zip.Inflater,int)", "type": "constructor", "idx": 45955, "Desc": "creates a new input stream with the specified decompressor and buffer size ."}{"node_name": "InflaterInputStream(java.io.InputStream,java.util.zip.Inflater)", "type": "constructor", "idx": 45959, "Desc": "creates a new input stream with the specified decompressor and a default buffer size ."}{"node_name": "InflaterInputStream(java.io.InputStream)", "type": "constructor", "idx": 45962, "Desc": "creates a new input stream with a default decompressor and buffer size ."}{"node_name": "InflaterOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 45981, "Desc": "creates a new output stream with a default decompressor and buffer size ."}{"node_name": "InflaterOutputStream(java.io.OutputStream,java.util.zip.Inflater)", "type": "constructor", "idx": 45983, "Desc": "creates a new output stream with the specified decompressor and a default buffer size ."}{"node_name": "InflaterOutputStream(java.io.OutputStream,java.util.zip.Inflater,int)", "type": "constructor", "idx": 45986, "Desc": "creates a new output stream with the specified decompressor and buffer size ."}{"node_name": "ZipEntry(java.lang.String)", "type": "constructor", "idx": 46042, "Desc": "creates a new zip entry with the specified name ."}{"node_name": "ZipEntry(java.util.zip.ZipEntry)", "type": "constructor", "idx": 46044, "Desc": "creates a new zip entry with fields taken from the specified zip entry ."}{"node_name": "ZipError(java.lang.String)", "type": "constructor", "idx": 46085, "Desc": "constructs a ziperror with the given detail message ."}{"node_name": "ZipException()", "type": "constructor", "idx": 46088, "Desc": "constructs a zipexception with null as its error detail message ."}{"node_name": "ZipException(java.lang.String)", "type": "constructor", "idx": 46089, "Desc": "constructs a zipexception with the specified detail message ."}{"node_name": "ZipFile(java.lang.String)", "type": "constructor", "idx": 46134, "Desc": "opens a zip file for reading . first , if there is a security manager , its checkread method is called with the name argument as its argument to ensure the read is allowed . the utf-8 charset is used to decode the entry names and comments ."}{"node_name": "ZipFile(java.io.File,int)", "type": "constructor", "idx": 46136, "Desc": "opens a new zipfile to read from the specified file object in the specified mode . the mode argument must be either open_read or open_read | open_delete . first , if there is a security manager , its checkread method is called with the name argument as its argument to ensure the read is allowed . the utf-8 charset is used to decode the entry names and comments"}{"node_name": "ZipFile(java.io.File)", "type": "constructor", "idx": 46139, "Desc": "opens a zip file for reading given the specified file object . the utf-8 charset is used to decode the entry names and comments ."}{"node_name": "ZipFile(java.io.File,int,java.nio.charset.Charset)", "type": "constructor", "idx": 46141, "Desc": "opens a new zipfile to read from the specified file object in the specified mode . the mode argument must be either open_read or open_read | open_delete . first , if there is a security manager , its checkread method is called with the name argument as its argument to ensure the read is allowed ."}{"node_name": "ZipFile(java.lang.String,java.nio.charset.Charset)", "type": "constructor", "idx": 46145, "Desc": "opens a zip file for reading . first , if there is a security manager , its checkread method is called with the name argument as its argument to ensure the read is allowed ."}{"node_name": "ZipFile(java.io.File,java.nio.charset.Charset)", "type": "constructor", "idx": 46148, "Desc": "opens a zip file for reading given the specified file object ."}{"node_name": "ZipInputStream(java.io.InputStream)", "type": "constructor", "idx": 46202, "Desc": "creates a new zip input stream . the utf-8 charset is used to decode the entry names ."}{"node_name": "ZipInputStream(java.io.InputStream,java.nio.charset.Charset)", "type": "constructor", "idx": 46204, "Desc": "creates a new zip input stream ."}{"node_name": "ZipOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 46262, "Desc": "creates a new zip output stream . the utf-8 charset is used to encode the entry names and comments ."}{"node_name": "ZipOutputStream(java.io.OutputStream,java.nio.charset.Charset)", "type": "constructor", "idx": 46264, "Desc": "creates a new zip output stream ."}{"node_name": "AccessibilityProvider()", "type": "constructor", "idx": 46283, "Desc": "initializes a new accessibility provider ."}{"node_name": "AccessibleAttributeSequence(int,int,javax.swing.text.AttributeSet)", "type": "constructor", "idx": 46303, "Desc": "constructs an accessibleattributesequence with the given parameters ."}{"node_name": "AccessibleBundle()", "type": "constructor", "idx": 46309, "Desc": "construct an accessiblebundle ."}{"node_name": "AccessibleContext()", "type": "constructor", "idx": 46385, "Desc": ""}{"node_name": "AccessibleHyperlink()", "type": "constructor", "idx": 46478, "Desc": ""}{"node_name": "AccessibleRelation(java.lang.String)", "type": "constructor", "idx": 46532, "Desc": "create a new accessiblerelation using the given locale independent key . the key string should be a locale independent key for the relation . it is not intended to be used as the actual string to display to the user . to get the localized string , use accessiblebundle.todisplaystring() ."}{"node_name": "AccessibleRelation(java.lang.String,java.lang.Object)", "type": "constructor", "idx": 46534, "Desc": "creates a new accessiblerelation using the given locale independent key . the key string should be a locale independent key for the relation . it is not intended to be used as the actual string to display to the user . to get the localized string , use accessiblebundle.todisplaystring() ."}{"node_name": "AccessibleRelation(java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 46537, "Desc": "creates a new accessiblerelation using the given locale independent key . the key string should be a locale independent key for the relation . it is not intended to be used as the actual string to display to the user . to get the localized string , use accessiblebundle.todisplaystring() ."}{"node_name": "AccessibleRelationSet()", "type": "constructor", "idx": 46548, "Desc": "creates a new empty relation set ."}{"node_name": "AccessibleRelationSet(javax.accessibility.AccessibleRelation[])", "type": "constructor", "idx": 46549, "Desc": "creates a new relation with the initial set of relations contained in the array of relations passed in . duplicate entries are ignored ."}{"node_name": "AccessibleRole(java.lang.String)", "type": "constructor", "idx": 46630, "Desc": "creates a new accessiblerole using the given locale independent key . this should not be a public method . instead , it is used to create the constants in this file to make it a strongly typed enumeration . subclasses of this class should enforce similar policy . the key string should be a locale independent key for the role . it is not intended to be used as the actual string to display to the user . to get the localized string , use accessiblebundle.todisplaystring() ."}{"node_name": "AccessibleState(java.lang.String)", "type": "constructor", "idx": 46674, "Desc": "creates a new accessiblestate using the given locale independent key . this should not be a public method . instead , it is used to create the constants in this file to make it a strongly typed enumeration . subclasses of this class should enforce similar policy . the key string should be a locale independent key for the state . it is not intended to be used as the actual string to display to the user . to get the localized string , use accessiblebundle.todisplaystring() ."}{"node_name": "AccessibleStateSet()", "type": "constructor", "idx": 46678, "Desc": "creates a new empty state set ."}{"node_name": "AccessibleStateSet(javax.accessibility.AccessibleState[])", "type": "constructor", "idx": 46679, "Desc": "creates a new state with the initial set of states contained in the array of states passed in . duplicate entries are ignored ."}{"node_name": "AccessibleTextSequence(int,int,java.lang.String)", "type": "constructor", "idx": 46776, "Desc": "constructs an accessibletextsequence with the given parameters ."}{"node_name": "AbstractProcessor()", "type": "constructor", "idx": 46788, "Desc": "constructor for subclasses to call ."}{"node_name": "FilerException(java.lang.String)", "type": "constructor", "idx": 46826, "Desc": "constructs an exception with the specified detail message ."}{"node_name": "AEADBadTagException()", "type": "constructor", "idx": 46887, "Desc": "constructs a aeadbadtagexception with no detail message ."}{"node_name": "AEADBadTagException(java.lang.String)", "type": "constructor", "idx": 46888, "Desc": "constructs a aeadbadtagexception with the specified detail message ."}{"node_name": "BadPaddingException()", "type": "constructor", "idx": 46891, "Desc": "constructs a badpaddingexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "BadPaddingException(java.lang.String)", "type": "constructor", "idx": 46892, "Desc": "constructs a badpaddingexception with the specified detail message ."}{"node_name": "Cipher(javax.crypto.CipherSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 46902, "Desc": "creates a cipher object ."}{"node_name": "CipherInputStream(java.io.InputStream,javax.crypto.Cipher)", "type": "constructor", "idx": 47018, "Desc": "constructs a cipherinputstream from an inputstream and a cipher . note : if the specified input stream or cipher is null , a nullpointerexception may be thrown later when they are used ."}{"node_name": "CipherInputStream(java.io.InputStream)", "type": "constructor", "idx": 47021, "Desc": "constructs a cipherinputstream from an inputstream without specifying a cipher . this has the effect of constructing a cipherinputstream using a nullcipher . note : if the specified input stream is null , a nullpointerexception may be thrown later when it is used ."}{"node_name": "CipherOutputStream(java.io.OutputStream,javax.crypto.Cipher)", "type": "constructor", "idx": 47036, "Desc": "constructs a cipheroutputstream from an outputstream and a cipher . note : if the specified output stream or cipher is null , a nullpointerexception may be thrown later when they are used ."}{"node_name": "CipherOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 47039, "Desc": "constructs a cipheroutputstream from an outputstream without specifying a cipher . this has the effect of constructing a cipheroutputstream using a nullcipher . note : if the specified output stream is null , a nullpointerexception may be thrown later when it is used ."}{"node_name": "CipherSpi()", "type": "constructor", "idx": 47052, "Desc": ""}{"node_name": "EncryptedPrivateKeyInfo(byte[])", "type": "constructor", "idx": 47117, "Desc": "constructs ( i.e. , parses ) an encryptedprivatekeyinfo from its asn.1 encoding ."}{"node_name": "EncryptedPrivateKeyInfo(java.lang.String,byte[])", "type": "constructor", "idx": 47119, "Desc": "constructs an encryptedprivatekeyinfo from the encryption algorithm name and the encrypted data . note : <init>(java.lang.String,byte[]) will use null as the value of the algorithm parameters . if the encryption algorithm has parameters whose value is not null , a different constructor , e.g. encryptedprivatekeyinfo ( algorithmparameters , byte [ ]) , should be used ."}{"node_name": "EncryptedPrivateKeyInfo(java.security.AlgorithmParameters,byte[])", "type": "constructor", "idx": 47122, "Desc": "constructs an encryptedprivatekeyinfo from the encryption algorithm parameters and the encrypted data ."}{"node_name": "ExemptionMechanism(javax.crypto.ExemptionMechanismSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 47140, "Desc": "creates a exemptionmechanism object ."}{"node_name": "ExemptionMechanismException()", "type": "constructor", "idx": 47173, "Desc": "constructs a exemptionmechanismexception with no detailed message . ( a detailed message is a string that describes this particular exception . )"}{"node_name": "ExemptionMechanismException(java.lang.String)", "type": "constructor", "idx": 47174, "Desc": "constructs a exemptionmechanismexception with the specified detailed message . ( a detailed message is a string that describes this particular exception . )"}{"node_name": "ExemptionMechanismSpi()", "type": "constructor", "idx": 47177, "Desc": ""}{"node_name": "IllegalBlockSizeException()", "type": "constructor", "idx": 47193, "Desc": "constructs an illegalblocksizeexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "IllegalBlockSizeException(java.lang.String)", "type": "constructor", "idx": 47194, "Desc": "constructs an illegalblocksizeexception with the specified detail message ."}{"node_name": "KeyAgreement(javax.crypto.KeyAgreementSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 47207, "Desc": "creates a keyagreement object ."}{"node_name": "KeyAgreementSpi()", "type": "constructor", "idx": 47243, "Desc": ""}{"node_name": "KeyGenerator(javax.crypto.KeyGeneratorSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 47261, "Desc": "creates a keygenerator object ."}{"node_name": "KeyGeneratorSpi()", "type": "constructor", "idx": 47289, "Desc": ""}{"node_name": "Mac(javax.crypto.MacSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 47300, "Desc": "creates a mac object ."}{"node_name": "MacSpi()", "type": "constructor", "idx": 47339, "Desc": ""}{"node_name": "NoSuchPaddingException()", "type": "constructor", "idx": 47356, "Desc": "constructs a nosuchpaddingexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "NoSuchPaddingException(java.lang.String)", "type": "constructor", "idx": 47357, "Desc": "constructs a nosuchpaddingexception with the specified detail message ."}{"node_name": "NullCipher()", "type": "constructor", "idx": 47360, "Desc": "creates a nullcipher object ."}{"node_name": "SealedObject(java.io.Serializable,javax.crypto.Cipher)", "type": "constructor", "idx": 47363, "Desc": "constructs a sealedobject from any serializable object . the given object is serialized , and its serialized contents are encrypted using the given cipher , which must be fully initialized . any algorithm parameters that may be used in the encryption operation are stored inside of the new sealedobject ."}{"node_name": "SealedObject(javax.crypto.SealedObject)", "type": "constructor", "idx": 47366, "Desc": "constructs a sealedobject object from the passed-in sealedobject ."}{"node_name": "SecretKeyFactory(javax.crypto.SecretKeyFactorySpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 47378, "Desc": "creates a secretkeyfactory object ."}{"node_name": "SecretKeyFactorySpi()", "type": "constructor", "idx": 47400, "Desc": ""}{"node_name": "ShortBufferException()", "type": "constructor", "idx": 47409, "Desc": "constructs a shortbufferexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "ShortBufferException(java.lang.String)", "type": "constructor", "idx": 47410, "Desc": "constructs a shortbufferexception with the specified detail message ."}{"node_name": "ChaCha20ParameterSpec(byte[],int)", "type": "constructor", "idx": 47413, "Desc": "constructs a parameter set for chacha20 from the given nonce and counter ."}{"node_name": "DESedeKeySpec(byte[])", "type": "constructor", "idx": 47420, "Desc": "creates a desedekeyspec object using the first 24 bytes in key as the key material for the des-ede key . the bytes that constitute the des-ede key are those between key [ 0 ] and key [ 23 ] inclusive"}{"node_name": "DESedeKeySpec(byte[],int)", "type": "constructor", "idx": 47422, "Desc": "creates a desedekeyspec object using the first 24 bytes in key , beginning at offset inclusive , as the key material for the des-ede key . the bytes that constitute the des-ede key are those between key [ offset ] and key [ offset+23 ] inclusive ."}{"node_name": "DESKeySpec(byte[])", "type": "constructor", "idx": 47431, "Desc": "creates a deskeyspec object using the first 8 bytes in key as the key material for the des key . the bytes that constitute the des key are those between key [ 0 ] and key [ 7 ] inclusive ."}{"node_name": "DESKeySpec(byte[],int)", "type": "constructor", "idx": 47433, "Desc": "creates a deskeyspec object using the first 8 bytes in key , beginning at offset inclusive , as the key material for the des key . the bytes that constitute the des key are those between key [ offset ] and key [ offset+7 ] inclusive ."}{"node_name": "DHGenParameterSpec(int,int)", "type": "constructor", "idx": 47444, "Desc": "constructs a parameter set for the generation of diffie-hellman ( system ) parameters . the constructed parameter set can be used to initialize an algorithmparametergenerator object for the generation of diffie-hellman parameters ."}{"node_name": "DHParameterSpec(java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 47450, "Desc": "constructs a parameter set for diffie-hellman , using a prime modulus p and a base generator g ."}{"node_name": "DHParameterSpec(java.math.BigInteger,java.math.BigInteger,int)", "type": "constructor", "idx": 47453, "Desc": "constructs a parameter set for diffie-hellman , using a prime modulus p , a base generator g , and the size in bits , l , of the random exponent ( private value ) ."}{"node_name": "DHPrivateKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 47461, "Desc": "constructor that takes a private value x , a prime modulus p , and a base generator g ."}{"node_name": "DHPublicKeySpec(java.math.BigInteger,java.math.BigInteger,java.math.BigInteger)", "type": "constructor", "idx": 47469, "Desc": "constructor that takes a public value y , a prime modulus p , and a base generator g ."}{"node_name": "GCMParameterSpec(int,byte[])", "type": "constructor", "idx": 47477, "Desc": "constructs a gcmparameterspec using the specified authentication tag bit-length and iv buffer ."}{"node_name": "GCMParameterSpec(int,byte[],int,int)", "type": "constructor", "idx": 47480, "Desc": "constructs a gcmparameterspec object using the specified authentication tag bit-length and a subset of the specified buffer as the iv ."}{"node_name": "IvParameterSpec(byte[])", "type": "constructor", "idx": 47488, "Desc": "creates an ivparameterspec object using the bytes in iv as the iv ."}{"node_name": "IvParameterSpec(byte[],int,int)", "type": "constructor", "idx": 47490, "Desc": "creates an ivparameterspec object using the first len bytes in iv , beginning at offset inclusive , as the iv . the bytes that constitute the iv are those between iv [ offset ] and iv [ offset+ len-1 ] inclusive ."}{"node_name": "OAEPParameterSpec(java.lang.String,java.lang.String,java.security.spec.AlgorithmParameterSpec,javax.crypto.spec.PSource)", "type": "constructor", "idx": 47497, "Desc": "constructs a parameter set for oaep padding as defined in the pkcs #1 standard using the specified message digest algorithm mdname , mask generation function algorithm mgfname , parameters for the mask generation function mgfspec , and source of the encoding input p psrc ."}{"node_name": "PBEKeySpec(char[])", "type": "constructor", "idx": 47507, "Desc": "constructor that takes a password . an empty char [ ] is used if null is specified . note : password is cloned before it is stored in the new pbekeyspec object ."}{"node_name": "PBEKeySpec(char[],byte[],int,int)", "type": "constructor", "idx": 47509, "Desc": "constructor that takes a password , salt , iteration count , and to-be-derived key length for generating pbekey of variable-key-size pbe ciphers . an empty char [ ] is used if null is specified for password . note : the password and salt are cloned before they are stored in the new pbekeyspec object ."}{"node_name": "PBEKeySpec(char[],byte[],int)", "type": "constructor", "idx": 47514, "Desc": "constructor that takes a password , salt , iteration count for generating pbekey of fixed-key-size pbe ciphers . an empty char [ ] is used if null is specified for password . note : the password and salt are cloned before they are stored in the new pbekeyspec object ."}{"node_name": "PBEParameterSpec(byte[],int)", "type": "constructor", "idx": 47524, "Desc": "constructs a parameter set for password-based encryption as defined in the pkcs #5 standard ."}{"node_name": "PBEParameterSpec(byte[],int,java.security.spec.AlgorithmParameterSpec)", "type": "constructor", "idx": 47527, "Desc": "constructs a parameter set for password-based encryption as defined in the pkcs #5 standard ."}{"node_name": "PSource(java.lang.String)", "type": "constructor", "idx": 47535, "Desc": "constructs a source of the encoding input p for oaep padding as defined in the pkcs #1 standard using the specified psource algorithm ."}{"node_name": "PSpecified(byte[])", "type": "constructor", "idx": 47540, "Desc": "constructs the source explicitly with the specified value p as the encoding input p . note :"}{"node_name": "RC2ParameterSpec(int)", "type": "constructor", "idx": 47544, "Desc": "constructs a parameter set for rc2 from the given effective key size ( in bits ) ."}{"node_name": "RC2ParameterSpec(int,byte[])", "type": "constructor", "idx": 47546, "Desc": "constructs a parameter set for rc2 from the given effective key size ( in bits ) and an 8-b yte iv . the bytes that constitute the iv are those between iv [ 0 ] and iv [ 7 ] inclusive ."}{"node_name": "RC2ParameterSpec(int,byte[],int)", "type": "constructor", "idx": 47549, "Desc": "constructs a parameter set for rc2 from the given effective key size ( in bits ) and iv . the iv is taken from iv , starting at offset inclusive . the bytes that constitute the iv are those between iv [ offset ] and iv [ offset+7 ] inclusive ."}{"node_name": "RC5ParameterSpec(int,int,int)", "type": "constructor", "idx": 47559, "Desc": "constructs a parameter set for rc5 from the given version , number of rounds and word size ( in bits ) ."}{"node_name": "RC5ParameterSpec(int,int,int,byte[])", "type": "constructor", "idx": 47563, "Desc": "constructs a parameter set for rc5 from the given version , number of rounds , word size ( in bits ) , and iv . note that the size of the iv ( block size ) must be twice the word size . the bytes that constitute the iv are those between iv [ 0 ] and iv [ 2* ( wordsize / 8) -1 ] inclusive ."}{"node_name": "RC5ParameterSpec(int,int,int,byte[],int)", "type": "constructor", "idx": 47568, "Desc": "constructs a parameter set for rc5 from the given version , number of rounds , word size ( in bits ) , and iv . the iv is taken from iv , starting at offset inclusive . note that the size of the iv ( block size ) , starting at offset inclusive , must be twice the word size . the bytes that constitute the iv are those between iv [ offset ] and iv [ offset+2* ( wordsize / 8) -1 ] inclusive ."}{"node_name": "SecretKeySpec(byte[],java.lang.String)", "type": "constructor", "idx": 47582, "Desc": "constructs a secret key from the given byte array . <init>(byte[],java.lang.String) does not check if the given bytes indeed specify a secret key of the specified algorithm . for example , if the algorithm is des , <init>(byte[],java.lang.String) does not check if key is 8 bytes long , and also does not check for weak or semi-weak keys . in order for those checks to be performed , an algorithm-specific key specification class ( in this case : deskeyspec ) should be used ."}{"node_name": "SecretKeySpec(byte[],int,int,java.lang.String)", "type": "constructor", "idx": 47585, "Desc": "constructs a secret key from the given byte array , using the first len bytes of key , starting at offset inclusive . the bytes that constitute the secret key are those between key [ offset ] and key [ offset+ len-1 ] inclusive . <init>(byte[],int,int,java.lang.String) does not check if the given bytes indeed specify a secret key of the specified algorithm . for example , if the algorithm is des , <init>(byte[],int,int,java.lang.String) does not check if key is 8 bytes long , and also does not check for weak or semi-weak keys . in order for those checks to be performed , an algorithm-specific key specification class ( in this case : deskeyspec ) must be used ."}{"node_name": "IIOException(java.lang.String)", "type": "constructor", "idx": 47700, "Desc": "constructs an iioexception with a given message string . no underlying cause is set ; getcause will return null ."}{"node_name": "IIOException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 47702, "Desc": "constructs an iioexception with a given message string and a throwable that was its underlying cause ."}{"node_name": "IIOImage(java.awt.image.RenderedImage,java.util.List,javax.imageio.metadata.IIOMetadata)", "type": "constructor", "idx": 47710, "Desc": "constructs an iioimage containing a renderedimage , and thumbnails and metadata associated with it . all parameters are stored by reference . the thumbnails argument must either be null or contain only bufferedimage objects ."}{"node_name": "IIOImage(java.awt.image.Raster,java.util.List,javax.imageio.metadata.IIOMetadata)", "type": "constructor", "idx": 47714, "Desc": "constructs an iioimage containing a raster , and thumbnails and metadata associated with it . all parameters are stored by reference ."}{"node_name": "IIOParam()", "type": "constructor", "idx": 47745, "Desc": "protected constructor may be called only by subclasses ."}{"node_name": "ImageReader(javax.imageio.spi.ImageReaderSpi)", "type": "constructor", "idx": 47850, "Desc": "constructs an imagereader and sets its originatingprovider field to the supplied value . subclasses that make use of extensions should provide a constructor with signature ( imagereaderspi , object ) in order to retrieve the extension object . if the extension object is unsuitable , an illegalargumentexception should be thrown ."}{"node_name": "ImageReadParam()", "type": "constructor", "idx": 48054, "Desc": "constructs an imagereadparam ."}{"node_name": "ImageTypeSpecifier(java.awt.image.ColorModel,java.awt.image.SampleModel)", "type": "constructor", "idx": 48082, "Desc": "constructs an imagetypespecifier directly from a colormodel and a samplemodel . it is the caller's responsibility to supply compatible parameters ."}{"node_name": "ImageTypeSpecifier(java.awt.image.RenderedImage)", "type": "constructor", "idx": 48085, "Desc": "constructs an imagetypespecifier from a renderedimage . if a bufferedimage is being used , one of the factory methods createfromrenderedimage or createfrombufferedimagetype should be used instead in order to get a more accurate result ."}{"node_name": "ImageWriteParam()", "type": "constructor", "idx": 48166, "Desc": "constructs an empty imagewriteparam . it is up to the subclass to set up the instance variables properly ."}{"node_name": "ImageWriteParam(java.util.Locale)", "type": "constructor", "idx": 48167, "Desc": "constructs an imagewriteparam set to use a given locale ."}{"node_name": "ImageWriter(javax.imageio.spi.ImageWriterSpi)", "type": "constructor", "idx": 48216, "Desc": "constructs an imagewriter and sets its originatingprovider instance variable to the supplied value . subclasses that make use of extensions should provide a constructor with signature ( imagewriterspi , object ) in order to retrieve the extension object . if the extension object is unsuitable , an illegalargumentexception should be thrown ."}{"node_name": "IIOInvalidTreeException(java.lang.String,org.w3c.dom.Node)", "type": "constructor", "idx": 48345, "Desc": "constructs an iioinvalidtreeexception with a message string and a reference to the node that caused the parsing error ."}{"node_name": "IIOInvalidTreeException(java.lang.String,java.lang.Throwable,org.w3c.dom.Node)", "type": "constructor", "idx": 48348, "Desc": "constructs an iioinvalidtreeexception with a message string , a reference to an exception that caused this exception , and a reference to the node that caused the parsing error ."}{"node_name": "IIOMetadata()", "type": "constructor", "idx": 48361, "Desc": "constructs an empty iiometadata object . the subclass is responsible for supplying values for all protected instance variables that will allow any non-overridden default implementations of methods to satisfy their contracts . for example , extrametadataformatnames should not have length 0 ."}{"node_name": "IIOMetadata(boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[])", "type": "constructor", "idx": 48362, "Desc": "constructs an iiometadata object with the given format names and format class names , as well as a boolean indicating whether the standard format is supported . <init>(boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[]) does not attempt to check the class names for validity . invalid class names may cause exceptions in subsequent calls to getmetadataformat ."}{"node_name": "IIOMetadataFormatImpl(java.lang.String,int)", "type": "constructor", "idx": 48491, "Desc": "constructs a blank iiometadataformatimpl instance , with a given root element name and child policy ( other than child_policy_repeat ) . additional elements , and their attributes and object reference information may be added using the various add methods ."}{"node_name": "IIOMetadataFormatImpl(java.lang.String,int,int)", "type": "constructor", "idx": 48494, "Desc": "constructs a blank iiometadataformatimpl instance , with a given root element name and a child policy of child_policy_repeat . additional elements , and their attributes and object reference information may be added using the various add methods ."}{"node_name": "IIOMetadataNode()", "type": "constructor", "idx": 48588, "Desc": "constructs an empty iiometadatanode ."}{"node_name": "IIOMetadataNode(java.lang.String)", "type": "constructor", "idx": 48589, "Desc": "constructs an iiometadatanode with a given node name ."}{"node_name": "BMPImageWriteParam(java.util.Locale)", "type": "constructor", "idx": 48688, "Desc": "constructs a bmpimagewriteparam set to use a given locale and with default values for all parameters ."}{"node_name": "BMPImageWriteParam()", "type": "constructor", "idx": 48690, "Desc": "constructs an bmpimagewriteparam object with default values for all parameters and a null locale ."}{"node_name": "JPEGHuffmanTable(short[],short[])", "type": "constructor", "idx": 48699, "Desc": "creates a huffman table and initializes it . the input arrays are copied . the arrays must describe a possible huffman table . for example , 3 codes cannot be expressed with a single bit ."}{"node_name": "JPEGImageReadParam()", "type": "constructor", "idx": 48706, "Desc": "constructs a jpegimagereadparam ."}{"node_name": "JPEGImageWriteParam(java.util.Locale)", "type": "constructor", "idx": 48717, "Desc": "constructs a jpegimagewriteparam . tiling is not supported . progressive encoding is supported . the default progressive mode is mode_disabled . a single form of compression , named \" jpeg \" , is supported . the default compression quality is 0.75 ."}{"node_name": "JPEGQTable(int[])", "type": "constructor", "idx": 48738, "Desc": "constructs a quantization table from the argument , which must contain 64 elements in natural order ( not zig-zag order ) . a copy is made of the input array ."}{"node_name": "TIFFDirectory(javax.imageio.plugins.tiff.TIFFTagSet[],javax.imageio.plugins.tiff.TIFFTag)", "type": "constructor", "idx": 49136, "Desc": "constructs a tiffdirectory which is aware of a given group of tifftagsets . an optional parent tifftag may also be specified ."}{"node_name": "TIFFField(javax.imageio.plugins.tiff.TIFFTag,int,int,java.lang.Object)", "type": "constructor", "idx": 49163, "Desc": "constructs a tifffield with arbitrary data . the type parameter must be a value for which tag.isdatatypeok() returns true . the data parameter must be an array of a java type appropriate for the type of the tiff field . note that the value ( data ) of the tifffield will always be the actual field value regardless of the number of bytes required for that value . this is the case despite the fact that the tiff ifd entry corresponding to the field may actually contain the offset to the value of the field rather than the value itself ( the latter occurring if and only if the value fits into 4 bytes ) . in other words , the value of the field will already have been read from the tiff stream . ( an exception to this case may occur when the field represents the contents of a non-baseline ifd . in that case the data will be a long [ ] containing the offset to the ifd and the tiffdirectory returned by getdirectory() will be its contents . )"}{"node_name": "TIFFField(javax.imageio.plugins.tiff.TIFFTag,int,int)", "type": "constructor", "idx": 49168, "Desc": "constructs a data array using createarrayfortype() and invokes tifffield ( tifftag , int , int , object ) with the supplied parameters and the created array ."}{"node_name": "TIFFField(javax.imageio.plugins.tiff.TIFFTag,long)", "type": "constructor", "idx": 49172, "Desc": "constructs a tifffield with a single non-negative integral value . the field will have type tiff_short if value is in [ 0 , 0xffff ] , and type tiff_long if value is in [ 0x10000 , 0xffffffff ] . the count of the field will be unity ."}{"node_name": "TIFFField(javax.imageio.plugins.tiff.TIFFTag,int,long,javax.imageio.plugins.tiff.TIFFDirectory)", "type": "constructor", "idx": 49175, "Desc": "constructs a tifffield with an ifd offset and contents . the offset will be stored as the data of this field as long [ ] { offset} . the directory will not be cloned . the count of the field will be unity ."}{"node_name": "TIFFImageReadParam()", "type": "constructor", "idx": 49226, "Desc": "constructs a tiffimagereadparam . tags defined by the tifftagsets baselinetifftagset , faxtifftagset , exifparenttifftagset , and geotifftagset will be supported ."}{"node_name": "TIFFTag(java.lang.String,int,int,int)", "type": "constructor", "idx": 49252, "Desc": "constructs a tifftag with a given name , tag number , set of legal data types , and value count . a negative value count signifies that either an arbitrary number of values is legal or the required count is determined by the values of other fields in the ifd . a non-negative count specifies the number of values which an associated field must contain . the tag will have no associated tifftagset . if there are mnemonic names to be associated with the legal data values for the tag , addvaluename() should be called on the new instance for each name . mnemonic names apply only to tags which have integral data type . see the documentation for getdatatypes() for an explanation of how the set of data types is to be converted into a bit mask ."}{"node_name": "TIFFTag(java.lang.String,int,javax.imageio.plugins.tiff.TIFFTagSet)", "type": "constructor", "idx": 49257, "Desc": "constructs a tifftag with a given name , tag number and tifftagset to which it refers . the legal data types are set to include tiff_long and tiff_ifd_pointer and the value count is unity . the tifftagset will represent the set of tifftags which appear in the ifd pointed to . a tifftag represents an ifd pointer if and only if tagset is non-null or the data type tiff_ifd_pointer is legal ."}{"node_name": "TIFFTag(java.lang.String,int,int)", "type": "constructor", "idx": 49261, "Desc": "constructs a tifftag with a given name , tag number , and set of legal data types . the value count of the tag will be undefined and it will have no associated tifftagset ."}{"node_name": "TIFFTagSet(java.util.List)", "type": "constructor", "idx": 49283, "Desc": "constructs a tifftagset , given a list of tifftag objects ."}{"node_name": "IIOServiceProvider(java.lang.String,java.lang.String)", "type": "constructor", "idx": 49297, "Desc": "constructs an iioserviceprovider with a given vendor name and version identifier ."}{"node_name": "IIOServiceProvider()", "type": "constructor", "idx": 49300, "Desc": "constructs a blank iioserviceprovider . it is up to the subclass to initialize instance variables and / or override method implementations in order to ensure that the getvendorname and getversion methods will return non-null values ."}{"node_name": "ImageInputStreamSpi()", "type": "constructor", "idx": 49313, "Desc": "constructs a blank imageinputstreamspi . it is up to the subclass to initialize instance variables and / or override method implementations in order to provide working versions of all methods ."}{"node_name": "ImageInputStreamSpi(java.lang.String,java.lang.String,java.lang.Class)", "type": "constructor", "idx": 49314, "Desc": "constructs an imageinputstreamspi with a given set of values ."}{"node_name": "ImageOutputStreamSpi()", "type": "constructor", "idx": 49329, "Desc": "constructs a blank imageoutputstreamspi . it is up to the subclass to initialize instance variables and / or override method implementations in order to provide working versions of all methods ."}{"node_name": "ImageOutputStreamSpi(java.lang.String,java.lang.String,java.lang.Class)", "type": "constructor", "idx": 49330, "Desc": "constructs an imageoutputstreamspi with a given set of values ."}{"node_name": "ImageReaderSpi()", "type": "constructor", "idx": 49346, "Desc": "constructs a blank imagereaderspi . it is up to the subclass to initialize instance variables and / or override method implementations in order to provide working versions of all methods ."}{"node_name": "ImageReaderSpi(java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],java.lang.String[],java.lang.String,java.lang.Class[],java.lang.String[],boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[])", "type": "constructor", "idx": 49347, "Desc": "constructs an imagereaderspi with a given set of values ."}{"node_name": "ImageReaderWriterSpi(java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],java.lang.String[],java.lang.String,boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[])", "type": "constructor", "idx": 49390, "Desc": "constructs an imagereaderwriterspi with a given set of values ."}{"node_name": "ImageReaderWriterSpi()", "type": "constructor", "idx": 49407, "Desc": "constructs a blank imagereaderwriterspi . it is up to the subclass to initialize instance variables and / or override method implementations in order to provide working versions of all methods ."}{"node_name": "ImageTranscoderSpi()", "type": "constructor", "idx": 49423, "Desc": "constructs a blank imagetranscoderspi . it is up to the subclass to initialize instance variables and / or override method implementations in order to provide working versions of all methods ."}{"node_name": "ImageTranscoderSpi(java.lang.String,java.lang.String)", "type": "constructor", "idx": 49424, "Desc": "constructs an imagetranscoderspi with a given set of values ."}{"node_name": "ImageWriterSpi()", "type": "constructor", "idx": 49433, "Desc": "constructs a blank imagewriterspi . it is up to the subclass to initialize instance variables and / or override method implementations in order to provide working versions of all methods ."}{"node_name": "ImageWriterSpi(java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],java.lang.String[],java.lang.String,java.lang.Class[],java.lang.String[],boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],boolean,java.lang.String,java.lang.String,java.lang.String[],java.lang.String[])", "type": "constructor", "idx": 49434, "Desc": "constructs an imagewriterspi with a given set of values ."}{"node_name": "ServiceRegistry(java.util.Iterator)", "type": "constructor", "idx": 49476, "Desc": "constructs a serviceregistry instance with a set of categories taken from the categories argument . the categories must all be members of the set of service types listed in the class specification ."}{"node_name": "FileCacheImageInputStream(java.io.InputStream,java.io.File)", "type": "constructor", "idx": 49519, "Desc": "constructs a filecacheimageinputstream that will read from a given inputstream . a temporary file is used as a cache . if cachedir is non-null and is a directory , the file will be created there . if it is null , the system-dependent default temporary-file directory will be used ( see the documentation for file.createtempfile for details ) ."}{"node_name": "FileCacheImageOutputStream(java.io.OutputStream,java.io.File)", "type": "constructor", "idx": 49527, "Desc": "constructs a filecacheimageoutputstream that will write to a given outputstream . a temporary file is used as a cache . if cachedir is non-null and is a directory , the file will be created there . if it is null , the system-dependent default temporary-file directory will be used ( see the documentation for file.createtempfile for details ) ."}{"node_name": "FileImageInputStream(java.io.File)", "type": "constructor", "idx": 49537, "Desc": "constructs a fileimageinputstream that will read from a given file . the file contents must not change between the time this object is constructed and the time of the last call to a read method ."}{"node_name": "FileImageInputStream(java.io.RandomAccessFile)", "type": "constructor", "idx": 49539, "Desc": "constructs a fileimageinputstream that will read from a given randomaccessfile . the file contents must not change between the time this object is constructed and the time of the last call to a read method ."}{"node_name": "FileImageOutputStream(java.io.File)", "type": "constructor", "idx": 49543, "Desc": "constructs a fileimageoutputstream that will write to a given file ."}{"node_name": "FileImageOutputStream(java.io.RandomAccessFile)", "type": "constructor", "idx": 49545, "Desc": "constructs a fileimageoutputstream that will write to a given randomaccessfile ."}{"node_name": "IIOByteBuffer(byte[],int,int)", "type": "constructor", "idx": 49550, "Desc": "constructs an iiobytebuffer that references a given byte array , offset , and length ."}{"node_name": "ImageInputStreamImpl()", "type": "constructor", "idx": 49649, "Desc": "constructs an imageinputstreamimpl ."}{"node_name": "ImageOutputStreamImpl()", "type": "constructor", "idx": 49731, "Desc": "constructs an imageoutputstreamimpl ."}{"node_name": "MemoryCacheImageInputStream(java.io.InputStream)", "type": "constructor", "idx": 49734, "Desc": "constructs a memorycacheimageinputstream that will read from a given inputstream ."}{"node_name": "MemoryCacheImageOutputStream(java.io.OutputStream)", "type": "constructor", "idx": 49741, "Desc": "constructs a memorycacheimageoutputstream that will write to a given outputstream ."}{"node_name": "UnknownAnnotationValueException(javax.lang.model.element.AnnotationValue,java.lang.Object)", "type": "constructor", "idx": 49971, "Desc": "creates a new unknownannotationvalueexception . the p parameter may be used to pass in an additional argument with information about the context in which the unknown annotation value was encountered ; for example , the visit methods of annotationvaluevisitor may pass in their additional parameter ."}{"node_name": "UnknownDirectiveException(javax.lang.model.element.ModuleElement.Directive,java.lang.Object)", "type": "constructor", "idx": 49977, "Desc": "creates a new unknownelementexception . the p parameter may be used to pass in an additional argument with information about the context in which the unknown directive was encountered ; for example , the visit methods of directivevisitor may pass in their additional parameter ."}{"node_name": "UnknownElementException(javax.lang.model.element.Element,java.lang.Object)", "type": "constructor", "idx": 49983, "Desc": "creates a new unknownelementexception . the p parameter may be used to pass in an additional argument with information about the context in which the unknown element was encountered ; for example , the visit methods of elementvisitor may pass in their additional parameter ."}{"node_name": "MirroredTypeException(javax.lang.model.type.TypeMirror)", "type": "constructor", "idx": 50027, "Desc": "constructs a new mirroredtypeexception for the specified type ."}{"node_name": "MirroredTypesException(java.util.List)", "type": "constructor", "idx": 50031, "Desc": "constructs a new mirroredtypesexception for the specified types ."}{"node_name": "UnknownTypeException(javax.lang.model.type.TypeMirror,java.lang.Object)", "type": "constructor", "idx": 50101, "Desc": "creates a new unknowntypeexception.the p parameter may be used to pass in an additional argument with information about the context in which the unknown type was encountered ; for example , the visit methods of typevisitor may pass in their additional parameter ."}{"node_name": "UnknownEntityException(java.lang.String)", "type": "constructor", "idx": 50110, "Desc": "creates a new unknownentityexception with the specified detail message ."}{"node_name": "AbstractAnnotationValueVisitor8()", "type": "constructor", "idx": 50123, "Desc": "constructor for concrete subclasses to call ."}{"node_name": "AbstractAnnotationValueVisitor9()", "type": "constructor", "idx": 50125, "Desc": "constructor for concrete subclasses to call ."}{"node_name": "AbstractElementVisitor8()", "type": "constructor", "idx": 50140, "Desc": "constructor for concrete subclasses to call ."}{"node_name": "AbstractElementVisitor9()", "type": "constructor", "idx": 50142, "Desc": "constructor for concrete subclasses to call ."}{"node_name": "AbstractTypeVisitor8()", "type": "constructor", "idx": 50166, "Desc": "constructor for concrete subclasses to call ."}{"node_name": "AbstractTypeVisitor9()", "type": "constructor", "idx": 50171, "Desc": "constructor for concrete subclasses to call ."}{"node_name": "ElementKindVisitor8()", "type": "constructor", "idx": 50270, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "ElementKindVisitor8(java.lang.Object)", "type": "constructor", "idx": 50271, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "ElementKindVisitor9()", "type": "constructor", "idx": 50274, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "ElementKindVisitor9(java.lang.Object)", "type": "constructor", "idx": 50275, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "ElementScanner8()", "type": "constructor", "idx": 50375, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "ElementScanner8(java.lang.Object)", "type": "constructor", "idx": 50376, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "ElementScanner9()", "type": "constructor", "idx": 50379, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "ElementScanner9(java.lang.Object)", "type": "constructor", "idx": 50380, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "SimpleAnnotationValueVisitor8()", "type": "constructor", "idx": 50431, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "SimpleAnnotationValueVisitor8(java.lang.Object)", "type": "constructor", "idx": 50432, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "SimpleAnnotationValueVisitor9()", "type": "constructor", "idx": 50435, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "SimpleAnnotationValueVisitor9(java.lang.Object)", "type": "constructor", "idx": 50436, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "SimpleElementVisitor8()", "type": "constructor", "idx": 50463, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "SimpleElementVisitor8(java.lang.Object)", "type": "constructor", "idx": 50464, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "SimpleElementVisitor9()", "type": "constructor", "idx": 50467, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "SimpleElementVisitor9(java.lang.Object)", "type": "constructor", "idx": 50468, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "SimpleTypeVisitor8()", "type": "constructor", "idx": 50510, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "SimpleTypeVisitor8(java.lang.Object)", "type": "constructor", "idx": 50511, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "SimpleTypeVisitor9()", "type": "constructor", "idx": 50517, "Desc": "constructor for concrete subclasses ; uses null for the default value ."}{"node_name": "SimpleTypeVisitor9(java.lang.Object)", "type": "constructor", "idx": 50518, "Desc": "constructor for concrete subclasses ; uses the argument for the default value ."}{"node_name": "TypeKindVisitor8()", "type": "constructor", "idx": 50568, "Desc": "constructor for concrete subclasses to call ; uses null for the default value ."}{"node_name": "TypeKindVisitor8(java.lang.Object)", "type": "constructor", "idx": 50569, "Desc": "constructor for concrete subclasses to call ; uses the argument for the default value ."}{"node_name": "TypeKindVisitor9()", "type": "constructor", "idx": 50575, "Desc": "constructor for concrete subclasses to call ; uses null for the default value ."}{"node_name": "TypeKindVisitor9(java.lang.Object)", "type": "constructor", "idx": 50576, "Desc": "constructor for concrete subclasses to call ; uses the argument for the default value ."}{"node_name": "Attribute(java.lang.String,java.lang.Object)", "type": "constructor", "idx": 50630, "Desc": "constructs an attribute object which associates the given attribute name with the given value ."}{"node_name": "AttributeChangeNotification(java.lang.Object,long,long,java.lang.String,java.lang.String,java.lang.String,java.lang.Object,java.lang.Object)", "type": "constructor", "idx": 50641, "Desc": "constructs an attribute change notification object . in addition to the information common to all notification , the caller must supply the name and type of the attribute , as well as its old and new values ."}{"node_name": "AttributeChangeNotificationFilter()", "type": "constructor", "idx": 50655, "Desc": ""}{"node_name": "AttributeList()", "type": "constructor", "idx": 50665, "Desc": "constructs an empty attributelist ."}{"node_name": "AttributeList(int)", "type": "constructor", "idx": 50666, "Desc": "constructs an empty attributelist with the initial capacity specified ."}{"node_name": "AttributeList(javax.management.AttributeList)", "type": "constructor", "idx": 50668, "Desc": "constructs an attributelist containing the elements of the attributelist specified , in the order in which they are returned by the attributelist's iterator . the attributelist instance has an initial capacity of 110% of the size of the attributelist specified ."}{"node_name": "AttributeList(java.util.List)", "type": "constructor", "idx": 50670, "Desc": "constructs an attributelist containing the elements of the list specified , in the order in which they are returned by the list's iterator ."}{"node_name": "AttributeNotFoundException()", "type": "constructor", "idx": 50700, "Desc": "default constructor ."}{"node_name": "AttributeNotFoundException(java.lang.String)", "type": "constructor", "idx": 50701, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "AttributeValueExp(java.lang.String)", "type": "constructor", "idx": 50704, "Desc": "creates a new attributevalueexp representing the specified object attribute , named attr ."}{"node_name": "BadAttributeValueExpException(java.lang.Object)", "type": "constructor", "idx": 50713, "Desc": "constructs a badattributevalueexpexception using the specified object to create the tostring() value ."}{"node_name": "BadBinaryOpValueExpException(javax.management.ValueExp)", "type": "constructor", "idx": 50717, "Desc": "constructs a badbinaryopvalueexpexception with the specified valueexp ."}{"node_name": "BadStringOperationException(java.lang.String)", "type": "constructor", "idx": 50722, "Desc": "constructs a badstringoperationexception with the specified detail message ."}{"node_name": "ImmutableDescriptor(java.lang.String[],java.lang.Object[])", "type": "constructor", "idx": 50769, "Desc": "construct a descriptor containing the given fields and values ."}{"node_name": "ImmutableDescriptor(java.lang.String...)", "type": "constructor", "idx": 50772, "Desc": "construct a descriptor containing the given fields . each string must be of the form fieldname=fieldvalue . the field name ends at the first = character ; for example if the string is a =b =c then the field name is a and its value is b=c ."}{"node_name": "ImmutableDescriptor(java.util.Map)", "type": "constructor", "idx": 50774, "Desc": "construct a descriptor where the names and values of the fields are the keys and values of the given map ."}{"node_name": "InstanceAlreadyExistsException()", "type": "constructor", "idx": 50792, "Desc": "default constructor ."}{"node_name": "InstanceAlreadyExistsException(java.lang.String)", "type": "constructor", "idx": 50793, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "InstanceNotFoundException()", "type": "constructor", "idx": 50796, "Desc": "default constructor ."}{"node_name": "InstanceNotFoundException(java.lang.String)", "type": "constructor", "idx": 50797, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "IntrospectionException()", "type": "constructor", "idx": 50800, "Desc": "default constructor ."}{"node_name": "IntrospectionException(java.lang.String)", "type": "constructor", "idx": 50801, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "InvalidApplicationException(java.lang.Object)", "type": "constructor", "idx": 50804, "Desc": "constructs an invalidapplicationexception with the specified object ."}{"node_name": "InvalidAttributeValueException()", "type": "constructor", "idx": 50807, "Desc": "default constructor ."}{"node_name": "InvalidAttributeValueException(java.lang.String)", "type": "constructor", "idx": 50808, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "JMException()", "type": "constructor", "idx": 50811, "Desc": "default constructor ."}{"node_name": "JMException(java.lang.String)", "type": "constructor", "idx": 50812, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "JMRuntimeException()", "type": "constructor", "idx": 50815, "Desc": "default constructor ."}{"node_name": "JMRuntimeException(java.lang.String)", "type": "constructor", "idx": 50816, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "ListenerNotFoundException()", "type": "constructor", "idx": 50849, "Desc": "default constructor ."}{"node_name": "ListenerNotFoundException(java.lang.String)", "type": "constructor", "idx": 50850, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "MLet()", "type": "constructor", "idx": 50863, "Desc": "constructs a new mlet using the default delegation parent classloader ."}{"node_name": "MLet(java.net.URL[])", "type": "constructor", "idx": 50864, "Desc": "constructs a new mlet for the specified urls using the default delegation parent classloader . the urls will be searched in the order specified for classes and resources after first searching in the parent class loader ."}{"node_name": "MLet(java.net.URL[],java.lang.ClassLoader)", "type": "constructor", "idx": 50866, "Desc": "constructs a new mlet for the given urls . the urls will be searched in the order specified for classes and resources after first searching in the specified parent class loader . the parent argument will be used as the parent class loader for delegation ."}{"node_name": "MLet(java.net.URL[],java.lang.ClassLoader,java.net.URLStreamHandlerFactory)", "type": "constructor", "idx": 50869, "Desc": "constructs a new mlet for the specified urls , parent class loader , and urlstreamhandlerfactory . the parent argument will be used as the parent class loader for delegation . the factory argument will be used as the stream handler factory to obtain protocol handlers when creating new urls ."}{"node_name": "MLet(java.net.URL[],boolean)", "type": "constructor", "idx": 50873, "Desc": "constructs a new mlet for the specified urls using the default delegation parent classloader . the urls will be searched in the order specified for classes and resources after first searching in the parent class loader ."}{"node_name": "MLet(java.net.URL[],java.lang.ClassLoader,boolean)", "type": "constructor", "idx": 50876, "Desc": "constructs a new mlet for the given urls . the urls will be searched in the order specified for classes and resources after first searching in the specified parent class loader . the parent argument will be used as the parent class loader for delegation ."}{"node_name": "MLet(java.net.URL[],java.lang.ClassLoader,java.net.URLStreamHandlerFactory,boolean)", "type": "constructor", "idx": 50880, "Desc": "constructs a new mlet for the specified urls , parent class loader , and urlstreamhandlerfactory . the parent argument will be used as the parent class loader for delegation . the factory argument will be used as the stream handler factory to obtain protocol handlers when creating new urls ."}{"node_name": "MLetContent(java.net.URL,java.util.Map,java.util.List,java.util.List)", "type": "constructor", "idx": 50921, "Desc": "creates an mlet instance initialized with attributes read from an mlet tag in an mlet text file ."}{"node_name": "PrivateMLet(java.net.URL[],boolean)", "type": "constructor", "idx": 50957, "Desc": "constructs a new privatemlet for the specified urls using the default delegation parent classloader . the urls will be searched in the order specified for classes and resources after first searching in the parent class loader ."}{"node_name": "PrivateMLet(java.net.URL[],java.lang.ClassLoader,boolean)", "type": "constructor", "idx": 50960, "Desc": "constructs a new privatemlet for the given urls . the urls will be searched in the order specified for classes and resources after first searching in the specified parent class loader . the parent argument will be used as the parent class loader for delegation ."}{"node_name": "PrivateMLet(java.net.URL[],java.lang.ClassLoader,java.net.URLStreamHandlerFactory,boolean)", "type": "constructor", "idx": 50964, "Desc": "constructs a new privatemlet for the specified urls , parent class loader , and urlstreamhandlerfactory . the parent argument will be used as the parent class loader for delegation . the factory argument will be used as the stream handler factory to obtain protocol handlers when creating new urls ."}{"node_name": "MalformedObjectNameException()", "type": "constructor", "idx": 50970, "Desc": "default constructor ."}{"node_name": "MalformedObjectNameException(java.lang.String)", "type": "constructor", "idx": 50971, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "MBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean,boolean)", "type": "constructor", "idx": 50974, "Desc": "constructs an mbeanattributeinfo object ."}{"node_name": "MBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean,boolean,javax.management.Descriptor)", "type": "constructor", "idx": 50981, "Desc": "constructs an mbeanattributeinfo object ."}{"node_name": "MBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 50989, "Desc": "<init>(java.lang.String,java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method) takes the name of a simple attribute , and method objects for reading and writing the attribute . the descriptor of the constructed object will include fields contributed by any annotations on the method objects that contain the descriptorkey meta-annotation ."}{"node_name": "MBeanConstructorInfo(java.lang.String,java.lang.reflect.Constructor)", "type": "constructor", "idx": 51002, "Desc": "constructs an mbeanconstructorinfo object . the descriptor of the constructed object will include fields contributed by any annotations on <init>(java.lang.String,java.lang.reflect.Constructor) object that contain the descriptorkey meta-annotation ."}{"node_name": "MBeanConstructorInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[])", "type": "constructor", "idx": 51005, "Desc": "constructs an mbeanconstructorinfo object ."}{"node_name": "MBeanConstructorInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[],javax.management.Descriptor)", "type": "constructor", "idx": 51009, "Desc": "constructs an mbeanconstructorinfo object ."}{"node_name": "MBeanException(java.lang.Exception)", "type": "constructor", "idx": 51019, "Desc": "creates an mbeanexception that wraps the actual java.lang.exception ."}{"node_name": "MBeanException(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 51021, "Desc": "creates an mbeanexception that wraps the actual java.lang.exception with a detail message ."}{"node_name": "MBeanFeatureInfo(java.lang.String,java.lang.String)", "type": "constructor", "idx": 51029, "Desc": "constructs an mbeanfeatureinfo object . <init>(java.lang.String,java.lang.String) is equivalent to mbeanfeatureinfo ( name , description , ( descriptor ) null ."}{"node_name": "MBeanFeatureInfo(java.lang.String,java.lang.String,javax.management.Descriptor)", "type": "constructor", "idx": 51032, "Desc": "constructs an mbeanfeatureinfo object ."}{"node_name": "MBeanInfo(java.lang.String,java.lang.String,javax.management.MBeanAttributeInfo[],javax.management.MBeanConstructorInfo[],javax.management.MBeanOperationInfo[],javax.management.MBeanNotificationInfo[])", "type": "constructor", "idx": 51042, "Desc": "constructs an mbeaninfo ."}{"node_name": "MBeanInfo(java.lang.String,java.lang.String,javax.management.MBeanAttributeInfo[],javax.management.MBeanConstructorInfo[],javax.management.MBeanOperationInfo[],javax.management.MBeanNotificationInfo[],javax.management.Descriptor)", "type": "constructor", "idx": 51049, "Desc": "constructs an mbeaninfo ."}{"node_name": "MBeanNotificationInfo(java.lang.String[],java.lang.String,java.lang.String)", "type": "constructor", "idx": 51068, "Desc": "constructs an mbeannotificationinfo object ."}{"node_name": "MBeanNotificationInfo(java.lang.String[],java.lang.String,java.lang.String,javax.management.Descriptor)", "type": "constructor", "idx": 51072, "Desc": "constructs an mbeannotificationinfo object ."}{"node_name": "MBeanOperationInfo(java.lang.String,java.lang.reflect.Method)", "type": "constructor", "idx": 51086, "Desc": "constructs an mbeanoperationinfo object . the descriptor of the constructed object will include fields contributed by any annotations on the method object that contain the descriptorkey meta-annotation ."}{"node_name": "MBeanOperationInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[],java.lang.String,int)", "type": "constructor", "idx": 51089, "Desc": "constructs an mbeanoperationinfo object ."}{"node_name": "MBeanOperationInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[],java.lang.String,int,javax.management.Descriptor)", "type": "constructor", "idx": 51095, "Desc": "constructs an mbeanoperationinfo object ."}{"node_name": "MBeanParameterInfo(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 51109, "Desc": "constructs an mbeanparameterinfo object ."}{"node_name": "MBeanParameterInfo(java.lang.String,java.lang.String,java.lang.String,javax.management.Descriptor)", "type": "constructor", "idx": 51113, "Desc": "constructs an mbeanparameterinfo object ."}{"node_name": "MBeanPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 51123, "Desc": "create a new mbeanpermission object with the specified target name and actions . the target name is of the form \" classname #member [ objectname ]\" where each part is optional . it must not be empty or null . the actions parameter contains a comma-separated list of the desired actions granted on the target name . it must not be empty or null ."}{"node_name": "MBeanPermission(java.lang.String,java.lang.String,javax.management.ObjectName,java.lang.String)", "type": "constructor", "idx": 51126, "Desc": "create a new mbeanpermission object with the specified target name ( class name , member , object name ) and actions . the class name , member and object name parameters define a target name of the form \" classname #member [ objectname ]\" where each part is optional . this will be the result of permission.getname() on the resultant mbeanpermission . the actions parameter contains a comma-separated list of the desired actions granted on the target name . it must not be empty or null ."}{"node_name": "MBeanRegistrationException(java.lang.Exception)", "type": "constructor", "idx": 51146, "Desc": "creates an mbeanregistrationexception that wraps the actual java.lang.exception ."}{"node_name": "MBeanRegistrationException(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 51148, "Desc": "creates an mbeanregistrationexception that wraps the actual java.lang.exception with a detailed message ."}{"node_name": "MBeanServerBuilder()", "type": "constructor", "idx": 51226, "Desc": "public default constructor ."}{"node_name": "MBeanServerDelegate()", "type": "constructor", "idx": 51316, "Desc": "create a mbeanserverdelegate object ."}{"node_name": "MBeanServerInvocationHandler(javax.management.MBeanServerConnection,javax.management.ObjectName)", "type": "constructor", "idx": 51348, "Desc": "invocation handler that forwards methods through an mbean server to a standard mbean . <init>(javax.management.MBeanServerConnection,javax.management.ObjectName) may be called instead of relying on jmx.newmbeanproxy , for instance if you need to supply a different classloader to proxy.newproxyinstance . <init>(javax.management.MBeanServerConnection,javax.management.ObjectName) is not appropriate for an mxbean . use mbeanserverinvocationhandler ( mbeanserverconnection , objectname , boolean ) for that . <init>(javax.management.MBeanServerConnection,javax.management.ObjectName) is equivalent to new mbeanserverinvocationhandler ( connection , objectname , false ) ."}{"node_name": "MBeanServerInvocationHandler(javax.management.MBeanServerConnection,javax.management.ObjectName,boolean)", "type": "constructor", "idx": 51351, "Desc": "invocation handler that can forward methods through an mbean server to a standard mbean or mxbean . <init>(javax.management.MBeanServerConnection,javax.management.ObjectName,boolean) may be called instead of relying on jmx.newmxbeanproxy , for instance if you need to supply a different classloader to proxy.newproxyinstance ."}{"node_name": "MBeanServerNotification(java.lang.String,java.lang.Object,long,javax.management.ObjectName)", "type": "constructor", "idx": 51366, "Desc": "creates an mbeanservernotification object specifying object names of the mbeans that caused the notification and the specified notification type ."}{"node_name": "MBeanServerPermission(java.lang.String)", "type": "constructor", "idx": 51373, "Desc": "create a new mbeanserverpermission with the given name . <init>(java.lang.String) is equivalent to mbeanserverpermission ( name , null ) ."}{"node_name": "MBeanServerPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 51375, "Desc": "create a new mbeanserverpermission with the given name ."}{"node_name": "MBeanTrustPermission(java.lang.String)", "type": "constructor", "idx": 51383, "Desc": "create a new mbeantrustpermission with the given name . <init>(java.lang.String) is equivalent to mbeantrustpermission ( name , null ) ."}{"node_name": "MBeanTrustPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 51385, "Desc": "create a new mbeantrustpermission with the given name ."}{"node_name": "DescriptorSupport()", "type": "constructor", "idx": 51389, "Desc": "descriptor default constructor . default initial descriptor size is 20 . it will grow as needed . note that the created empty descriptor is not a valid descriptor ( the method isvalid returns false )"}{"node_name": "DescriptorSupport(int)", "type": "constructor", "idx": 51390, "Desc": "descriptor constructor . takes as parameter the initial capacity of the map that stores the descriptor fields . capacity will grow as needed . note that the created empty descriptor is not a valid descriptor ( the method isvalid returns false ) ."}{"node_name": "DescriptorSupport(javax.management.modelmbean.DescriptorSupport)", "type": "constructor", "idx": 51392, "Desc": "descriptor constructor taking a descriptor as parameter . creates a new descriptor initialized to the values of the descriptor passed in parameter ."}{"node_name": "DescriptorSupport(java.lang.String)", "type": "constructor", "idx": 51394, "Desc": "descriptor constructor taking an xml string . the format of the xml string is not defined , but an implementation must ensure that the string returned by toxmlstring() on an existing descriptor can be used to instantiate an equivalent descriptor using <init>(java.lang.String) . in this implementation , all field values will be created as strings . if the field values are not strings , the programmer will have to reset or convert these fields correctly ."}{"node_name": "DescriptorSupport(java.lang.String[],java.lang.Object[])", "type": "constructor", "idx": 51396, "Desc": "constructor taking field names and field values . neither array can be null ."}{"node_name": "DescriptorSupport(java.lang.String...)", "type": "constructor", "idx": 51399, "Desc": "constructor taking fields in the fieldname=fieldvalue format ."}{"node_name": "InvalidTargetObjectTypeException()", "type": "constructor", "idx": 51409, "Desc": "default constructor ."}{"node_name": "InvalidTargetObjectTypeException(java.lang.String)", "type": "constructor", "idx": 51410, "Desc": "constructor from a string ."}{"node_name": "InvalidTargetObjectTypeException(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 51412, "Desc": "constructor taking an exception and a string ."}{"node_name": "ModelMBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method)", "type": "constructor", "idx": 51422, "Desc": "constructs a modelmbeanattributeinfo object with a default descriptor . the descriptor of the constructed object will include fields contributed by any annotations on the method objects that contain the descriptorkey meta-annotation ."}{"node_name": "ModelMBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.reflect.Method,java.lang.reflect.Method,javax.management.Descriptor)", "type": "constructor", "idx": 51427, "Desc": "constructs a modelmbeanattributeinfo object . the descriptor of the constructed object will include fields contributed by any annotations on the method objects that contain the descriptorkey meta-annotation ."}{"node_name": "ModelMBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean,boolean)", "type": "constructor", "idx": 51433, "Desc": "constructs a modelmbeanattributeinfo object with a default descriptor ."}{"node_name": "ModelMBeanAttributeInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean,boolean,javax.management.Descriptor)", "type": "constructor", "idx": 51440, "Desc": "constructs a modelmbeanattributeinfo object ."}{"node_name": "ModelMBeanAttributeInfo(javax.management.modelmbean.ModelMBeanAttributeInfo)", "type": "constructor", "idx": 51448, "Desc": "constructs a new modelmbeanattributeinfo object from this modelmbeanattributeinfo object . a default descriptor will be created ."}{"node_name": "ModelMBeanConstructorInfo(java.lang.String,java.lang.reflect.Constructor)", "type": "constructor", "idx": 51456, "Desc": "constructs a modelmbeanconstructorinfo object with a default descriptor . the descriptor of the constructed object will include fields contributed by any annotations on <init>(java.lang.String,java.lang.reflect.Constructor) object that contain the descriptorkey meta-annotation ."}{"node_name": "ModelMBeanConstructorInfo(java.lang.String,java.lang.reflect.Constructor,javax.management.Descriptor)", "type": "constructor", "idx": 51459, "Desc": "constructs a modelmbeanconstructorinfo object . the descriptor of the constructed object will include fields contributed by any annotations on <init>(java.lang.String,java.lang.reflect.Constructor,javax.management.Descriptor) object that contain the descriptorkey meta-annotation ."}{"node_name": "ModelMBeanConstructorInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[])", "type": "constructor", "idx": 51463, "Desc": "constructs a modelmbeanconstructorinfo object with a default descriptor ."}{"node_name": "ModelMBeanConstructorInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[],javax.management.Descriptor)", "type": "constructor", "idx": 51467, "Desc": "constructs a modelmbeanconstructorinfo object ."}{"node_name": "ModelMBeanInfoSupport(javax.management.modelmbean.ModelMBeanInfo)", "type": "constructor", "idx": 51505, "Desc": "constructs a modelmbeaninfosupport which is a duplicate of the given modelmbeaninfo . the returned object is a shallow copy of the given object . neither the descriptor nor the contained arrays ( modelmbeanattributeinfo [ ] etc ) are cloned . this method is chiefly of interest to modify the descriptor of the returned instance via setdescriptor without affecting the descriptor of the original object ."}{"node_name": "ModelMBeanInfoSupport(java.lang.String,java.lang.String,javax.management.modelmbean.ModelMBeanAttributeInfo[],javax.management.modelmbean.ModelMBeanConstructorInfo[],javax.management.modelmbean.ModelMBeanOperationInfo[],javax.management.modelmbean.ModelMBeanNotificationInfo[])", "type": "constructor", "idx": 51507, "Desc": "creates a modelmbeaninfosupport with the provided information , but the descriptor is a default . the default descriptor is : name=classname , descriptortype= \" mbean \" , displayname=classname , persistpolicy= \" never \" , log= \" f \" , visibility= \" 1 \""}{"node_name": "ModelMBeanInfoSupport(java.lang.String,java.lang.String,javax.management.modelmbean.ModelMBeanAttributeInfo[],javax.management.modelmbean.ModelMBeanConstructorInfo[],javax.management.modelmbean.ModelMBeanOperationInfo[],javax.management.modelmbean.ModelMBeanNotificationInfo[],javax.management.Descriptor)", "type": "constructor", "idx": 51514, "Desc": "creates a modelmbeaninfosupport with the provided information and the descriptor given in parameter ."}{"node_name": "ModelMBeanNotificationInfo(java.lang.String[],java.lang.String,java.lang.String)", "type": "constructor", "idx": 51546, "Desc": "constructs a modelmbeannotificationinfo object with a default descriptor ."}{"node_name": "ModelMBeanNotificationInfo(java.lang.String[],java.lang.String,java.lang.String,javax.management.Descriptor)", "type": "constructor", "idx": 51550, "Desc": "constructs a modelmbeannotificationinfo object ."}{"node_name": "ModelMBeanNotificationInfo(javax.management.modelmbean.ModelMBeanNotificationInfo)", "type": "constructor", "idx": 51555, "Desc": "constructs a new modelmbeannotificationinfo object from this modelmbeannotfication object ."}{"node_name": "ModelMBeanOperationInfo(java.lang.String,java.lang.reflect.Method)", "type": "constructor", "idx": 51563, "Desc": "constructs a modelmbeanoperationinfo object with a default descriptor . the descriptor of the constructed object will include fields contributed by any annotations on the method object that contain the descriptorkey meta-annotation ."}{"node_name": "ModelMBeanOperationInfo(java.lang.String,java.lang.reflect.Method,javax.management.Descriptor)", "type": "constructor", "idx": 51566, "Desc": "constructs a modelmbeanoperationinfo object . the descriptor of the constructed object will include fields contributed by any annotations on the method object that contain the descriptorkey meta-annotation ."}{"node_name": "ModelMBeanOperationInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[],java.lang.String,int)", "type": "constructor", "idx": 51570, "Desc": "constructs a modelmbeanoperationinfo object with a default descriptor ."}{"node_name": "ModelMBeanOperationInfo(java.lang.String,java.lang.String,javax.management.MBeanParameterInfo[],java.lang.String,int,javax.management.Descriptor)", "type": "constructor", "idx": 51576, "Desc": "constructs a modelmbeanoperationinfo object ."}{"node_name": "ModelMBeanOperationInfo(javax.management.modelmbean.ModelMBeanOperationInfo)", "type": "constructor", "idx": 51583, "Desc": "constructs a new modelmbeanoperationinfo object from this modelmbeanoperation object ."}{"node_name": "RequiredModelMBean()", "type": "constructor", "idx": 51591, "Desc": "constructs an requiredmodelmbean with an empty modelmbeaninfo . the requiredmodelmbean's mbeaninfo and descriptors can be customized using the setmodelmbeaninfo ( javax.management.modelmbean.modelmbeaninfo ) method . after the requiredmodelmbean's mbeaninfo and descriptors are customized , the requiredmodelmbean can be registered with the mbeanserver ."}{"node_name": "RequiredModelMBean(javax.management.modelmbean.ModelMBeanInfo)", "type": "constructor", "idx": 51592, "Desc": "constructs a requiredmodelmbean object using modelmbeaninfo passed in . as long as the requiredmodelmbean is not registered with the mbeanserver yet , the requiredmodelmbean's mbeaninfo and descriptors can be customized using the setmodelmbeaninfo ( javax.management.modelmbean.modelmbeaninfo ) method . after the requiredmodelmbean's mbeaninfo and descriptors are customized , the requiredmodelmbean can be registered with the mbeanserver ."}{"node_name": "XMLParseException()", "type": "constructor", "idx": 51630, "Desc": "default constructor ."}{"node_name": "XMLParseException(java.lang.String)", "type": "constructor", "idx": 51631, "Desc": "constructor taking a string ."}{"node_name": "XMLParseException(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 51633, "Desc": "constructor taking a string and an exception ."}{"node_name": "CounterMonitor()", "type": "constructor", "idx": 51637, "Desc": "default constructor ."}{"node_name": "GaugeMonitor()", "type": "constructor", "idx": 51685, "Desc": "default constructor ."}{"node_name": "Monitor()", "type": "constructor", "idx": 51736, "Desc": ""}{"node_name": "MonitorSettingException()", "type": "constructor", "idx": 51793, "Desc": "default constructor ."}{"node_name": "MonitorSettingException(java.lang.String)", "type": "constructor", "idx": 51794, "Desc": "constructor that allows an error message to be specified ."}{"node_name": "StringMonitor()", "type": "constructor", "idx": 51797, "Desc": "default constructor ."}{"node_name": "NotCompliantMBeanException()", "type": "constructor", "idx": 51830, "Desc": "default constructor ."}{"node_name": "NotCompliantMBeanException(java.lang.String)", "type": "constructor", "idx": 51831, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "Notification(java.lang.String,java.lang.Object,long)", "type": "constructor", "idx": 51835, "Desc": "creates a notification object . the notification timestamp is set to the current date ."}{"node_name": "Notification(java.lang.String,java.lang.Object,long,java.lang.String)", "type": "constructor", "idx": 51839, "Desc": "creates a notification object . the notification timestamp is set to the current date ."}{"node_name": "Notification(java.lang.String,java.lang.Object,long,long)", "type": "constructor", "idx": 51844, "Desc": "creates a notification object ."}{"node_name": "Notification(java.lang.String,java.lang.Object,long,long,java.lang.String)", "type": "constructor", "idx": 51849, "Desc": "creates a notification object ."}{"node_name": "NotificationBroadcasterSupport()", "type": "constructor", "idx": 51878, "Desc": "constructs a notificationbroadcastersupport where each listener is invoked by the thread sending the notification . <init>() is equivalent to notificationbroadcastersupport ( null , null ) ."}{"node_name": "NotificationBroadcasterSupport(java.util.concurrent.Executor)", "type": "constructor", "idx": 51879, "Desc": "constructs a notificationbroadcastersupport where each listener is invoked using the given executor . when sendnotification is called , a listener is selected if it was added with a null notificationfilter , or if isnotificationenabled returns true for the notification being sent . the call to notificationfilter.isnotificationenabled takes place in the thread that called sendnotification . then , for each selected listener , executor.execute is called with a command that calls the handlenotification method . <init>(java.util.concurrent.Executor) is equivalent to notificationbroadcastersupport ( executor , null ) ."}{"node_name": "NotificationBroadcasterSupport(javax.management.MBeanNotificationInfo...)", "type": "constructor", "idx": 51881, "Desc": "constructs a notificationbroadcastersupport with information about the notifications that may be sent . each listener is invoked by the thread sending the notification . <init>(javax.management.MBeanNotificationInfo...) is equivalent to notificationbroadcastersupport ( null , info ) . if the info array is not empty , then it is cloned by <init>(javax.management.MBeanNotificationInfo...) as if by info.clone() , and each call to notificationbroadcaster.getnotificationinfo() returns a new clone ."}{"node_name": "NotificationBroadcasterSupport(java.util.concurrent.Executor,javax.management.MBeanNotificationInfo...)", "type": "constructor", "idx": 51883, "Desc": "constructs a notificationbroadcastersupport with information about the notifications that may be sent , and where each listener is invoked using the given executor . when sendnotification is called , a listener is selected if it was added with a null notificationfilter , or if isnotificationenabled returns true for the notification being sent . the call to notificationfilter.isnotificationenabled takes place in the thread that called sendnotification . then , for each selected listener , executor.execute is called with a command that calls the handlenotification method . if the info array is not empty , then it is cloned by <init>(java.util.concurrent.Executor,javax.management.MBeanNotificationInfo...) as if by info.clone() , and each call to notificationbroadcaster.getnotificationinfo() returns a new clone ."}{"node_name": "NotificationFilterSupport()", "type": "constructor", "idx": 51905, "Desc": ""}{"node_name": "ObjectInstance(java.lang.String,java.lang.String)", "type": "constructor", "idx": 51919, "Desc": "allows an object instance to be created given a string representation of an object name and the full class name , including the package name ."}{"node_name": "ObjectInstance(javax.management.ObjectName,java.lang.String)", "type": "constructor", "idx": 51922, "Desc": "allows an object instance to be created given an object name and the full class name , including the package name ."}{"node_name": "ObjectName(java.lang.String)", "type": "constructor", "idx": 51932, "Desc": "construct an object name from the given string ."}{"node_name": "ObjectName(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 51934, "Desc": "construct an object name with exactly one key property ."}{"node_name": "ObjectName(java.lang.String,java.util.Hashtable)", "type": "constructor", "idx": 51938, "Desc": "construct an object name with several key properties from a hashtable ."}{"node_name": "ArrayType(int,javax.management.openmbean.OpenType)", "type": "constructor", "idx": 51979, "Desc": "constructs an arraytype instance describing open data values which are arrays with dimension dimension of elements whose open type is elementtype . when invoked on an arraytype instance , the getclassname method returns the class name of the array instances it describes ( following the rules defined by the getname method of java.lang.class ) , not the class name of the array elements ( which is returned by a call to getelementopentype() .getclassname() ) . the internal field corresponding to the type name of this arraytype instance is also set to the class name of the array instances it describes . in other words , the methods getclassname and gettypename return the same string value . the internal field corresponding to the description of this arraytype instance is set to a string value which follows the following template : if non-primitive array : < dimension > -dimension array of < element_class_name > if primitive array : < dimension > -dimension array of < primitive_type_of_the_element_class_name > as an example , the following piece of code : arraytype < string [ ] [ ] [ ] > t = new arraytype < string [ ] [ ] [ ] > ( 3 , simpletype.string ); system.out.println ( \" array class name = \" + t.getclassname() ); system.out.println ( \" element class name = \" + t.getelementopentype() .getclassname() ); system.out.println ( \" array type name = \" + t.gettypename() ); system.out.println ( \" array type description = \" + t.getdescription() ); would produce the following output : array class name = [[[ ljava.lang.string ; element class name = java.lang.string array type name = [[[ ljava.lang.string ; array type description = 3-dimension array of java.lang.string and the following piece of code which is equivalent to the one listed above would also produce the same output : arraytype < string [ ] > t1 = new arraytype < string [ ] > ( 1 , simpletype.string ); arraytype < string [ ] [ ] > t2 = new arraytype < string [ ] [ ] > ( 1 , t1 ); arraytype < string [ ] [ ] [ ] > t3 = new arraytype < string [ ] [ ] [ ] > ( 1 , t2 ); system.out.println ( \" array class name = \" + t3.getclassname() ); system.out.println ( \" element class name = \" + t3.getelementopentype() .getclassname() ); system.out.println ( \" array type name = \" + t3.gettypename() ); system.out.println ( \" array type description = \" + t3.getdescription() );"}{"node_name": "ArrayType(javax.management.openmbean.SimpleType,boolean)", "type": "constructor", "idx": 51982, "Desc": "constructs a unidimensional arraytype instance for the supplied simpletype . <init>(javax.management.openmbean.SimpleType,boolean) supports the creation of arrays of primitive types when primitivearray is true . for primitive arrays the getelementopentype() method returns the simpletype corresponding to the wrapper type of the primitive type of the array . when invoked on an arraytype instance , the getclassname method returns the class name of the array instances it describes ( following the rules defined by the getname method of java.lang.class ) , not the class name of the array elements ( which is returned by a call to getelementopentype() .getclassname() ) . the internal field corresponding to the type name of this arraytype instance is also set to the class name of the array instances it describes . in other words , the methods getclassname and gettypename return the same string value . the internal field corresponding to the description of this arraytype instance is set to a string value which follows the following template : if non-primitive array : 1-dimension array of < element_class_name > if primitive array : 1-dimension array of < primitive_type_of_the_element_class_name > as an example , the following piece of code : arraytype < int [ ] > t = new arraytype < int [ ] > ( simpletype.integer , true ); system.out.println ( \" array class name = \" + t.getclassname() ); system.out.println ( \" element class name = \" + t.getelementopentype() .getclassname() ); system.out.println ( \" array type name = \" + t.gettypename() ); system.out.println ( \" array type description = \" + t.getdescription() ); would produce the following output : array class name = [ i element class name = java.lang.integer array type name = [ i array type description = 1-dimension array of int"}{"node_name": "CompositeDataInvocationHandler(javax.management.openmbean.CompositeData)", "type": "constructor", "idx": 52014, "Desc": "construct a handler backed by the given compositedata ."}{"node_name": "CompositeDataSupport(javax.management.openmbean.CompositeType,java.lang.String[],java.lang.Object[])", "type": "constructor", "idx": 52018, "Desc": "constructs a compositedatasupport instance with the specified compositetype , whose item values are specified by itemvalues [ ] , in the same order as in itemnames [ ] . as a compositetype does not specify any order on its items , the itemnames [ ] parameter is used to specify the order in which the values are given in itemvalues [ ] . the items contained in this compositedatasupport instance are internally stored in a treemap , thus sorted in ascending lexicographic order of their names , for faster retrieval of individual item values . <init>(javax.management.openmbean.CompositeType,java.lang.String[],java.lang.Object[]) checks that all the constraints listed below for each parameter are satisfied , and throws the appropriate exception if they are not ."}{"node_name": "CompositeDataSupport(javax.management.openmbean.CompositeType,java.util.Map)", "type": "constructor", "idx": 52022, "Desc": "constructs a compositedatasupport instance with the specified compositetype , whose item names and corresponding values are given by the mappings in the map items . <init>(javax.management.openmbean.CompositeType,java.util.Map) converts the keys to a string array and the values to an object array and calls compositedatasupport ( javax.management.openmbean.compositetype , java.lang.string [ ] , java.lang.object [ ]) ."}{"node_name": "CompositeType(java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],javax.management.openmbean.OpenType[])", "type": "constructor", "idx": 52043, "Desc": "constructs a compositetype instance , checking for the validity of the given parameters . the validity constraints are described below for each parameter . note that the contents of the three array parameters itemnames , itemdescriptions and itemtypes are internally copied so that any subsequent modification of these arrays by the caller of <init>(java.lang.String,java.lang.String,java.lang.String[],java.lang.String[],javax.management.openmbean.OpenType[]) has no impact on the constructed compositetype instance . the java class name of composite data values this composite type represents ( ie the class name returned by the getclassname method ) is set to the string value returned by compositedata.class.getname() ."}{"node_name": "InvalidKeyException()", "type": "constructor", "idx": 52063, "Desc": "an invalidkeyexception with no detail message ."}{"node_name": "InvalidKeyException(java.lang.String)", "type": "constructor", "idx": 52064, "Desc": "an invalidkeyexception with a detail message ."}{"node_name": "InvalidOpenTypeException()", "type": "constructor", "idx": 52067, "Desc": "an invalidopentypeexception with no detail message ."}{"node_name": "InvalidOpenTypeException(java.lang.String)", "type": "constructor", "idx": 52068, "Desc": "an invalidopentypeexception with a detail message ."}{"node_name": "KeyAlreadyExistsException()", "type": "constructor", "idx": 52071, "Desc": "a keyalreadyexistsexception with no detail message ."}{"node_name": "KeyAlreadyExistsException(java.lang.String)", "type": "constructor", "idx": 52072, "Desc": "a keyalreadyexistsexception with a detail message ."}{"node_name": "OpenDataException()", "type": "constructor", "idx": 52075, "Desc": "an opendataexception with no detail message ."}{"node_name": "OpenDataException(java.lang.String)", "type": "constructor", "idx": 52076, "Desc": "an opendataexception with a detail message ."}{"node_name": "OpenMBeanAttributeInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,boolean,boolean,boolean)", "type": "constructor", "idx": 52087, "Desc": "constructs an openmbeanattributeinfosupport instance , which describes the attribute of an open mbean with the specified name , opentype and description , and the specified read / write access properties ."}{"node_name": "OpenMBeanAttributeInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,boolean,boolean,boolean,javax.management.Descriptor)", "type": "constructor", "idx": 52094, "Desc": "constructs an openmbeanattributeinfosupport instance , which describes the attribute of an open mbean with the specified name , opentype , description , read / write access properties , and descriptor . the descriptor can contain entries that will define the values returned by certain methods of this class , as explained in the package description ."}{"node_name": "OpenMBeanAttributeInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,boolean,boolean,boolean,java.lang.Object)", "type": "constructor", "idx": 52102, "Desc": "constructs an openmbeanattributeinfosupport instance , which describes the attribute of an open mbean with the specified name , opentype , description and defaultvalue , and the specified read / write access properties ."}{"node_name": "OpenMBeanAttributeInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,boolean,boolean,boolean,java.lang.Object,java.lang.Object[])", "type": "constructor", "idx": 52110, "Desc": "constructs an openmbeanattributeinfosupport instance , which describes the attribute of an open mbean with the specified name , opentype , description , defaultvalue and legalvalues , and the specified read / write access properties . the contents of legalvalues are copied , so subsequent modifications of the array referenced by legalvalues have no impact on this openmbeanattributeinfosupport instance ."}{"node_name": "OpenMBeanAttributeInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,boolean,boolean,boolean,java.lang.Object,java.lang.Comparable,java.lang.Comparable)", "type": "constructor", "idx": 52119, "Desc": "constructs an openmbeanattributeinfosupport instance , which describes the attribute of an open mbean , with the specified name , opentype , description , defaultvalue , minvalue and maxvalue . it is possible to specify minimal and maximal values only for an open type whose values are comparable ."}{"node_name": "OpenMBeanConstructorInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanParameterInfo[])", "type": "constructor", "idx": 52153, "Desc": "constructs an openmbeanconstructorinfosupport instance , which describes <init>(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanParameterInfo[]) of a class of open mbeans with the specified name , description and signature . the signature array parameter is internally copied , so that subsequent changes to the array referenced by signature have no effect on this instance ."}{"node_name": "OpenMBeanConstructorInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanParameterInfo[],javax.management.Descriptor)", "type": "constructor", "idx": 52157, "Desc": "constructs an openmbeanconstructorinfosupport instance , which describes <init>(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanParameterInfo[],javax.management.Descriptor) of a class of open mbeans with the specified name , description , signature , and descriptor . the signature array parameter is internally copied , so that subsequent changes to the array referenced by signature have no effect on this instance ."}{"node_name": "OpenMBeanInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanAttributeInfo[],javax.management.openmbean.OpenMBeanConstructorInfo[],javax.management.openmbean.OpenMBeanOperationInfo[],javax.management.MBeanNotificationInfo[])", "type": "constructor", "idx": 52178, "Desc": "constructs an openmbeaninfosupport instance , which describes a class of open mbeans with the specified classname , description , openattributes , openconstructors , openoperations and notifications . the openattributes , openconstructors , openoperations and notifications array parameters are internally copied , so that subsequent changes to the arrays referenced by these parameters have no effect on this instance ."}{"node_name": "OpenMBeanInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanAttributeInfo[],javax.management.openmbean.OpenMBeanConstructorInfo[],javax.management.openmbean.OpenMBeanOperationInfo[],javax.management.MBeanNotificationInfo[],javax.management.Descriptor)", "type": "constructor", "idx": 52185, "Desc": "constructs an openmbeaninfosupport instance , which describes a class of open mbeans with the specified classname , description , openattributes , openconstructors , openoperations , notifications , and descriptor . the openattributes , openconstructors , openoperations and notifications array parameters are internally copied , so that subsequent changes to the arrays referenced by these parameters have no effect on this instance ."}{"node_name": "OpenMBeanOperationInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanParameterInfo[],javax.management.openmbean.OpenType,int)", "type": "constructor", "idx": 52209, "Desc": "constructs an openmbeanoperationinfosupport instance , which describes the operation of a class of open mbeans , with the specified name , description , signature , returnopentype and impact . the signature array parameter is internally copied , so that subsequent changes to the array referenced by signature have no effect on this instance ."}{"node_name": "OpenMBeanOperationInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenMBeanParameterInfo[],javax.management.openmbean.OpenType,int,javax.management.Descriptor)", "type": "constructor", "idx": 52215, "Desc": "constructs an openmbeanoperationinfosupport instance , which describes the operation of a class of open mbeans , with the specified name , description , signature , returnopentype , impact , and descriptor . the signature array parameter is internally copied , so that subsequent changes to the array referenced by signature have no effect on this instance ."}{"node_name": "OpenMBeanParameterInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType)", "type": "constructor", "idx": 52246, "Desc": "constructs an openmbeanparameterinfosupport instance , which describes the parameter used in one or more operations or constructors of a class of open mbeans , with the specified name , opentype and description ."}{"node_name": "OpenMBeanParameterInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,javax.management.Descriptor)", "type": "constructor", "idx": 52250, "Desc": "constructs an openmbeanparameterinfosupport instance , which describes the parameter used in one or more operations or constructors of a class of open mbeans , with the specified name , opentype , description , and descriptor . the descriptor can contain entries that will define the values returned by certain methods of this class , as explained in the package description ."}{"node_name": "OpenMBeanParameterInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,java.lang.Object)", "type": "constructor", "idx": 52255, "Desc": "constructs an openmbeanparameterinfosupport instance , which describes the parameter used in one or more operations or constructors of a class of open mbeans , with the specified name , opentype , description and defaultvalue ."}{"node_name": "OpenMBeanParameterInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,java.lang.Object,java.lang.Object[])", "type": "constructor", "idx": 52260, "Desc": "constructs an openmbeanparameterinfosupport instance , which describes the parameter used in one or more operations or constructors of a class of open mbeans , with the specified name , opentype , description , defaultvalue and legalvalues . the contents of legalvalues are copied , so subsequent modifications of the array referenced by legalvalues have no impact on this openmbeanparameterinfosupport instance ."}{"node_name": "OpenMBeanParameterInfoSupport(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,java.lang.Object,java.lang.Comparable,java.lang.Comparable)", "type": "constructor", "idx": 52266, "Desc": "constructs an openmbeanparameterinfosupport instance , which describes the parameter used in one or more operations or constructors of a class of open mbeans , with the specified name , opentype , description , defaultvalue , minvalue and maxvalue . it is possible to specify minimal and maximal values only for an open type whose values are comparable ."}{"node_name": "OpenType(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 52290, "Desc": "constructs an opentype instance ( actually a subclass instance as opentype is abstract ) , checking for the validity of the given parameters . the validity constraints are described below for each parameter ."}{"node_name": "TabularDataSupport(javax.management.openmbean.TabularType)", "type": "constructor", "idx": 52351, "Desc": "creates an empty tabulardatasupport instance whose open-type is tabulartype , and whose underlying hashmap has a default initial capacity ( 101 ) and default load factor ( 0.75 ) . <init>(javax.management.openmbean.TabularType) simply calls this ( tabulartype , 101 , 0.75f );"}{"node_name": "TabularDataSupport(javax.management.openmbean.TabularType,int,float)", "type": "constructor", "idx": 52353, "Desc": "creates an empty tabulardatasupport instance whose open-type is tabulartype , and whose underlying hashmap has the specified initial capacity and load factor ."}{"node_name": "TabularType(java.lang.String,java.lang.String,javax.management.openmbean.CompositeType,java.lang.String[])", "type": "constructor", "idx": 52395, "Desc": "constructs a tabulartype instance , checking for the validity of the given parameters . the validity constraints are described below for each parameter . the java class name of tabular data values this tabular type represents ( ie the class name returned by the getclassname method ) is set to the string value returned by tabulardata.class.getname() ."}{"node_name": "OperationsException()", "type": "constructor", "idx": 52409, "Desc": "default constructor ."}{"node_name": "OperationsException(java.lang.String)", "type": "constructor", "idx": 52410, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "Query()", "type": "constructor", "idx": 52425, "Desc": "basic constructor ."}{"node_name": "QueryEval()", "type": "constructor", "idx": 52503, "Desc": ""}{"node_name": "ReflectionException(java.lang.Exception)", "type": "constructor", "idx": 52513, "Desc": "creates a reflectionexception that wraps the actual java.lang.exception ."}{"node_name": "ReflectionException(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 52515, "Desc": "creates a reflectionexception that wraps the actual java.lang.exception with a detail message ."}{"node_name": "InvalidRelationIdException()", "type": "constructor", "idx": 52521, "Desc": "default constructor , no message put in exception ."}{"node_name": "InvalidRelationIdException(java.lang.String)", "type": "constructor", "idx": 52522, "Desc": "constructor with given message put in exception ."}{"node_name": "InvalidRelationServiceException()", "type": "constructor", "idx": 52525, "Desc": "default constructor , no message put in exception ."}{"node_name": "InvalidRelationServiceException(java.lang.String)", "type": "constructor", "idx": 52526, "Desc": "constructor with given message put in exception ."}{"node_name": "InvalidRelationTypeException()", "type": "constructor", "idx": 52529, "Desc": "default constructor , no message put in exception ."}{"node_name": "InvalidRelationTypeException(java.lang.String)", "type": "constructor", "idx": 52530, "Desc": "constructor with given message put in exception ."}{"node_name": "InvalidRoleInfoException()", "type": "constructor", "idx": 52533, "Desc": "default constructor , no message put in exception ."}{"node_name": "InvalidRoleInfoException(java.lang.String)", "type": "constructor", "idx": 52534, "Desc": "constructor with given message put in exception ."}{"node_name": "InvalidRoleValueException()", "type": "constructor", "idx": 52537, "Desc": "default constructor , no message put in exception ."}{"node_name": "InvalidRoleValueException(java.lang.String)", "type": "constructor", "idx": 52538, "Desc": "constructor with given message put in exception ."}{"node_name": "MBeanServerNotificationFilter()", "type": "constructor", "idx": 52541, "Desc": "creates a filter selecting all mbeanservernotification notifications for all objectnames ."}{"node_name": "RelationException()", "type": "constructor", "idx": 52573, "Desc": "default constructor , no message put in exception ."}{"node_name": "RelationException(java.lang.String)", "type": "constructor", "idx": 52574, "Desc": "constructor with given message put in exception ."}{"node_name": "RelationNotFoundException()", "type": "constructor", "idx": 52577, "Desc": "default constructor , no message put in exception ."}{"node_name": "RelationNotFoundException(java.lang.String)", "type": "constructor", "idx": 52578, "Desc": "constructor with given message put in exception ."}{"node_name": "RelationNotification(java.lang.String,java.lang.Object,long,long,java.lang.String,java.lang.String,java.lang.String,javax.management.ObjectName,java.util.List)", "type": "constructor", "idx": 52587, "Desc": "creates a notification for either a relation creation ( relationsupport object created internally in the relation service , or an mbean added as a relation ) or for a relation removal from the relation service ."}{"node_name": "RelationNotification(java.lang.String,java.lang.Object,long,long,java.lang.String,java.lang.String,java.lang.String,javax.management.ObjectName,java.lang.String,java.util.List,java.util.List)", "type": "constructor", "idx": 52597, "Desc": "creates a notification for a role update in a relation ."}{"node_name": "RelationService(boolean)", "type": "constructor", "idx": 52617, "Desc": "constructor ."}{"node_name": "RelationServiceNotRegisteredException()", "type": "constructor", "idx": 52793, "Desc": "default constructor , no message put in exception ."}{"node_name": "RelationServiceNotRegisteredException(java.lang.String)", "type": "constructor", "idx": 52794, "Desc": "constructor with given message put in exception ."}{"node_name": "RelationSupport(java.lang.String,javax.management.ObjectName,java.lang.String,javax.management.relation.RoleList)", "type": "constructor", "idx": 52797, "Desc": "creates a relationsupport object . <init>(java.lang.String,javax.management.ObjectName,java.lang.String,javax.management.relation.RoleList) has to be used when the relationsupport object will be registered as a mbean by the user , or when creating a user relation mbean whose class extends relationsupport . nothing is done at the relation service level , i.e. the relationsupport object is not added to the relationservice and no checks are performed to see if the provided values are correct . the object is always created , except if : - any of the required parameters is null . - the same name is used for two roles . to be handled as a relation , the relationsupport object has to be added to the relation service using the relation service method addrelation() ."}{"node_name": "RelationSupport(java.lang.String,javax.management.ObjectName,javax.management.MBeanServer,java.lang.String,javax.management.relation.RoleList)", "type": "constructor", "idx": 52802, "Desc": "creates a relationsupport object . <init>(java.lang.String,javax.management.ObjectName,javax.management.MBeanServer,java.lang.String,javax.management.relation.RoleList) has to be used when the user relation mbean implements the interfaces expected to be supported by a relation by delegating to a relationsupport object . this object needs to know the relation service expected to handle the relation . so it has to know the mbean server where the relation service is registered . according to a limitation , a relation mbean must be registered in the same mbean server as the relation service expected to handle it . so the user relation mbean has to be created and registered , and then the wrapped relationsupport object can be created within the identified mbean server . nothing is done at the relation service level , i.e. the relationsupport object is not added to the relationservice and no checks are performed to see if the provided values are correct . the object is always created , except if : - any of the required parameters is null . - the same name is used for two roles . to be handled as a relation , the relationsupport object has to be added to the relation service using the relation service method addrelation() ."}{"node_name": "RelationTypeNotFoundException()", "type": "constructor", "idx": 52838, "Desc": "default constructor , no message put in exception ."}{"node_name": "RelationTypeNotFoundException(java.lang.String)", "type": "constructor", "idx": 52839, "Desc": "constructor with given message put in exception ."}{"node_name": "RelationTypeSupport(java.lang.String,javax.management.relation.RoleInfo[])", "type": "constructor", "idx": 52842, "Desc": "constructor where all role definitions are dynamically created and passed as parameter ."}{"node_name": "RelationTypeSupport(java.lang.String)", "type": "constructor", "idx": 52845, "Desc": "constructor to be used for subclasses ."}{"node_name": "Role(java.lang.String,java.util.List)", "type": "constructor", "idx": 52854, "Desc": "make a new role object . no check is made that the objectnames in the role value exist in an mbean server . that check will be made when the role is set in a relation ."}{"node_name": "RoleInfo(java.lang.String,java.lang.String,boolean,boolean,int,int,java.lang.String)", "type": "constructor", "idx": 52869, "Desc": "constructor ."}{"node_name": "RoleInfo(java.lang.String,java.lang.String,boolean,boolean)", "type": "constructor", "idx": 52877, "Desc": "constructor ."}{"node_name": "RoleInfo(java.lang.String,java.lang.String)", "type": "constructor", "idx": 52882, "Desc": "constructor ."}{"node_name": "RoleInfo(javax.management.relation.RoleInfo)", "type": "constructor", "idx": 52885, "Desc": "copy constructor ."}{"node_name": "RoleInfoNotFoundException()", "type": "constructor", "idx": 52900, "Desc": "default constructor , no message put in exception ."}{"node_name": "RoleInfoNotFoundException(java.lang.String)", "type": "constructor", "idx": 52901, "Desc": "constructor with given message put in exception ."}{"node_name": "RoleList()", "type": "constructor", "idx": 52904, "Desc": "constructs an empty rolelist ."}{"node_name": "RoleList(int)", "type": "constructor", "idx": 52905, "Desc": "constructs an empty rolelist with the initial capacity specified ."}{"node_name": "RoleList(java.util.List)", "type": "constructor", "idx": 52907, "Desc": "constructs a rolelist containing the elements of the list specified , in the order in which they are returned by the list's iterator . the rolelist instance has an initial capacity of 110% of the size of the list specified ."}{"node_name": "RoleNotFoundException()", "type": "constructor", "idx": 52924, "Desc": "default constructor , no message put in exception ."}{"node_name": "RoleNotFoundException(java.lang.String)", "type": "constructor", "idx": 52925, "Desc": "constructor with given message put in exception ."}{"node_name": "RoleResult(javax.management.relation.RoleList,javax.management.relation.RoleUnresolvedList)", "type": "constructor", "idx": 52928, "Desc": "constructor ."}{"node_name": "RoleStatus()", "type": "constructor", "idx": 52945, "Desc": ""}{"node_name": "RoleUnresolved(java.lang.String,java.util.List,int)", "type": "constructor", "idx": 52949, "Desc": "constructor ."}{"node_name": "RoleUnresolvedList()", "type": "constructor", "idx": 52965, "Desc": "constructs an empty roleunresolvedlist ."}{"node_name": "RoleUnresolvedList(int)", "type": "constructor", "idx": 52966, "Desc": "constructs an empty roleunresolvedlist with the initial capacity specified ."}{"node_name": "RoleUnresolvedList(java.util.List)", "type": "constructor", "idx": 52968, "Desc": "constructs a roleunresolvedlist containing the elements of the list specified , in the order in which they are returned by the list's iterator . the roleunresolvedlist instance has an initial capacity of 110% of the size of the list specified ."}{"node_name": "JMXConnectionNotification(java.lang.String,java.lang.Object,java.lang.String,long,java.lang.String,java.lang.Object)", "type": "constructor", "idx": 52994, "Desc": "constructs a new connection notification . the source of the notification depends on whether it is being sent by a connector server or a connector client : for a connector server , if it is registered in an mbean server , the source is the objectname under which it is registered . otherwise , it is a reference to the connector server object itself , an instance of a subclass of jmxconnectorserver . for a connector client , the source is a reference to the connector client object , an instance of a class implementing jmxconnector ."}{"node_name": "JMXConnectorServer()", "type": "constructor", "idx": 53040, "Desc": "constructs a connector server that will be registered as an mbean in the mbean server it is attached to . <init>() is typically called by one of the creatembean methods when creating , within an mbean server , a connector server that makes it available remotely ."}{"node_name": "JMXConnectorServer(javax.management.MBeanServer)", "type": "constructor", "idx": 53041, "Desc": "constructs a connector server that is attached to the given mbean server . a connector server that is created in this way can be registered in a different mbean server , or not registered in any mbean server ."}{"node_name": "JMXPrincipal(java.lang.String)", "type": "constructor", "idx": 53089, "Desc": "creates a jmxprincipal for a given identity ."}{"node_name": "JMXProviderException()", "type": "constructor", "idx": 53097, "Desc": "constructs a jmxproviderexception with no specified detail message ."}{"node_name": "JMXProviderException(java.lang.String)", "type": "constructor", "idx": 53098, "Desc": "constructs a jmxproviderexception with the specified detail message ."}{"node_name": "JMXProviderException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 53100, "Desc": "constructs a jmxproviderexception with the specified detail message and nested exception ."}{"node_name": "JMXServerErrorException(java.lang.String,java.lang.Error)", "type": "constructor", "idx": 53104, "Desc": "constructs a jmxservererrorexception with the specified detail message and nested error ."}{"node_name": "JMXServiceURL(java.lang.String)", "type": "constructor", "idx": 53108, "Desc": "constructs a jmxserviceurl by parsing a service url string ."}{"node_name": "JMXServiceURL(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 53110, "Desc": "constructs a jmxserviceurl with the given protocol , host , and port . <init>(java.lang.String,java.lang.String,int) is equivalent to jmxserviceurl ( protocol , host , port , null ) ."}{"node_name": "JMXServiceURL(java.lang.String,java.lang.String,int,java.lang.String)", "type": "constructor", "idx": 53114, "Desc": "constructs a jmxserviceurl with the given parts ."}{"node_name": "NotificationResult(long,long,javax.management.remote.TargetedNotification[])", "type": "constructor", "idx": 53131, "Desc": "constructs a notification query result ."}{"node_name": "RMIConnectionImpl(javax.management.remote.rmi.RMIServerImpl,java.lang.String,java.lang.ClassLoader,javax.security.auth.Subject,java.util.Map)", "type": "constructor", "idx": 53245, "Desc": "constructs a new rmiconnection . this connection can be used with the jrmp transport . this object does not export itself : it is the responsibility of the caller to export it appropriately ( see rmijrmpserverimpl.makeclient ( string , subject )) ."}{"node_name": "RMIConnector(javax.management.remote.JMXServiceURL,java.util.Map)", "type": "constructor", "idx": 53254, "Desc": "constructs an rmiconnector that will connect the rmi connector server with the given address . the address can refer directly to the connector server , using the following syntax : service : jmx : rmi :/ /[ host [: port ]] / stub / encoded-stub ( here , the square brackets [ ] are not part of the address but indicate that the host and port are optional . ) the address can instead indicate where to find an rmi stub through jndi , using the following syntax : service : jmx : rmi :/ /[ host [: port ]] / jndi / jndi-name an implementation may also recognize additional address syntaxes , for example : service : jmx : iiop :/ /[ host [: port ]] / stub / encoded-stub"}{"node_name": "RMIConnector(javax.management.remote.rmi.RMIServer,java.util.Map)", "type": "constructor", "idx": 53257, "Desc": "constructs an rmiconnector using the given rmi stub ."}{"node_name": "RMIConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map)", "type": "constructor", "idx": 53271, "Desc": "makes an rmiconnectorserver . this is equivalent to calling rmiconnectorserver ( directoryurl , environment , null , null )"}{"node_name": "RMIConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.MBeanServer)", "type": "constructor", "idx": 53274, "Desc": "makes an rmiconnectorserver for the given mbean server . this is equivalent to calling rmiconnectorserver ( directoryurl , environment , null , mbeanserver )"}{"node_name": "RMIConnectorServer(javax.management.remote.JMXServiceURL,java.util.Map,javax.management.remote.rmi.RMIServerImpl,javax.management.MBeanServer)", "type": "constructor", "idx": 53278, "Desc": "makes an rmiconnectorserver for the given mbean server ."}{"node_name": "RMIJRMPServerImpl(int,java.rmi.server.RMIClientSocketFactory,java.rmi.server.RMIServerSocketFactory,java.util.Map)", "type": "constructor", "idx": 53289, "Desc": "creates a new rmiserver object that will be exported on the given port using the given socket factories ."}{"node_name": "RMIServerImpl(java.util.Map)", "type": "constructor", "idx": 53304, "Desc": "constructs a new rmiserverimpl ."}{"node_name": "SubjectDelegationPermission(java.lang.String)", "type": "constructor", "idx": 53328, "Desc": "creates a new subjectdelegationpermission with the specified name . the name is the symbolic name of the subjectdelegationpermission ."}{"node_name": "SubjectDelegationPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 53330, "Desc": "creates a new subjectdelegationpermission object with the specified name . the name is the symbolic name of the subjectdelegationpermission , and the actions string is currently unused and must be null ."}{"node_name": "TargetedNotification(javax.management.Notification,java.lang.Integer)", "type": "constructor", "idx": 53334, "Desc": "constructs a targetednotification object . the object contains a pair ( notification , listener id ) . the listener id identifies the client listener to which that notification is targeted . the client listener id is one previously returned by the connector server in response to an addnotificationlistener request ."}{"node_name": "RuntimeErrorException(java.lang.Error)", "type": "constructor", "idx": 53341, "Desc": "default constructor ."}{"node_name": "RuntimeErrorException(java.lang.Error,java.lang.String)", "type": "constructor", "idx": 53343, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "RuntimeMBeanException(java.lang.RuntimeException)", "type": "constructor", "idx": 53349, "Desc": "creates a runtimembeanexception that wraps the actual java.lang.runtimeexception ."}{"node_name": "RuntimeMBeanException(java.lang.RuntimeException,java.lang.String)", "type": "constructor", "idx": 53351, "Desc": "creates a runtimembeanexception that wraps the actual java.lang.runtimeexception with a detailed message ."}{"node_name": "RuntimeOperationsException(java.lang.RuntimeException)", "type": "constructor", "idx": 53357, "Desc": "creates a runtimeoperationsexception that wraps the actual java.lang.runtimeexception ."}{"node_name": "RuntimeOperationsException(java.lang.RuntimeException,java.lang.String)", "type": "constructor", "idx": 53359, "Desc": "creates a runtimeoperationsexception that wraps the actual java.lang.runtimeexception with a detailed message ."}{"node_name": "ServiceNotFoundException()", "type": "constructor", "idx": 53365, "Desc": "default constructor ."}{"node_name": "ServiceNotFoundException(java.lang.String)", "type": "constructor", "idx": 53366, "Desc": "constructor that allows a specific error message to be specified ."}{"node_name": "StandardEmitterMBean(java.lang.Object,java.lang.Class,javax.management.NotificationEmitter)", "type": "constructor", "idx": 53369, "Desc": "make an mbean whose management interface is specified by mbeaninterface , with the given implementation and where notifications are handled by the given notificationemitter . the resultant mbean implements the notificationemitter interface by forwarding its methods to emitter . it is legal and useful for implementation and emitter to be the same object . if emitter is an instance of notificationbroadcastersupport then the mbean's sendnotification method will call emitter.sendnotification . the array returned by notificationbroadcaster.getnotificationinfo() on the new mbean is a copy of the array returned by emitter.getnotificationinfo() at the time of construction . if the array returned by emitter.getnotificationinfo() later changes , that will have no effect on this object's getnotificationinfo() ."}{"node_name": "StandardEmitterMBean(java.lang.Object,java.lang.Class,boolean,javax.management.NotificationEmitter)", "type": "constructor", "idx": 53373, "Desc": "make an mbean whose management interface is specified by mbeaninterface , with the given implementation and where notifications are handled by the given notificationemitter . <init>(java.lang.Object,java.lang.Class,boolean,javax.management.NotificationEmitter) can be used to make either standard mbeans or mxbeans . the resultant mbean implements the notificationemitter interface by forwarding its methods to emitter . it is legal and useful for implementation and emitter to be the same object . if emitter is an instance of notificationbroadcastersupport then the mbean's sendnotification method will call emitter.sendnotification . the array returned by notificationbroadcaster.getnotificationinfo() on the new mbean is a copy of the array returned by emitter.getnotificationinfo() at the time of construction . if the array returned by emitter.getnotificationinfo() later changes , that will have no effect on this object's getnotificationinfo() ."}{"node_name": "StandardEmitterMBean(java.lang.Class,javax.management.NotificationEmitter)", "type": "constructor", "idx": 53378, "Desc": "make an mbean whose management interface is specified by mbeaninterface , and where notifications are handled by the given notificationemitter . the resultant mbean implements the notificationemitter interface by forwarding its methods to emitter . if emitter is an instance of notificationbroadcastersupport then the mbean's sendnotification method will call emitter.sendnotification . the array returned by notificationbroadcaster.getnotificationinfo() on the new mbean is a copy of the array returned by emitter.getnotificationinfo() at the time of construction . if the array returned by emitter.getnotificationinfo() later changes , that will have no effect on this object's getnotificationinfo() . <init>(java.lang.Class,javax.management.NotificationEmitter) must be called from a subclass that implements the given mbeaninterface ."}{"node_name": "StandardEmitterMBean(java.lang.Class,boolean,javax.management.NotificationEmitter)", "type": "constructor", "idx": 53381, "Desc": "make an mbean whose management interface is specified by mbeaninterface , and where notifications are handled by the given notificationemitter . <init>(java.lang.Class,boolean,javax.management.NotificationEmitter) can be used to make either standard mbeans or mxbeans . the resultant mbean implements the notificationemitter interface by forwarding its methods to emitter . if emitter is an instance of notificationbroadcastersupport then the mbean's sendnotification method will call emitter.sendnotification . the array returned by notificationbroadcaster.getnotificationinfo() on the new mbean is a copy of the array returned by emitter.getnotificationinfo() at the time of construction . if the array returned by emitter.getnotificationinfo() later changes , that will have no effect on this object's getnotificationinfo() . <init>(java.lang.Class,boolean,javax.management.NotificationEmitter) must be called from a subclass that implements the given mbeaninterface ."}{"node_name": "StandardMBean(java.lang.Object,java.lang.Class)", "type": "constructor", "idx": 53388, "Desc": "make a dynamicmbean out of the object implementation , using the specified mbeaninterface class ."}{"node_name": "StandardMBean(java.lang.Class)", "type": "constructor", "idx": 53391, "Desc": "make a dynamicmbean out of this , using the specified mbeaninterface class . calls this ( this , mbeaninterface ) . <init>(java.lang.Class) is reserved to subclasses ."}{"node_name": "StandardMBean(java.lang.Object,java.lang.Class,boolean)", "type": "constructor", "idx": 53393, "Desc": "make a dynamicmbean out of the object implementation , using the specified mbeaninterface class , and choosing whether the resultant mbean is an mxbean . <init>(java.lang.Object,java.lang.Class,boolean) can be used to make either standard mbeans or mxbeans . unlike <init>(java.lang.Object,java.lang.Class,boolean) standardmbean ( object , class ) , it does not throw notcompliantmbeanexception ."}{"node_name": "StandardMBean(java.lang.Class,boolean)", "type": "constructor", "idx": 53397, "Desc": "make a dynamicmbean out of this , using the specified mbeaninterface class , and choosing whether the resulting mbean is an mxbean . <init>(java.lang.Class,boolean) can be used to make either standard mbeans or mxbeans . unlike <init>(java.lang.Class,boolean) standardmbean ( object , class ) , it does not throw notcompliantmbeanexception . calls this ( this , mbeaninterface , ismxbean ) . <init>(java.lang.Class,boolean) is reserved to subclasses ."}{"node_name": "StringValueExp()", "type": "constructor", "idx": 53450, "Desc": "basic constructor ."}{"node_name": "StringValueExp(java.lang.String)", "type": "constructor", "idx": 53451, "Desc": "creates a new stringvalueexp representing the given string ."}{"node_name": "Timer()", "type": "constructor", "idx": 53463, "Desc": "default constructor ."}{"node_name": "TimerNotification(java.lang.String,java.lang.Object,long,long,java.lang.String,java.lang.Integer)", "type": "constructor", "idx": 53585, "Desc": "creates a timer notification object ."}{"node_name": "AuthenticationException(java.lang.String)", "type": "constructor", "idx": 53597, "Desc": "constructs a new instance of authenticationexception using the explanation supplied . all other fields default to null ."}{"node_name": "AuthenticationException()", "type": "constructor", "idx": 53599, "Desc": "constructs a new instance of authenticationexception . all fields are set to null ."}{"node_name": "AuthenticationNotSupportedException(java.lang.String)", "type": "constructor", "idx": 53601, "Desc": "constructs a new instance of authenticationnotsupportedexception using an explanation . all other fields default to null ."}{"node_name": "AuthenticationNotSupportedException()", "type": "constructor", "idx": 53603, "Desc": "constructs a new instance of authenticationnotsupportedexception with all name resolution fields and explanation initialized to null ."}{"node_name": "BinaryRefAddr(java.lang.String,byte[])", "type": "constructor", "idx": 53605, "Desc": "constructs a new instance of binaryrefaddr using its address type and a byte array for contents ."}{"node_name": "BinaryRefAddr(java.lang.String,byte[],int,int)", "type": "constructor", "idx": 53608, "Desc": "constructs a new instance of binaryrefaddr using its address type and a region of a byte array for contents ."}{"node_name": "Binding(java.lang.String,java.lang.Object)", "type": "constructor", "idx": 53619, "Desc": "constructs an instance of a binding given its name and object . getclassname() will return the class name of obj ( or null if obj is null ) unless the class name has been explicitly set using setclassname()"}{"node_name": "Binding(java.lang.String,java.lang.Object,boolean)", "type": "constructor", "idx": 53622, "Desc": "constructs an instance of a binding given its name , object , and whether the name is relative . getclassname() will return the class name of obj ( or null if obj is null ) unless the class name has been explicitly set using setclassname()"}{"node_name": "Binding(java.lang.String,java.lang.String,java.lang.Object)", "type": "constructor", "idx": 53626, "Desc": "constructs an instance of a binding given its name , class name , and object ."}{"node_name": "Binding(java.lang.String,java.lang.String,java.lang.Object,boolean)", "type": "constructor", "idx": 53630, "Desc": "constructs an instance of a binding given its name , class name , object , and whether the name is relative ."}{"node_name": "CannotProceedException(java.lang.String)", "type": "constructor", "idx": 53645, "Desc": "constructs a new instance of cannotproceedexception using an explanation . all unspecified fields default to null ."}{"node_name": "CannotProceedException()", "type": "constructor", "idx": 53647, "Desc": "constructs a new instance of cannotproceedexception . all fields default to null ."}{"node_name": "CommunicationException(java.lang.String)", "type": "constructor", "idx": 53661, "Desc": "constructs a new instance of communicationexception using the arguments supplied ."}{"node_name": "CommunicationException()", "type": "constructor", "idx": 53663, "Desc": "constructs a new instance of communicationexception ."}{"node_name": "CompositeName(java.util.Enumeration)", "type": "constructor", "idx": 53665, "Desc": "constructs a new composite name instance using the components specified by ' comps ' . this protected method is intended to be used by subclasses of compositename when they override methods such as clone() , getprefix() , getsuffix() ."}{"node_name": "CompositeName(java.lang.String)", "type": "constructor", "idx": 53667, "Desc": "constructs a new composite name instance by parsing the string n using the composite name syntax ( left-to-right , slash separated ) . the composite name syntax is described in detail in the class description ."}{"node_name": "CompositeName()", "type": "constructor", "idx": 53669, "Desc": "constructs a new empty composite name . such a name returns true when isempty() is invoked on it ."}{"node_name": "CompoundName(java.util.Enumeration,java.util.Properties)", "type": "constructor", "idx": 53704, "Desc": "constructs a new compound name instance using the components specified in comps and syntax . this protected method is intended to be used by subclasses of compoundname when they override methods such as clone() , getprefix() , getsuffix() ."}{"node_name": "CompoundName(java.lang.String,java.util.Properties)", "type": "constructor", "idx": 53707, "Desc": "constructs a new compound name instance by parsing the string n using the syntax specified by the syntax properties supplied ."}{"node_name": "ConfigurationException(java.lang.String)", "type": "constructor", "idx": 53743, "Desc": "constructs a new instance of configurationexception using an explanation . all other fields default to null ."}{"node_name": "ConfigurationException()", "type": "constructor", "idx": 53745, "Desc": "constructs a new instance of configurationexception with all name resolution fields and explanation initialized to null ."}{"node_name": "ContextNotEmptyException(java.lang.String)", "type": "constructor", "idx": 53826, "Desc": "constructs a new instance of contextnotemptyexception using an explanation . all other fields default to null ."}{"node_name": "ContextNotEmptyException()", "type": "constructor", "idx": 53828, "Desc": "constructs a new instance of contextnotemptyexception with all name resolution fields and explanation initialized to null ."}{"node_name": "AttributeInUseException(java.lang.String)", "type": "constructor", "idx": 53856, "Desc": "constructs a new instance of attributeinuseexception with an explanation . all other fields are set to null ."}{"node_name": "AttributeInUseException()", "type": "constructor", "idx": 53858, "Desc": "constructs a new instance of attributeinuseexception . all fields are initialized to null ."}{"node_name": "AttributeModificationException(java.lang.String)", "type": "constructor", "idx": 53860, "Desc": "constructs a new instance of attributemodificationexception using an explanation . all other fields are set to null ."}{"node_name": "AttributeModificationException()", "type": "constructor", "idx": 53862, "Desc": "constructs a new instance of attributemodificationexception . all fields are set to null ."}{"node_name": "BasicAttribute(java.lang.String)", "type": "constructor", "idx": 53886, "Desc": "constructs a new instance of an unordered attribute with no value ."}{"node_name": "BasicAttribute(java.lang.String,java.lang.Object)", "type": "constructor", "idx": 53888, "Desc": "constructs a new instance of an unordered attribute with a single value ."}{"node_name": "BasicAttribute(java.lang.String,boolean)", "type": "constructor", "idx": 53891, "Desc": "constructs a new instance of a possibly ordered attribute with no value ."}{"node_name": "BasicAttribute(java.lang.String,java.lang.Object,boolean)", "type": "constructor", "idx": 53894, "Desc": "constructs a new instance of a possibly ordered attribute with a single value ."}{"node_name": "BasicAttributes()", "type": "constructor", "idx": 53913, "Desc": "constructs a new instance of attributes . the character case of attribute identifiers is significant when subsequently retrieving or adding attributes ."}{"node_name": "BasicAttributes(boolean)", "type": "constructor", "idx": 53914, "Desc": "constructs a new instance of attributes . if ignorecase is true , the character case of attribute identifiers is ignored ; otherwise the case is significant ."}{"node_name": "BasicAttributes(java.lang.String,java.lang.Object)", "type": "constructor", "idx": 53916, "Desc": "constructs a new instance of attributes with one attribute . the attribute specified by attrid and val are added to the newly created attribute . the character case of attribute identifiers is significant when subsequently retrieving or adding attributes ."}{"node_name": "BasicAttributes(java.lang.String,java.lang.Object,boolean)", "type": "constructor", "idx": 53919, "Desc": "constructs a new instance of attributes with one attribute . the attribute specified by attrid and val are added to the newly created attribute . if ignorecase is true , the character case of attribute identifiers is ignored ; otherwise the case is significant ."}{"node_name": "InitialDirContext(boolean)", "type": "constructor", "idx": 54019, "Desc": "constructs an initial dircontext with the option of not initializing it . this may be used by a constructor in a subclass when the value of the environment parameter is not yet known at the time the initialdircontext constructor is called . the subclass's constructor will call <init>(boolean) , compute the value of the environment , and then call init() before returning ."}{"node_name": "InitialDirContext()", "type": "constructor", "idx": 54021, "Desc": "constructs an initial dircontext . no environment properties are supplied . equivalent to new initialdircontext ( null ) ."}{"node_name": "InitialDirContext(java.util.Hashtable)", "type": "constructor", "idx": 54022, "Desc": "constructs an initial dircontext using the supplied environment . environment properties are discussed in the javax.naming.initialcontext class description . if the java.naming.provider.url property of the supplied environment consists of a url ( or a list of urls ) using the ldap protocol the resulting ldapcontext will use an ldap server resolved by the configured ldapdnsproviders : if this is the first initialdircontext created with a java.naming.provider.url using the ldap protocol then the serviceloader mechanism is used to locate ldapdnsprovider implementations using the system class loader . the order that providers are located is implementation specific and an implementation is free to cache the located providers . the lookupendpoints method of each provider , if instantiated , is invoked once with a combination of each of the urls in the the java.naming.provider.url property and the environment until a provider returns non-empty or all providers have been exhausted . if none of the ldapdnsproviders return a non-empty result then the implementation will make a best-effort attempt to determine an endpoint . a serviceconfigurationerror , error or runtimeexception thrown when loading or calling an ldapdnsprovider , if encountered , will be propagated to the calling thread . <init>(java.util.Hashtable) will not modify environment or save a reference to it , but may save a clone . caller should not modify mutable keys and values in environment after it has been passed to <init>(java.util.Hashtable) ."}{"node_name": "InvalidAttributeIdentifierException(java.lang.String)", "type": "constructor", "idx": 54025, "Desc": "constructs a new instance of invalidattributeidentifierexception using the explanation supplied . all other fields set to null ."}{"node_name": "InvalidAttributeIdentifierException()", "type": "constructor", "idx": 54027, "Desc": "constructs a new instance of invalidattributeidentifierexception . all fields are set to null ."}{"node_name": "InvalidAttributesException(java.lang.String)", "type": "constructor", "idx": 54029, "Desc": "constructs a new instance of invalidattributesexception using an explanation . all other fields are set to null ."}{"node_name": "InvalidAttributesException()", "type": "constructor", "idx": 54031, "Desc": "constructs a new instance of invalidattributesexception . all fields are set to null ."}{"node_name": "InvalidAttributeValueException(java.lang.String)", "type": "constructor", "idx": 54033, "Desc": "constructs a new instance of invalidattributevalueexception using an explanation . all other fields are set to null ."}{"node_name": "InvalidAttributeValueException()", "type": "constructor", "idx": 54035, "Desc": "constructs a new instance of invalidattributevalueexception . all fields are set to null ."}{"node_name": "InvalidSearchControlsException()", "type": "constructor", "idx": 54037, "Desc": "constructs a new instance of invalidsearchcontrolsexception . all fields are set to null ."}{"node_name": "InvalidSearchControlsException(java.lang.String)", "type": "constructor", "idx": 54038, "Desc": "constructs a new instance of invalidsearchcontrolsexception with an explanation . all other fields set to null ."}{"node_name": "InvalidSearchFilterException()", "type": "constructor", "idx": 54041, "Desc": "constructs a new instance of invalidsearchfilterexception . all fields are set to null ."}{"node_name": "InvalidSearchFilterException(java.lang.String)", "type": "constructor", "idx": 54042, "Desc": "constructs a new instance of invalidsearchfilterexception with an explanation . all other fields are set to null ."}{"node_name": "ModificationItem(int,javax.naming.directory.Attribute)", "type": "constructor", "idx": 54045, "Desc": "creates a new instance of modificationitem ."}{"node_name": "NoSuchAttributeException(java.lang.String)", "type": "constructor", "idx": 54052, "Desc": "constructs a new instance of nosuchattributeexception using an explanation . all other fields are set to null ."}{"node_name": "NoSuchAttributeException()", "type": "constructor", "idx": 54054, "Desc": "constructs a new instance of nosuchattributeexception . all fields are initialized to null ."}{"node_name": "SchemaViolationException()", "type": "constructor", "idx": 54056, "Desc": "constructs a new instance of schemaviolationexception . all fields are set to null ."}{"node_name": "SchemaViolationException(java.lang.String)", "type": "constructor", "idx": 54057, "Desc": "constructs a new instance of schemaviolationexception using the explanation supplied . all other fields are set to null ."}{"node_name": "SearchControls()", "type": "constructor", "idx": 54063, "Desc": "constructs a search constraints using defaults . the defaults are : search one level no maximum return limit for search results no time limit for search return all attributes associated with objects that satisfy the search filter . do not return named object ( return only name and class ) do not dereference links during search"}{"node_name": "SearchControls(int,long,int,java.lang.String[],boolean,boolean)", "type": "constructor", "idx": 54064, "Desc": "constructs a search constraints using arguments ."}{"node_name": "SearchResult(java.lang.String,java.lang.Object,javax.naming.directory.Attributes)", "type": "constructor", "idx": 54090, "Desc": "constructs a search result using the result's name , its bound object , and its attributes . getclassname() will return the class name of obj ( or null if obj is null ) unless the class name has been explicitly set using setclassname() ."}{"node_name": "SearchResult(java.lang.String,java.lang.Object,javax.naming.directory.Attributes,boolean)", "type": "constructor", "idx": 54094, "Desc": "constructs a search result using the result's name , its bound object , and its attributes , and whether the name is relative . getclassname() will return the class name of obj ( or null if obj is null ) unless the class name has been explicitly set using setclassname()"}{"node_name": "SearchResult(java.lang.String,java.lang.String,java.lang.Object,javax.naming.directory.Attributes)", "type": "constructor", "idx": 54099, "Desc": "constructs a search result using the result's name , its class name , its bound object , and its attributes ."}{"node_name": "SearchResult(java.lang.String,java.lang.String,java.lang.Object,javax.naming.directory.Attributes,boolean)", "type": "constructor", "idx": 54104, "Desc": "constructs a search result using the result's name , its class name , its bound object , its attributes , and whether the name is relative ."}{"node_name": "NamingEvent(javax.naming.event.EventContext,int,javax.naming.Binding,javax.naming.Binding,java.lang.Object)", "type": "constructor", "idx": 54168, "Desc": "constructs an instance of namingevent . the names in newbd and oldbd are to be resolved relative to the event source source . for an object_added event type , newbd must not be null . for an object_removed event type , oldbd must not be null . for an object_changed event type , newbd and oldbd must not be null . for an object_renamed event type , one of newbd or oldbd may be null if the new or old binding is outside of the scope for which the listener has registered ."}{"node_name": "NamingExceptionEvent(javax.naming.event.EventContext,javax.naming.NamingException)", "type": "constructor", "idx": 54182, "Desc": "constructs an instance of namingexceptionevent using the context in which the namingexception was thrown and the exception that was thrown ."}{"node_name": "InitialContext(boolean)", "type": "constructor", "idx": 54199, "Desc": "constructs an initial context with the option of not initializing it . this may be used by a constructor in a subclass when the value of the environment parameter is not yet known at the time the initialcontext constructor is called . the subclass's constructor will call <init>(boolean) , compute the value of the environment , and then call init() before returning ."}{"node_name": "InitialContext()", "type": "constructor", "idx": 54201, "Desc": "constructs an initial context . no environment properties are supplied . equivalent to new initialcontext ( null ) ."}{"node_name": "InitialContext(java.util.Hashtable)", "type": "constructor", "idx": 54202, "Desc": "constructs an initial context using the supplied environment . environment properties are discussed in the class description . <init>(java.util.Hashtable) will not modify environment or save a reference to it , but may save a clone . caller should not modify mutable keys and values in environment after it has been passed to <init>(java.util.Hashtable) ."}{"node_name": "InsufficientResourcesException(java.lang.String)", "type": "constructor", "idx": 54222, "Desc": "constructs a new instance of insufficientresourcesexception using an explanation . all other fields default to null ."}{"node_name": "InsufficientResourcesException()", "type": "constructor", "idx": 54224, "Desc": "constructs a new instance of insufficientresourcesexception with all name resolution fields and explanation initialized to null ."}{"node_name": "InterruptedNamingException(java.lang.String)", "type": "constructor", "idx": 54226, "Desc": "constructs an instance of interruptednamingexception using an explanation of the problem . all name resolution-related fields are initialized to null ."}{"node_name": "InterruptedNamingException()", "type": "constructor", "idx": 54228, "Desc": "constructs an instance of interruptednamingexception with all name resolution fields and explanation initialized to null ."}{"node_name": "InvalidNameException(java.lang.String)", "type": "constructor", "idx": 54230, "Desc": "constructs an instance of invalidnameexception using an explanation of the problem . all other fields are initialized to null ."}{"node_name": "InvalidNameException()", "type": "constructor", "idx": 54232, "Desc": "constructs an instance of invalidnameexception with all fields set to null ."}{"node_name": "BasicControl(java.lang.String)", "type": "constructor", "idx": 54237, "Desc": "constructs a non-critical control ."}{"node_name": "BasicControl(java.lang.String,boolean,byte[])", "type": "constructor", "idx": 54239, "Desc": "constructs a control using the supplied arguments ."}{"node_name": "ControlFactory()", "type": "constructor", "idx": 54253, "Desc": "creates a new instance of a control factory ."}{"node_name": "InitialLdapContext()", "type": "constructor", "idx": 54274, "Desc": "constructs an initial context using no environment properties or connection request controls . equivalent to new initialldapcontext ( null , null ) ."}{"node_name": "InitialLdapContext(java.util.Hashtable,javax.naming.ldap.Control[])", "type": "constructor", "idx": 54275, "Desc": "constructs an initial context using environment properties and connection request controls . see javax.naming.initialcontext for a discussion of environment properties . <init>(java.util.Hashtable,javax.naming.ldap.Control[]) will not modify its parameters or save references to them , but may save a clone or copy . caller should not modify mutable keys and values in environment after it has been passed to <init>(java.util.Hashtable,javax.naming.ldap.Control[]) . connctls is used as the underlying context instance's connection request controls . see the class description for details ."}{"node_name": "LdapName(java.lang.String)", "type": "constructor", "idx": 54292, "Desc": "constructs an ldap name from the given distinguished name ."}{"node_name": "LdapName(java.util.List)", "type": "constructor", "idx": 54294, "Desc": "constructs an ldap name given its parsed rdn components . the indexing of rdns in the list follows the numbering of rdns described in the class description ."}{"node_name": "LdapReferralException(java.lang.String)", "type": "constructor", "idx": 54346, "Desc": "constructs a new instance of ldapreferralexception using the explanation supplied . all other fields are set to null ."}{"node_name": "LdapReferralException()", "type": "constructor", "idx": 54348, "Desc": "constructs a new instance of ldapreferralexception . all fields are set to null ."}{"node_name": "ManageReferralControl()", "type": "constructor", "idx": 54357, "Desc": "constructs a critical managereferral control ."}{"node_name": "ManageReferralControl(boolean)", "type": "constructor", "idx": 54358, "Desc": "constructs a managereferral control ."}{"node_name": "PagedResultsControl(int,boolean)", "type": "constructor", "idx": 54362, "Desc": "constructs a control to set the number of entries to be returned per page of results ."}{"node_name": "PagedResultsControl(int,byte[],boolean)", "type": "constructor", "idx": 54365, "Desc": "constructs a control to set the number of entries to be returned per page of results . the cookie is provided by the server and may be obtained from the paged-results response control . a sequence of paged-results can be abandoned by setting the pagesize to zero and setting the cookie to the last cookie received from the server ."}{"node_name": "PagedResultsResponseControl(java.lang.String,boolean,byte[])", "type": "constructor", "idx": 54371, "Desc": "constructs a paged-results response control ."}{"node_name": "Rdn(javax.naming.directory.Attributes)", "type": "constructor", "idx": 54378, "Desc": "constructs an rdn from the given attribute set . see attributes . the string attribute values are not interpreted as rfc 2253 formatted rdn strings . that is , the values are used literally ( not parsed ) and assumed to be unescaped ."}{"node_name": "Rdn(java.lang.String)", "type": "constructor", "idx": 54380, "Desc": "constructs an rdn from the given string . <init>(java.lang.String) takes a string formatted according to the rules defined in rfc 2253 and described in the class description for ldapname ."}{"node_name": "Rdn(javax.naming.ldap.Rdn)", "type": "constructor", "idx": 54382, "Desc": "constructs an rdn from the given rdn . the contents of the rdn are simply copied into the newly created rdn ."}{"node_name": "Rdn(java.lang.String,java.lang.Object)", "type": "constructor", "idx": 54384, "Desc": "constructs an rdn from the given attribute type and value . the string attribute values are not interpreted as rfc 2253 formatted rdn strings . that is , the values are used literally ( not parsed ) and assumed to be unescaped ."}{"node_name": "SortControl(java.lang.String,boolean)", "type": "constructor", "idx": 54403, "Desc": "constructs a control to sort on a single attribute in ascending order . sorting will be performed using the ordering matching rule defined for use with the specified attribute ."}{"node_name": "SortControl(java.lang.String[],boolean)", "type": "constructor", "idx": 54406, "Desc": "constructs a control to sort on a list of attributes in ascending order . sorting will be performed using the ordering matching rule defined for use with each of the specified attributes ."}{"node_name": "SortControl(javax.naming.ldap.SortKey[],boolean)", "type": "constructor", "idx": 54409, "Desc": "constructs a control to sort on a list of sort keys . each sort key specifies the sort order and ordering matching rule to use ."}{"node_name": "SortKey(java.lang.String)", "type": "constructor", "idx": 54413, "Desc": "creates the default sort key for an attribute . entries will be sorted according to the specified attribute in ascending order using the ordering matching rule defined for use with that attribute ."}{"node_name": "SortKey(java.lang.String,boolean,java.lang.String)", "type": "constructor", "idx": 54415, "Desc": "creates a sort key for an attribute . entries will be sorted according to the specified attribute in the specified sort order and using the specified matching rule , if supplied ."}{"node_name": "SortResponseControl(java.lang.String,boolean,byte[])", "type": "constructor", "idx": 54424, "Desc": "constructs a control to indicate the outcome of a sort request ."}{"node_name": "LdapDnsProvider()", "type": "constructor", "idx": 54433, "Desc": "creates a new instance of ldapdnsprovider ."}{"node_name": "LdapDnsProviderResult(java.lang.String,java.util.List)", "type": "constructor", "idx": 54438, "Desc": "construct an ldapdnsproviderresult consisting of a resolved domain name and the ldap server endpoints that serve the domain ."}{"node_name": "StartTlsRequest()", "type": "constructor", "idx": 54445, "Desc": "constructs a starttls extended request ."}{"node_name": "StartTlsResponse()", "type": "constructor", "idx": 54455, "Desc": "constructs a starttls extended response . a concrete subclass must have a public no-arg constructor ."}{"node_name": "UnsolicitedNotificationEvent(java.lang.Object,javax.naming.ldap.UnsolicitedNotification)", "type": "constructor", "idx": 54470, "Desc": "constructs a new instance of unsolicitednotificationevent ."}{"node_name": "LimitExceededException()", "type": "constructor", "idx": 54480, "Desc": "constructs a new instance of limitexceededexception with all name resolution fields and explanation initialized to null ."}{"node_name": "LimitExceededException(java.lang.String)", "type": "constructor", "idx": 54481, "Desc": "constructs a new instance of limitexceededexception using an explanation . all other fields default to null ."}{"node_name": "LinkException(java.lang.String)", "type": "constructor", "idx": 54488, "Desc": "constructs a new instance of linkexception with an explanation . all the other fields are initialized to null ."}{"node_name": "LinkException()", "type": "constructor", "idx": 54490, "Desc": "constructs a new instance of linkexception . all the non-link-related and link-related fields are initialized to null ."}{"node_name": "LinkLoopException(java.lang.String)", "type": "constructor", "idx": 54507, "Desc": "constructs a new instance of linkloopexception with an explanation . all the other fields are initialized to null ."}{"node_name": "LinkLoopException()", "type": "constructor", "idx": 54509, "Desc": "constructs a new instance of linkloopexception . all the non-link-related and link-related fields are initialized to null ."}{"node_name": "LinkRef(javax.naming.Name)", "type": "constructor", "idx": 54511, "Desc": "constructs a linkref for a name ."}{"node_name": "LinkRef(java.lang.String)", "type": "constructor", "idx": 54513, "Desc": "constructs a linkref for a string name ."}{"node_name": "MalformedLinkException(java.lang.String)", "type": "constructor", "idx": 54517, "Desc": "constructs a new instance of malformedlinkexception with an explanation . all the other fields are initialized to null ."}{"node_name": "MalformedLinkException()", "type": "constructor", "idx": 54519, "Desc": "constructs a new instance of malformed linkexception . all fields are initialized to null ."}{"node_name": "NameAlreadyBoundException(java.lang.String)", "type": "constructor", "idx": 54550, "Desc": "constructs a new instance of namealreadyboundexception using the explanation supplied . all other fields default to null ."}{"node_name": "NameAlreadyBoundException()", "type": "constructor", "idx": 54552, "Desc": "constructs a new instance of namealreadyboundexception . all fields are set to null ;"}{"node_name": "NameClassPair(java.lang.String,java.lang.String)", "type": "constructor", "idx": 54554, "Desc": "constructs an instance of a nameclasspair given its name and class name ."}{"node_name": "NameClassPair(java.lang.String,java.lang.String,boolean)", "type": "constructor", "idx": 54557, "Desc": "constructs an instance of a nameclasspair given its name , class name , and whether it is relative to the listing context ."}{"node_name": "NameNotFoundException(java.lang.String)", "type": "constructor", "idx": 54575, "Desc": "constructs a new instance of namenotfoundexception using the explanation supplied . all other fields default to null ."}{"node_name": "NameNotFoundException()", "type": "constructor", "idx": 54577, "Desc": "constructs a new instance of namenotfoundexception . all name resolution fields and explanation initialized to null ."}{"node_name": "NamingException(java.lang.String)", "type": "constructor", "idx": 54590, "Desc": "constructs a new namingexception with an explanation . all unspecified fields are set to null ."}{"node_name": "NamingException()", "type": "constructor", "idx": 54592, "Desc": "constructs a new namingexception . all fields are set to null ."}{"node_name": "NamingSecurityException(java.lang.String)", "type": "constructor", "idx": 54617, "Desc": "constructs a new instance of namingsecurityexception using the explanation supplied . all other fields default to null ."}{"node_name": "NamingSecurityException()", "type": "constructor", "idx": 54619, "Desc": "constructs a new instance of namingsecurityexception . all fields are initialized to null ."}{"node_name": "NoInitialContextException()", "type": "constructor", "idx": 54621, "Desc": "constructs an instance of noinitialcontextexception . all fields are initialized to null ."}{"node_name": "NoInitialContextException(java.lang.String)", "type": "constructor", "idx": 54622, "Desc": "constructs an instance of noinitialcontextexception with an explanation . all other fields are initialized to null ."}{"node_name": "NoPermissionException(java.lang.String)", "type": "constructor", "idx": 54625, "Desc": "constructs a new instance of nopermissionexception using an explanation . all other fields default to null ."}{"node_name": "NoPermissionException()", "type": "constructor", "idx": 54627, "Desc": "constructs a new instance of nopermissionexception . all fields are initialized to null ."}{"node_name": "NotContextException(java.lang.String)", "type": "constructor", "idx": 54629, "Desc": "constructs a new instance of notcontextexception using an explanation . all other fields default to null ."}{"node_name": "NotContextException()", "type": "constructor", "idx": 54631, "Desc": "constructs a new instance of notcontextexception . all fields default to null ."}{"node_name": "OperationNotSupportedException()", "type": "constructor", "idx": 54633, "Desc": "constructs a new instance of operationnotsupportedexception . all fields default to null ."}{"node_name": "OperationNotSupportedException(java.lang.String)", "type": "constructor", "idx": 54634, "Desc": "constructs a new instance of operationnotsupportedexception using an explanation . all other fields default to null ."}{"node_name": "PartialResultException(java.lang.String)", "type": "constructor", "idx": 54637, "Desc": "constructs a new instance of the exception using the explanation message specified . all other fields default to null ."}{"node_name": "PartialResultException()", "type": "constructor", "idx": 54639, "Desc": "constructs a new instance of partialresultexception . all fields default to null ."}{"node_name": "RefAddr(java.lang.String)", "type": "constructor", "idx": 54642, "Desc": "constructs a new instance of refaddr using its address type ."}{"node_name": "Reference(java.lang.String)", "type": "constructor", "idx": 54655, "Desc": "constructs a new reference for an object with class name ' classname ' . class factory and class factory location are set to null . the newly created reference contains zero addresses ."}{"node_name": "Reference(java.lang.String,javax.naming.RefAddr)", "type": "constructor", "idx": 54657, "Desc": "constructs a new reference for an object with class name ' classname ' and an address . class factory and class factory location are set to null ."}{"node_name": "Reference(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 54660, "Desc": "constructs a new reference for an object with class name ' classname ' , and the class name and location of the object's factory ."}{"node_name": "Reference(java.lang.String,javax.naming.RefAddr,java.lang.String,java.lang.String)", "type": "constructor", "idx": 54664, "Desc": "constructs a new reference for an object with class name ' classname ' , the class name and location of the object's factory , and the address for the object ."}{"node_name": "ReferralException(java.lang.String)", "type": "constructor", "idx": 54694, "Desc": "constructs a new instance of referralexception using the explanation supplied . all other fields are set to null ."}{"node_name": "ReferralException()", "type": "constructor", "idx": 54696, "Desc": "constructs a new instance of referralexception . all fields are set to null ."}{"node_name": "ServiceUnavailableException(java.lang.String)", "type": "constructor", "idx": 54704, "Desc": "constructs a new instance of serviceunavailableexception using an explanation . all other fields default to null ."}{"node_name": "ServiceUnavailableException()", "type": "constructor", "idx": 54706, "Desc": "constructs a new instance of serviceunavailableexception . all fields default to null ."}{"node_name": "SizeLimitExceededException()", "type": "constructor", "idx": 54708, "Desc": "constructs a new instance of sizelimitexceededexception . all fields default to null ."}{"node_name": "SizeLimitExceededException(java.lang.String)", "type": "constructor", "idx": 54709, "Desc": "constructs a new instance of sizelimitexceededexception using an explanation . all other fields default to null ."}{"node_name": "Result(java.lang.Object,javax.naming.directory.Attributes)", "type": "constructor", "idx": 54741, "Desc": "constructs an instance of result ."}{"node_name": "ResolveResult()", "type": "constructor", "idx": 54796, "Desc": "constructs an instance of resolveresult with the resolved object and remaining name both initialized to null ."}{"node_name": "ResolveResult(java.lang.Object,java.lang.String)", "type": "constructor", "idx": 54797, "Desc": "constructs a new instance of resolveresult consisting of the resolved object and the remaining unresolved component ."}{"node_name": "ResolveResult(java.lang.Object,javax.naming.Name)", "type": "constructor", "idx": 54800, "Desc": "constructs a new instance of resolveresult consisting of the resolved object and the remaining name ."}{"node_name": "StringRefAddr(java.lang.String,java.lang.String)", "type": "constructor", "idx": 54820, "Desc": "constructs a new instance of stringrefaddr using its address type and contents ."}{"node_name": "TimeLimitExceededException()", "type": "constructor", "idx": 54825, "Desc": "constructs a new instance of timelimitexceededexception . all fields default to null ."}{"node_name": "TimeLimitExceededException(java.lang.String)", "type": "constructor", "idx": 54826, "Desc": "constructs a new instance of timelimitexceededexception using the argument supplied ."}{"node_name": "ServerSocketFactory()", "type": "constructor", "idx": 54829, "Desc": "creates a server socket factory ."}{"node_name": "SocketFactory()", "type": "constructor", "idx": 54842, "Desc": "creates a socketfactory ."}{"node_name": "CertPathTrustManagerParameters(java.security.cert.CertPathParameters)", "type": "constructor", "idx": 54862, "Desc": "construct new certpathtrustmanagerparameters from the specified parameters . the parameters are cloned to protect against subsequent modification ."}{"node_name": "ExtendedSSLSession()", "type": "constructor", "idx": 54866, "Desc": ""}{"node_name": "HandshakeCompletedEvent(javax.net.ssl.SSLSocket,javax.net.ssl.SSLSession)", "type": "constructor", "idx": 54872, "Desc": "constructs a new handshakecompletedevent ."}{"node_name": "HttpsURLConnection(java.net.URL)", "type": "constructor", "idx": 54891, "Desc": "creates an httpsurlconnection using the url specified ."}{"node_name": "KeyManagerFactory(javax.net.ssl.KeyManagerFactorySpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 54913, "Desc": "creates a keymanagerfactory object ."}{"node_name": "KeyManagerFactorySpi()", "type": "constructor", "idx": 54935, "Desc": ""}{"node_name": "KeyStoreBuilderParameters(java.security.KeyStore.Builder)", "type": "constructor", "idx": 54943, "Desc": "construct new keystorebuilderparameters from the specified keystore.builder ."}{"node_name": "KeyStoreBuilderParameters(java.util.List)", "type": "constructor", "idx": 54945, "Desc": "construct new keystorebuilderparameters from a list of keystore.builders . note that the list is cloned to protect against subsequent modification ."}{"node_name": "SNIHostName(java.lang.String)", "type": "constructor", "idx": 54950, "Desc": "creates an snihostname using the specified hostname . note that per rfc 6066 , the encoded server name value of a hostname is standardcharsets.us_ascii-compliant . in this method , hostname can be a user-friendly internationalized domain name ( idn ) . idn.toascii ( string , int ) is used to enforce the restrictions on ascii characters in hostnames ( see rfc 3490 , rfc 1122 , rfc 1123 ) and translate the hostname into ascii compatible encoding ( ace ) , as : idn.toascii ( hostname , idn.use_std3_ascii_rules ); the hostname argument is illegal if it : hostname is empty , hostname ends with a trailing dot , hostname is not a valid internationalized domain name ( idn ) compliant with the rfc 3490 specification ."}{"node_name": "SNIHostName(byte[])", "type": "constructor", "idx": 54952, "Desc": "creates an snihostname using the specified encoded value . this method is normally used to parse the encoded name value in a requested sni extension . per rfc 6066 , the encoded name value of a hostname is standardcharsets.us_ascii-compliant . however , in the previous version of the sni extension ( rfc 4366 ) , the encoded hostname is represented as a byte string using utf-8 encoding . for the purpose of version tolerance , this method allows that the charset of encoded argument can be standardcharsets.utf_8 , as well as standardcharsets.us_ascii . idn.toascii ( string ) is used to translate the encoded argument into ascii compatible encoding ( ace ) hostname . it is strongly recommended that <init>(byte[]) is only used to parse the encoded name value in a requested sni extension . otherwise , to comply with rfc 6066 , please always use standardcharsets.us_ascii-compliant charset and enforce the restrictions on ascii characters in hostnames ( see rfc 3490 , rfc 1122 , rfc 1123 ) for encoded argument , or use snihostname ( string ) instead . the encoded argument is illegal if it : encoded is empty , encoded ends with a trailing dot , encoded is not encoded in standardcharsets.us_ascii or standardcharsets.utf_8-compliant charset , encoded is not a valid internationalized domain name ( idn ) compliant with the rfc 3490 specification . note that the encoded byte array is cloned to protect against subsequent modification ."}{"node_name": "SNIMatcher(int)", "type": "constructor", "idx": 54962, "Desc": "creates an snimatcher using the specified server name type ."}{"node_name": "SNIServerName(int,byte[])", "type": "constructor", "idx": 54968, "Desc": "creates an sniservername using the specified name type and encoded value . note that the encoded byte array is cloned to protect against subsequent modification ."}{"node_name": "SSLContext(javax.net.ssl.SSLContextSpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 54978, "Desc": "creates an sslcontext object ."}{"node_name": "SSLContextSpi()", "type": "constructor", "idx": 55010, "Desc": ""}{"node_name": "SSLEngine()", "type": "constructor", "idx": 55026, "Desc": "constructor for an sslengine providing no hints for an internal session reuse strategy ."}{"node_name": "SSLEngine(java.lang.String,int)", "type": "constructor", "idx": 55027, "Desc": "constructor for an sslengine . sslengine implementations may use the peerhost and peerport parameters as hints for their internal session reuse strategy . some cipher suites ( such as kerberos ) require remote hostname information . implementations of this class should use <init>(java.lang.String,int) to use kerberos . the parameters are not authenticated by the sslengine ."}{"node_name": "SSLEngineResult(javax.net.ssl.SSLEngineResult.Status,javax.net.ssl.SSLEngineResult.HandshakeStatus,int,int)", "type": "constructor", "idx": 55095, "Desc": "initializes a new instance of this class ."}{"node_name": "SSLEngineResult(javax.net.ssl.SSLEngineResult.Status,javax.net.ssl.SSLEngineResult.HandshakeStatus,int,int,long)", "type": "constructor", "idx": 55100, "Desc": "initializes a new instance of this class ."}{"node_name": "SSLException(java.lang.String)", "type": "constructor", "idx": 55117, "Desc": "constructs an exception reporting an error found by an ssl subsystem ."}{"node_name": "SSLException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 55119, "Desc": "creates a sslexception with the specified detail message and cause ."}{"node_name": "SSLException(java.lang.Throwable)", "type": "constructor", "idx": 55122, "Desc": "creates a sslexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "SSLHandshakeException(java.lang.String)", "type": "constructor", "idx": 55125, "Desc": "constructs an exception reporting an error found by an ssl subsystem during handshaking ."}{"node_name": "SSLKeyException(java.lang.String)", "type": "constructor", "idx": 55128, "Desc": "constructs an exception reporting a key management error found by an ssl subsystem ."}{"node_name": "SSLParameters()", "type": "constructor", "idx": 55131, "Desc": "constructs sslparameters . the values of ciphersuites , protocols , cryptographic algorithm constraints , endpoint identification algorithm , server names and server name matchers are set to null ; useciphersuitesorder , wantclientauth and needclientauth are set to false ; enableretransmissions is set to true ; maximum network packet size is set to 0 ."}{"node_name": "SSLParameters(java.lang.String[])", "type": "constructor", "idx": 55132, "Desc": "constructs sslparameters from the specified array of ciphersuites . calling <init>(java.lang.String[]) is equivalent to calling the no-args constructor followed by setciphersuites ( ciphersuites ); . note that the standard list of cipher suite names may be found in the jsse cipher suite names section of the java cryptography architecture standard algorithm name documentation . providers may support cipher suite names not found in this list ."}{"node_name": "SSLParameters(java.lang.String[],java.lang.String[])", "type": "constructor", "idx": 55134, "Desc": "constructs sslparameters from the specified array of ciphersuites and protocols . calling <init>(java.lang.String[],java.lang.String[]) is equivalent to calling the no-args constructor followed by setciphersuites ( ciphersuites ); setprotocols ( protocols ); . note that the standard list of cipher suite names may be found in the jsse cipher suite names section of the java cryptography architecture standard algorithm name documentation . providers may support cipher suite names not found in this list ."}{"node_name": "SSLPeerUnverifiedException(java.lang.String)", "type": "constructor", "idx": 55174, "Desc": "constructs an exception reporting that the ssl peer's identity has not been verified ."}{"node_name": "SSLPermission(java.lang.String)", "type": "constructor", "idx": 55177, "Desc": "creates a new sslpermission with the specified name . the name is the symbolic name of the sslpermission , such as \" setdefaultauthenticator \" , etc . an asterisk may appear at the end of the name , following a \" . \" , or by itself , to signify a wildcard match ."}{"node_name": "SSLPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 55179, "Desc": "creates a new sslpermission object with the specified name . the name is the symbolic name of the sslpermission , and the actions string is currently unused and should be null ."}{"node_name": "SSLProtocolException(java.lang.String)", "type": "constructor", "idx": 55183, "Desc": "constructs an exception reporting an ssl protocol error detected by an ssl subsystem ."}{"node_name": "SSLServerSocket()", "type": "constructor", "idx": 55186, "Desc": "used only by subclasses . create an unbound tcp server socket using the default authentication context ."}{"node_name": "SSLServerSocket(int)", "type": "constructor", "idx": 55187, "Desc": "used only by subclasses . create a tcp server socket on a port , using the default authentication context . the connection backlog defaults to fifty connections queued up before the system starts to reject new connection requests . a port number of 0 creates a socket on any free port . if there is a security manager , its checklisten method is called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "SSLServerSocket(int,int)", "type": "constructor", "idx": 55189, "Desc": "used only by subclasses . create a tcp server socket on a port , using the default authentication context and a specified backlog of connections . a port number of 0 creates a socket on any free port . the backlog argument is the requested maximum number of pending connections on the socket . its exact semantics are implementation specific . in particular , an implementation may impose a maximum length or may choose to ignore the parameter altogther . the value provided should be greater than 0 . if it is less than or equal to 0 , then an implementation specific default will be used . if there is a security manager , its checklisten method is called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception ."}{"node_name": "SSLServerSocket(int,int,java.net.InetAddress)", "type": "constructor", "idx": 55192, "Desc": "used only by subclasses . create a tcp server socket on a port , using the default authentication context and a specified backlog of connections as well as a particular specified network interface . <init>(int,int,java.net.InetAddress) is used on multihomed hosts , such as those used for firewalls or as routers , to control through which interface a network service is provided . if there is a security manager , its checklisten method is called with the port argument as its argument to ensure the operation is allowed . this could result in a securityexception . a port number of 0 creates a socket on any free port . the backlog argument is the requested maximum number of pending connections on the socket . its exact semantics are implementation specific . in particular , an implementation may impose a maximum length or may choose to ignore the parameter altogther . the value provided should be greater than 0 . if it is less than or equal to 0 , then an implementation specific default will be used . if address is null , it will default accepting connections on any / all local addresses ."}{"node_name": "SSLServerSocketFactory()", "type": "constructor", "idx": 55220, "Desc": "constructor is used only by subclasses ."}{"node_name": "SSLSessionBindingEvent(javax.net.ssl.SSLSession,java.lang.String)", "type": "constructor", "idx": 55250, "Desc": "constructs a new sslsessionbindingevent ."}{"node_name": "SSLSocket()", "type": "constructor", "idx": 55271, "Desc": "used only by subclasses . constructs an uninitialized , unconnected tcp socket ."}{"node_name": "SSLSocket(java.lang.String,int)", "type": "constructor", "idx": 55272, "Desc": "used only by subclasses . constructs a tcp connection to a named host at a specified port . this acts as the ssl client . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "SSLSocket(java.net.InetAddress,int)", "type": "constructor", "idx": 55275, "Desc": "used only by subclasses . constructs a tcp connection to a server at a specified address and port . this acts as the ssl client . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "SSLSocket(java.lang.String,int,java.net.InetAddress,int)", "type": "constructor", "idx": 55278, "Desc": "used only by subclasses . constructs an ssl connection to a named host at a specified port , binding the client side of the connection a given address and port . this acts as the ssl client . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "SSLSocket(java.net.InetAddress,int,java.net.InetAddress,int)", "type": "constructor", "idx": 55283, "Desc": "used only by subclasses . constructs an ssl connection to a server at a specified address and tcp port , binding the client side of the connection a given address and port . this acts as the ssl client . if there is a security manager , its checkconnect method is called with the host address and port as its arguments . this could result in a securityexception ."}{"node_name": "SSLSocketFactory()", "type": "constructor", "idx": 55323, "Desc": "constructor is used only by subclasses ."}{"node_name": "TrustManagerFactory(javax.net.ssl.TrustManagerFactorySpi,java.security.Provider,java.lang.String)", "type": "constructor", "idx": 55340, "Desc": "creates a trustmanagerfactory object ."}{"node_name": "TrustManagerFactorySpi()", "type": "constructor", "idx": 55361, "Desc": ""}{"node_name": "X509ExtendedKeyManager()", "type": "constructor", "idx": 55368, "Desc": "constructor used by subclasses only ."}{"node_name": "X509ExtendedTrustManager()", "type": "constructor", "idx": 55378, "Desc": ""}{"node_name": "DateTimeSyntax(java.util.Date)", "type": "constructor", "idx": 55478, "Desc": "construct a new date-time attribute with the given java.util.date value ."}{"node_name": "EnumSyntax(int)", "type": "constructor", "idx": 55492, "Desc": "construct a new enumeration value with the given integer value ."}{"node_name": "HashAttributeSet()", "type": "constructor", "idx": 55503, "Desc": "construct a new , empty attribute set ."}{"node_name": "HashAttributeSet(javax.print.attribute.Attribute)", "type": "constructor", "idx": 55504, "Desc": "construct a new attribute set , initially populated with the given attribute ."}{"node_name": "HashAttributeSet(javax.print.attribute.Attribute[])", "type": "constructor", "idx": 55506, "Desc": "construct a new attribute set , initially populated with the values from the given array . the new attribute set is populated by adding the elements of attributes array to the set in sequence , starting at index 0 . thus , later array elements may replace earlier array elements if the array contains duplicate attribute values or attribute categories ."}{"node_name": "HashAttributeSet(javax.print.attribute.AttributeSet)", "type": "constructor", "idx": 55508, "Desc": "construct a new attribute set , initially populated with the values from the given set ."}{"node_name": "HashAttributeSet(java.lang.Class)", "type": "constructor", "idx": 55510, "Desc": "construct a new , empty attribute set , where the members of the attribute set are restricted to the given interface ."}{"node_name": "HashAttributeSet(javax.print.attribute.Attribute,java.lang.Class)", "type": "constructor", "idx": 55512, "Desc": "construct a new attribute set , initially populated with the given attribute , where the members of the attribute set are restricted to the given interface ."}{"node_name": "HashAttributeSet(javax.print.attribute.Attribute[],java.lang.Class)", "type": "constructor", "idx": 55515, "Desc": "construct a new attribute set , where the members of the attribute set are restricted to the given interface . the new attribute set is populated by adding the elements of attributes array to the set in sequence , starting at index 0 . thus , later array elements may replace earlier array elements if the array contains duplicate attribute values or attribute categories ."}{"node_name": "HashAttributeSet(javax.print.attribute.AttributeSet,java.lang.Class)", "type": "constructor", "idx": 55518, "Desc": "construct a new attribute set , initially populated with the values from the given set where the members of the attribute set are restricted to the given interface ."}{"node_name": "HashDocAttributeSet()", "type": "constructor", "idx": 55543, "Desc": "construct a new , empty hash doc attribute set ."}{"node_name": "HashDocAttributeSet(javax.print.attribute.DocAttribute)", "type": "constructor", "idx": 55544, "Desc": "construct a new hash doc attribute set , initially populated with the given value ."}{"node_name": "HashDocAttributeSet(javax.print.attribute.DocAttribute[])", "type": "constructor", "idx": 55546, "Desc": "construct a new hash doc attribute set , initially populated with the values from the given array . the new attribute set is populated by adding the elements of attributes array to the set in sequence , starting at index 0 . thus , later array elements may replace earlier array elements if the array contains duplicate attribute values or attribute categories ."}{"node_name": "HashDocAttributeSet(javax.print.attribute.DocAttributeSet)", "type": "constructor", "idx": 55548, "Desc": "construct a new attribute set , initially populated with the values from the given set where the members of the attribute set are restricted to the docattribute interface ."}{"node_name": "HashPrintJobAttributeSet()", "type": "constructor", "idx": 55551, "Desc": "construct a new , empty hash print job attribute set ."}{"node_name": "HashPrintJobAttributeSet(javax.print.attribute.PrintJobAttribute)", "type": "constructor", "idx": 55552, "Desc": "construct a new hash print job attribute set , initially populated with the given value ."}{"node_name": "HashPrintJobAttributeSet(javax.print.attribute.PrintJobAttribute[])", "type": "constructor", "idx": 55554, "Desc": "construct a new hash print job attribute set , initially populated with the values from the given array . the new attribute set is populated by adding the elements of attributes array to the set in sequence , starting at index 0 . thus , later array elements may replace earlier array elements if the array contains duplicate attribute values or attribute categories ."}{"node_name": "HashPrintJobAttributeSet(javax.print.attribute.PrintJobAttributeSet)", "type": "constructor", "idx": 55556, "Desc": "construct a new attribute set , initially populated with the values from the given set where the members of the attribute set are restricted to the printjobattribute interface ."}{"node_name": "HashPrintRequestAttributeSet()", "type": "constructor", "idx": 55559, "Desc": "construct a new , empty print request attribute set ."}{"node_name": "HashPrintRequestAttributeSet(javax.print.attribute.PrintRequestAttribute)", "type": "constructor", "idx": 55560, "Desc": "construct a new print request attribute set , initially populated with the given value ."}{"node_name": "HashPrintRequestAttributeSet(javax.print.attribute.PrintRequestAttribute[])", "type": "constructor", "idx": 55562, "Desc": "construct a new print request attribute set , initially populated with the values from the given array . the new attribute set is populated by adding the elements of attributes array to the set in sequence , starting at index 0 . thus , later array elements may replace earlier array elements if the array contains duplicate attribute values or attribute categories ."}{"node_name": "HashPrintRequestAttributeSet(javax.print.attribute.PrintRequestAttributeSet)", "type": "constructor", "idx": 55564, "Desc": "construct a new attribute set , initially populated with the values from the given set where the members of the attribute set are restricted to the ( printrequestattributese interface ."}{"node_name": "HashPrintServiceAttributeSet()", "type": "constructor", "idx": 55567, "Desc": "construct a new , empty hash print service attribute set ."}{"node_name": "HashPrintServiceAttributeSet(javax.print.attribute.PrintServiceAttribute)", "type": "constructor", "idx": 55568, "Desc": "construct a new hash print service attribute set , initially populated with the given value ."}{"node_name": "HashPrintServiceAttributeSet(javax.print.attribute.PrintServiceAttribute[])", "type": "constructor", "idx": 55570, "Desc": "construct a new print service attribute set , initially populated with the values from the given array . the new attribute set is populated by adding the elements of attributes array to the set in sequence , starting at index 0 . thus , later array elements may replace earlier array elements if the array contains duplicate attribute values or attribute categories ."}{"node_name": "HashPrintServiceAttributeSet(javax.print.attribute.PrintServiceAttributeSet)", "type": "constructor", "idx": 55572, "Desc": "construct a new attribute set , initially populated with the values from the given set where the members of the attribute set are restricted to the printserviceattribute interface ."}{"node_name": "IntegerSyntax(int)", "type": "constructor", "idx": 55575, "Desc": "construct a new integer attribute with the given integer value ."}{"node_name": "IntegerSyntax(int,int,int)", "type": "constructor", "idx": 55577, "Desc": "construct a new integer attribute with the given integer value , which must lie within the given range ."}{"node_name": "ResolutionSyntax(int,int,int)", "type": "constructor", "idx": 55607, "Desc": "construct a new resolution attribute from the given items ."}{"node_name": "SetOfIntegerSyntax(java.lang.String)", "type": "constructor", "idx": 55629, "Desc": "construct a new set-of-integer attribute with the given members in string form ."}{"node_name": "SetOfIntegerSyntax(int[][])", "type": "constructor", "idx": 55631, "Desc": "construct a new set-of-integer attribute with the given members in array form ."}{"node_name": "SetOfIntegerSyntax(int)", "type": "constructor", "idx": 55633, "Desc": "construct a new set-of-integer attribute containing a single integer ."}{"node_name": "SetOfIntegerSyntax(int,int)", "type": "constructor", "idx": 55635, "Desc": "construct a new set-of-integer attribute containing a single range of integers . if the lower bound is greater than the upper bound ( a null range ) , an empty set is constructed ."}{"node_name": "Size2DSyntax(float,float,int)", "type": "constructor", "idx": 55652, "Desc": "construct a new two-dimensional size attribute from the given floating-point values ."}{"node_name": "Size2DSyntax(int,int,int)", "type": "constructor", "idx": 55656, "Desc": "construct a new two-dimensional size attribute from the given integer values ."}{"node_name": "Chromaticity(int)", "type": "constructor", "idx": 55678, "Desc": "construct a new chromaticity enumeration value with the given integer value ."}{"node_name": "ColorSupported(int)", "type": "constructor", "idx": 55687, "Desc": "construct a new color supported enumeration value with the given integer value ."}{"node_name": "Compression(int)", "type": "constructor", "idx": 55698, "Desc": "construct a new compression enumeration value with the given integer value ."}{"node_name": "Copies(int)", "type": "constructor", "idx": 55705, "Desc": "construct a new copies attribute with the given integer value ."}{"node_name": "CopiesSupported(int)", "type": "constructor", "idx": 55712, "Desc": "construct a new copies supported attribute containing a single integer . that is , only the one value of copies is supported ."}{"node_name": "CopiesSupported(int,int)", "type": "constructor", "idx": 55714, "Desc": "construct a new copies supported attribute containing a single range of integers . that is , only those values of copies in the one range are supported ."}{"node_name": "DateTimeAtCompleted(java.util.Date)", "type": "constructor", "idx": 55722, "Desc": "construct a new date-time at completed attribute with the given date value ."}{"node_name": "DateTimeAtCreation(java.util.Date)", "type": "constructor", "idx": 55729, "Desc": "construct a new date-time at creation attribute with the given date value ."}{"node_name": "DateTimeAtProcessing(java.util.Date)", "type": "constructor", "idx": 55736, "Desc": "construct a new date-time at processing attribute with the given date value ."}{"node_name": "Destination(java.net.URI)", "type": "constructor", "idx": 55743, "Desc": "constructs a new destination attribute with the specified uri ."}{"node_name": "DialogOwner()", "type": "constructor", "idx": 55750, "Desc": "constructs an instance which can be used to request java.awt.window.setalwaysontop ( true ) behaviour . this should be used where there is no application preferred owner window . whether this has any effect depends on if always on top is supported for this platform and the particular dialog to be displayed ."}{"node_name": "DialogOwner(java.awt.Window)", "type": "constructor", "idx": 55751, "Desc": "constructs an instance which can be used to request that the specified window be the owner of the dialog ."}{"node_name": "DialogTypeSelection(int)", "type": "constructor", "idx": 55759, "Desc": "constructs a new dialog type selection enumeration value with the given integer value ."}{"node_name": "DocumentName(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 55766, "Desc": "constructs a new document name attribute with the given document name and locale ."}{"node_name": "Fidelity(int)", "type": "constructor", "idx": 55776, "Desc": "construct a new fidelity enumeration value with the given integer value ."}{"node_name": "Finishings(int)", "type": "constructor", "idx": 55801, "Desc": "construct a new finishings binding enumeration value with the given integer value ."}{"node_name": "JobHoldUntil(java.util.Date)", "type": "constructor", "idx": 55809, "Desc": "construct a new job hold until date-time attribute with the given date value ."}{"node_name": "JobImpressions(int)", "type": "constructor", "idx": 55816, "Desc": "construct a new job impressions attribute with the given integer value ."}{"node_name": "JobImpressionsCompleted(int)", "type": "constructor", "idx": 55823, "Desc": "construct a new job impressions completed attribute with the given integer value ."}{"node_name": "JobImpressionsSupported(int,int)", "type": "constructor", "idx": 55830, "Desc": "construct a new job impressions supported attribute containing a single range of integers . that is , only those values of jobimpressions in the one range are supported ."}{"node_name": "JobKOctets(int)", "type": "constructor", "idx": 55838, "Desc": "construct a new job k octets attribute with the given integer value ."}{"node_name": "JobKOctetsProcessed(int)", "type": "constructor", "idx": 55845, "Desc": "construct a new job k octets processed attribute with the given integer value ."}{"node_name": "JobKOctetsSupported(int,int)", "type": "constructor", "idx": 55852, "Desc": "construct a new job k octets supported attribute containing a single range of integers . that is , only those values of jobkoctets in the one range are supported ."}{"node_name": "JobMediaSheets(int)", "type": "constructor", "idx": 55860, "Desc": "construct a new job media sheets attribute with the given integer value ."}{"node_name": "JobMediaSheetsCompleted(int)", "type": "constructor", "idx": 55867, "Desc": "construct a new job media sheets completed attribute with the given integer value ."}{"node_name": "JobMediaSheetsSupported(int,int)", "type": "constructor", "idx": 55874, "Desc": "construct a new job media sheets supported attribute containing a single range of integers . that is , only those values of jobmediasheets in the one range are supported ."}{"node_name": "JobMessageFromOperator(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 55882, "Desc": "constructs a new job message from operator attribute with the given message and locale ."}{"node_name": "JobName(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 55890, "Desc": "constructs a new job name attribute with the given job name and locale ."}{"node_name": "JobOriginatingUserName(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 55898, "Desc": "constructs a new job originating user name attribute with the given user name and locale ."}{"node_name": "JobPriority(int)", "type": "constructor", "idx": 55906, "Desc": "construct a new job priority attribute with the given integer value ."}{"node_name": "JobPrioritySupported(int)", "type": "constructor", "idx": 55913, "Desc": "construct a new job priority supported attribute with the given integer value ."}{"node_name": "JobSheets(int)", "type": "constructor", "idx": 55922, "Desc": "construct a new job sheets enumeration value with the given integer value ."}{"node_name": "JobState(int)", "type": "constructor", "idx": 55937, "Desc": "construct a new job state enumeration value with the given integer value ."}{"node_name": "JobStateReason(int)", "type": "constructor", "idx": 55973, "Desc": "construct a new job state reason enumeration value with the given integer value ."}{"node_name": "JobStateReasons()", "type": "constructor", "idx": 55980, "Desc": "construct a new , empty job state reasons attribute ; the underlying hash set has the default initial capacity and load factor ."}{"node_name": "JobStateReasons(int)", "type": "constructor", "idx": 55981, "Desc": "construct a new , empty job state reasons attribute ; the underlying hash set has the given initial capacity and the default load factor ."}{"node_name": "JobStateReasons(int,float)", "type": "constructor", "idx": 55983, "Desc": "construct a new , empty job state reasons attribute ; the underlying hash set has the given initial capacity and load factor ."}{"node_name": "JobStateReasons(java.util.Collection)", "type": "constructor", "idx": 55986, "Desc": "construct a new job state reasons attribute that contains the same jobstatereason objects as the given collection . the underlying hash set's initial capacity and load factor are as specified in the superclass constructor hashset ( collection ) ."}{"node_name": "Media(int)", "type": "constructor", "idx": 55993, "Desc": "constructs a new media attribute specified by name ."}{"node_name": "MediaName(int)", "type": "constructor", "idx": 56004, "Desc": "constructs a new media name enumeration value with the given integer value ."}{"node_name": "MediaPrintableArea(float,float,float,float,int)", "type": "constructor", "idx": 56011, "Desc": "constructs a mediaprintablearea object from floating point values ."}{"node_name": "MediaPrintableArea(int,int,int,int,int)", "type": "constructor", "idx": 56017, "Desc": "constructs a mediaprintablearea object from integer values ."}{"node_name": "MediaSize(float,float,int)", "type": "constructor", "idx": 56113, "Desc": "construct a new media size attribute from the given floating-point values ."}{"node_name": "MediaSize(int,int,int)", "type": "constructor", "idx": 56117, "Desc": "construct a new media size attribute from the given integer values ."}{"node_name": "MediaSize(float,float,int,javax.print.attribute.standard.MediaSizeName)", "type": "constructor", "idx": 56121, "Desc": "construct a new media size attribute from the given floating-point values ."}{"node_name": "MediaSize(int,int,int,javax.print.attribute.standard.MediaSizeName)", "type": "constructor", "idx": 56126, "Desc": "construct a new media size attribute from the given integer values ."}{"node_name": "MediaSizeName(int)", "type": "constructor", "idx": 56245, "Desc": "construct a new media size enumeration value with the given integer value ."}{"node_name": "MediaTray(int)", "type": "constructor", "idx": 56258, "Desc": "construct a new media tray enumeration value with the given integer value ."}{"node_name": "MultipleDocumentHandling(int)", "type": "constructor", "idx": 56267, "Desc": "construct a new multiple document handling enumeration value with the given integer value ."}{"node_name": "NumberOfDocuments(int)", "type": "constructor", "idx": 56274, "Desc": "construct a new number of documents attribute with the given integer value ."}{"node_name": "NumberOfInterveningJobs(int)", "type": "constructor", "idx": 56281, "Desc": "construct a new number of intervening jobs attribute with the given integer value ."}{"node_name": "NumberUp(int)", "type": "constructor", "idx": 56288, "Desc": "construct a new number up attribute with the given integer value ."}{"node_name": "NumberUpSupported(int[][])", "type": "constructor", "idx": 56295, "Desc": "construct a new number up supported attribute with the given members . the supported values for numberup are specified in \" array form ; \" see class setofintegersyntax for an explanation of array form ."}{"node_name": "NumberUpSupported(int)", "type": "constructor", "idx": 56297, "Desc": "construct a new number up supported attribute containing a single integer . that is , only the one value of numberup is supported ."}{"node_name": "NumberUpSupported(int,int)", "type": "constructor", "idx": 56299, "Desc": "construct a new number up supported attribute containing a single range of integers . that is , only those values of numberup in the one range are supported ."}{"node_name": "OrientationRequested(int)", "type": "constructor", "idx": 56311, "Desc": "construct a new orientation requested enumeration value with the given integer value ."}{"node_name": "OutputDeviceAssigned(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56319, "Desc": "constructs a new output device assigned attribute with the given device name and locale ."}{"node_name": "PageRanges(int[][])", "type": "constructor", "idx": 56327, "Desc": "construct a new page ranges attribute with the given members . the members are specified in \" array form ; \" see class setofintegersyntax for an explanation of array form ."}{"node_name": "PageRanges(java.lang.String)", "type": "constructor", "idx": 56329, "Desc": "construct a new page ranges attribute with the given members in string form . see class setofintegersyntax for explanation of the syntax ."}{"node_name": "PageRanges(int)", "type": "constructor", "idx": 56331, "Desc": "construct a new page ranges attribute containing a single integer . that is , only the one page is to be printed ."}{"node_name": "PageRanges(int,int)", "type": "constructor", "idx": 56333, "Desc": "construct a new page ranges attribute containing a single range of integers . that is , only those pages in the one range are to be printed ."}{"node_name": "PagesPerMinute(int)", "type": "constructor", "idx": 56341, "Desc": "construct a new pages per minute attribute with the given integer value ."}{"node_name": "PagesPerMinuteColor(int)", "type": "constructor", "idx": 56348, "Desc": "construct a new pages per minute color attribute with the given integer value ."}{"node_name": "PDLOverrideSupported(int)", "type": "constructor", "idx": 56357, "Desc": "construct a new pdl override supported enumeration value with the given integer value ."}{"node_name": "PrinterInfo(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56377, "Desc": "constructs a new printer info attribute with the given information string and locale ."}{"node_name": "PrinterIsAcceptingJobs(int)", "type": "constructor", "idx": 56387, "Desc": "construct a new printer is accepting jobs enumeration value with the given integer value ."}{"node_name": "PrinterLocation(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56394, "Desc": "constructs a new printer location attribute with the given location and locale ."}{"node_name": "PrinterMakeAndModel(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56402, "Desc": "constructs a new printer make and model attribute with the given make and model string and locale ."}{"node_name": "PrinterMessageFromOperator(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56410, "Desc": "constructs a new printer message from operator attribute with the given message and locale ."}{"node_name": "PrinterMoreInfo(java.net.URI)", "type": "constructor", "idx": 56418, "Desc": "constructs a new printer more info attribute with the specified uri ."}{"node_name": "PrinterMoreInfoManufacturer(java.net.URI)", "type": "constructor", "idx": 56425, "Desc": "constructs a new printer more info manufacturer attribute with the specified uri ."}{"node_name": "PrinterName(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56432, "Desc": "constructs a new printer name attribute with the given name and locale ."}{"node_name": "PrinterResolution(int,int,int)", "type": "constructor", "idx": 56440, "Desc": "construct a new printer resolution attribute from the given items ."}{"node_name": "PrinterState(int)", "type": "constructor", "idx": 56453, "Desc": "construct a new printer state enumeration value with the given integer value ."}{"node_name": "PrinterStateReason(int)", "type": "constructor", "idx": 56493, "Desc": "construct a new printer state reason enumeration value with the given integer value ."}{"node_name": "PrinterStateReasons()", "type": "constructor", "idx": 56500, "Desc": "construct a new , empty printer state reasons attribute ; the underlying hash map has the default initial capacity and load factor ."}{"node_name": "PrinterStateReasons(int)", "type": "constructor", "idx": 56501, "Desc": "construct a new , empty printer state reasons attribute ; the underlying hash map has the given initial capacity and the default load factor ."}{"node_name": "PrinterStateReasons(int,float)", "type": "constructor", "idx": 56503, "Desc": "construct a new , empty printer state reasons attribute ; the underlying hash map has the given initial capacity and load factor ."}{"node_name": "PrinterStateReasons(java.util.Map)", "type": "constructor", "idx": 56506, "Desc": "construct a new printer state reasons attribute that contains the same printerstatereason-to-severity mappings as the given map . the underlying hash map's initial capacity and load factor are as specified in the superclass constructor hashmap ( map ) ."}{"node_name": "PrinterURI(java.net.URI)", "type": "constructor", "idx": 56516, "Desc": "constructs a new printeruri attribute with the specified uri ."}{"node_name": "PrintQuality(int)", "type": "constructor", "idx": 56526, "Desc": "construct a new print quality enumeration value with the given integer value ."}{"node_name": "QueuedJobCount(int)", "type": "constructor", "idx": 56534, "Desc": "construct a new queued job count attribute with the given integer value ."}{"node_name": "ReferenceUriSchemesSupported(int)", "type": "constructor", "idx": 56549, "Desc": "construct a new reference uri scheme enumeration value with the given integer value ."}{"node_name": "RequestingUserName(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56556, "Desc": "constructs a new requesting user name attribute with the given user name and locale ."}{"node_name": "Severity(int)", "type": "constructor", "idx": 56567, "Desc": "construct a new severity enumeration value with the given integer value ."}{"node_name": "SheetCollate(int)", "type": "constructor", "idx": 56576, "Desc": "construct a new sheet collate enumeration value with the given integer value ."}{"node_name": "Sides(int)", "type": "constructor", "idx": 56588, "Desc": "construct a new sides enumeration value with the given integer value ."}{"node_name": "TextSyntax(java.lang.String,java.util.Locale)", "type": "constructor", "idx": 56596, "Desc": "constructs a textattribute with the specified string and locale ."}{"node_name": "UnmodifiableSetException()", "type": "constructor", "idx": 56606, "Desc": "constructs an unsupportedoperationexception with no detail message ."}{"node_name": "UnmodifiableSetException(java.lang.String)", "type": "constructor", "idx": 56607, "Desc": "constructs an unmodifiablesetexception with the specified detail message ."}{"node_name": "URISyntax(java.net.URI)", "type": "constructor", "idx": 56610, "Desc": "constructs a uri attribute with the specified uri ."}{"node_name": "BYTE_ARRAY(java.lang.String)", "type": "constructor", "idx": 56648, "Desc": "constructs a new doc flavor with the given mime type and a print data representation class name of \" [ b \" ( byte array ) ."}{"node_name": "CHAR_ARRAY(java.lang.String)", "type": "constructor", "idx": 56653, "Desc": "constructs a new doc flavor with the given mime type and a print data representation class name of \" [ c \" ( character array ) ."}{"node_name": "INPUT_STREAM(java.lang.String)", "type": "constructor", "idx": 56675, "Desc": "constructs a new doc flavor with the given mime type and a print data representation class name of \" java.io.inputstream \" ( byte stream ) ."}{"node_name": "DocFlavor(java.lang.String,java.lang.String)", "type": "constructor", "idx": 56679, "Desc": "constructs a new doc flavor object from the given mime type and representation class name . the given mime type is converted into canonical form and stored internally ."}{"node_name": "READER(java.lang.String)", "type": "constructor", "idx": 56695, "Desc": "constructs a new doc flavor with the given mime type and a print data representation class name of \" java.io.reader \" ( character stream ) ."}{"node_name": "SERVICE_FORMATTED(java.lang.String)", "type": "constructor", "idx": 56701, "Desc": "constructs a new doc flavor with a mime type of \" application / x-java-jvm-local-objectref \" indicating service formatted print data and the given print data representation class name ."}{"node_name": "STRING(java.lang.String)", "type": "constructor", "idx": 56706, "Desc": "constructs a new doc flavor with the given mime type and a print data representation class name of \" java.lang.string \" ."}{"node_name": "URL(java.lang.String)", "type": "constructor", "idx": 56728, "Desc": "constructs a new doc flavor with the given mime type and a print data representation class name of \" java.net.url \" ."}{"node_name": "PrintEvent(java.lang.Object)", "type": "constructor", "idx": 56746, "Desc": "constructs a printevent object ."}{"node_name": "PrintJobAdapter()", "type": "constructor", "idx": 56750, "Desc": ""}{"node_name": "PrintJobAttributeEvent(javax.print.DocPrintJob,javax.print.attribute.PrintJobAttributeSet)", "type": "constructor", "idx": 56764, "Desc": "constructs a printjobattributeevent object ."}{"node_name": "PrintJobEvent(javax.print.DocPrintJob,int)", "type": "constructor", "idx": 56779, "Desc": "constructs a printjobevent object ."}{"node_name": "PrintServiceAttributeEvent(javax.print.PrintService,javax.print.attribute.PrintServiceAttributeSet)", "type": "constructor", "idx": 56798, "Desc": "constructs a printserviceattributeevent object ."}{"node_name": "PrintException()", "type": "constructor", "idx": 56818, "Desc": "construct a print exception with no detail message ."}{"node_name": "PrintException(java.lang.String)", "type": "constructor", "idx": 56819, "Desc": "construct a print exception with the given detail message ."}{"node_name": "PrintException(java.lang.Exception)", "type": "constructor", "idx": 56821, "Desc": "construct a print exception chaining the supplied exception ."}{"node_name": "PrintException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 56823, "Desc": "construct a print exception with the given detail message and chained exception ."}{"node_name": "PrintServiceLookup()", "type": "constructor", "idx": 56860, "Desc": ""}{"node_name": "ServiceUI()", "type": "constructor", "idx": 56881, "Desc": ""}{"node_name": "ServiceUIFactory()", "type": "constructor", "idx": 56899, "Desc": ""}{"node_name": "SimpleDoc(java.lang.Object,javax.print.DocFlavor,javax.print.attribute.DocAttributeSet)", "type": "constructor", "idx": 56906, "Desc": "constructs a simpledoc with the specified print data , doc flavor and doc attribute set ."}{"node_name": "StreamPrintService(java.io.OutputStream)", "type": "constructor", "idx": 56916, "Desc": "constructs a streamprintservice object ."}{"node_name": "StreamPrintServiceFactory()", "type": "constructor", "idx": 56923, "Desc": ""}{"node_name": "SslRMIClientSocketFactory()", "type": "constructor", "idx": 56938, "Desc": "creates a new sslrmiclientsocketfactory ."}{"node_name": "SslRMIServerSocketFactory()", "type": "constructor", "idx": 56946, "Desc": "creates a new sslrmiserversocketfactory with the default ssl socket configuration . ssl connections accepted by server sockets created by this factory have the default cipher suites and protocol versions enabled and do not require client authentication ."}{"node_name": "SslRMIServerSocketFactory(java.lang.String[],java.lang.String[],boolean)", "type": "constructor", "idx": 56947, "Desc": "creates a new sslrmiserversocketfactory with the specified ssl socket configuration ."}{"node_name": "SslRMIServerSocketFactory(javax.net.ssl.SSLContext,java.lang.String[],java.lang.String[],boolean)", "type": "constructor", "idx": 56951, "Desc": "creates a new sslrmiserversocketfactory with the specified sslcontext and ssl socket configuration ."}{"node_name": "AbstractScriptEngine()", "type": "constructor", "idx": 56966, "Desc": "creates a new instance of abstractscriptengine using a simplescriptcontext as its default scriptcontext ."}{"node_name": "AbstractScriptEngine(javax.script.Bindings)", "type": "constructor", "idx": 56967, "Desc": "creates a new instance using the specified bindings as the engine_scope bindings in the protected context field ."}{"node_name": "CompiledScript()", "type": "constructor", "idx": 57012, "Desc": ""}{"node_name": "ScriptEngineManager()", "type": "constructor", "idx": 57123, "Desc": "the effect of calling <init>() is the same as calling scriptenginemanager ( thread.currentthread() .getcontextclassloader() ) ."}{"node_name": "ScriptEngineManager(java.lang.ClassLoader)", "type": "constructor", "idx": 57124, "Desc": "<init>(java.lang.ClassLoader) loads the implementations of scriptenginefactory visible to the given classloader using the service provider mechanism . if loader is null , the script engine factories that are bundled with the platform are loaded ."}{"node_name": "ScriptException(java.lang.String)", "type": "constructor", "idx": 57151, "Desc": "creates a scriptexception with a string to be used in its message . filename , and line and column numbers are unspecified ."}{"node_name": "ScriptException(java.lang.Exception)", "type": "constructor", "idx": 57153, "Desc": "creates a scriptexception wrapping an exception thrown by an underlying interpreter . line and column numbers and filename are unspecified ."}{"node_name": "ScriptException(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 57155, "Desc": "creates a scriptexception with message , filename and linenumber to be used in error messages ."}{"node_name": "ScriptException(java.lang.String,java.lang.String,int,int)", "type": "constructor", "idx": 57159, "Desc": "scriptexception constructor specifying message , filename , line number and column number ."}{"node_name": "SimpleBindings(java.util.Map)", "type": "constructor", "idx": 57169, "Desc": "constructor uses an existing map to store the values ."}{"node_name": "SimpleBindings()", "type": "constructor", "idx": 57171, "Desc": "default constructor uses a hashmap ."}{"node_name": "SimpleScriptContext()", "type": "constructor", "idx": 57189, "Desc": "create a simplescriptcontext ."}{"node_name": "AuthPermission(java.lang.String)", "type": "constructor", "idx": 57210, "Desc": "creates a new authpermission with the specified name . the name is the symbolic name of the authpermission ."}{"node_name": "AuthPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57212, "Desc": "creates a new authpermission object with the specified name . the name is the symbolic name of the authpermission , and the actions string is currently unused and should be null ."}{"node_name": "ChoiceCallback(java.lang.String,java.lang.String[],int,boolean)", "type": "constructor", "idx": 57220, "Desc": "construct a choicecallback with a prompt , a list of choices , a default choice , and a boolean specifying whether or not multiple selections from the list of choices are allowed ."}{"node_name": "ConfirmationCallback(int,int,int)", "type": "constructor", "idx": 57246, "Desc": "construct a confirmationcallback with a message type , an option type and a default option . underlying security services use <init>(int,int,int) if they require either a yes / no , yes / no / cancel or ok / cancel confirmation ."}{"node_name": "ConfirmationCallback(int,java.lang.String[],int)", "type": "constructor", "idx": 57250, "Desc": "construct a confirmationcallback with a message type , a list of options and a default option . underlying security services use <init>(int,java.lang.String[],int) if they require a confirmation different from the available preset confirmations provided ( for example , continue / abort or stop / go ) . the confirmation options are listed in the options array , and are displayed by the callbackhandler implementation in a manner consistent with the way preset options are displayed ."}{"node_name": "ConfirmationCallback(java.lang.String,int,int,int)", "type": "constructor", "idx": 57254, "Desc": "construct a confirmationcallback with a prompt , message type , an option type and a default option . underlying security services use <init>(java.lang.String,int,int,int) if they require either a yes / no , yes / no / cancel or ok / cancel confirmation ."}{"node_name": "ConfirmationCallback(java.lang.String,int,java.lang.String[],int)", "type": "constructor", "idx": 57259, "Desc": "construct a confirmationcallback with a prompt , message type , a list of options and a default option . underlying security services use <init>(java.lang.String,int,java.lang.String[],int) if they require a confirmation different from the available preset confirmations provided ( for example , continue / abort or stop / go ) . the confirmation options are listed in the options array , and are displayed by the callbackhandler implementation in a manner consistent with the way preset options are displayed ."}{"node_name": "LanguageCallback()", "type": "constructor", "idx": 57273, "Desc": "construct a languagecallback ."}{"node_name": "NameCallback(java.lang.String)", "type": "constructor", "idx": 57278, "Desc": "construct a namecallback with a prompt ."}{"node_name": "NameCallback(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57280, "Desc": "construct a namecallback with a prompt and default name ."}{"node_name": "PasswordCallback(java.lang.String,boolean)", "type": "constructor", "idx": 57289, "Desc": "construct a passwordcallback with a prompt and a boolean specifying whether the password should be displayed as it is being typed ."}{"node_name": "TextInputCallback(java.lang.String)", "type": "constructor", "idx": 57299, "Desc": "construct a textinputcallback with a prompt ."}{"node_name": "TextInputCallback(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57301, "Desc": "construct a textinputcallback with a prompt and default input value ."}{"node_name": "TextOutputCallback(int,java.lang.String)", "type": "constructor", "idx": 57313, "Desc": "construct a textoutputcallback with a message type and message to be displayed ."}{"node_name": "UnsupportedCallbackException(javax.security.auth.callback.Callback)", "type": "constructor", "idx": 57319, "Desc": "constructs an unsupportedcallbackexception with no detail message ."}{"node_name": "UnsupportedCallbackException(javax.security.auth.callback.Callback,java.lang.String)", "type": "constructor", "idx": 57321, "Desc": "constructs a unsupportedcallbackexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "DestroyFailedException()", "type": "constructor", "idx": 57329, "Desc": "constructs a destroyfailedexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "DestroyFailedException(java.lang.String)", "type": "constructor", "idx": 57330, "Desc": "constructs a destroyfailedexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "DelegationPermission(java.lang.String)", "type": "constructor", "idx": 57333, "Desc": "create a new delegationpermission with the specified subordinate and target principals ."}{"node_name": "DelegationPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57335, "Desc": "create a new delegationpermission with the specified subordinate and target principals ."}{"node_name": "EncryptionKey(byte[],int)", "type": "constructor", "idx": 57345, "Desc": "constructs an encryptionkey from the given bytes and the key type . the contents of the byte array are copied ; subsequent modification of the byte array does not affect the newly created key ."}{"node_name": "KerberosCredMessage(javax.security.auth.kerberos.KerberosPrincipal,javax.security.auth.kerberos.KerberosPrincipal,byte[])", "type": "constructor", "idx": 57358, "Desc": "constructs a kerberoscredmessage object . the contents of the message argument are copied ; subsequent modification of the byte array does not affect the newly created object ."}{"node_name": "KerberosKey(javax.security.auth.kerberos.KerberosPrincipal,byte[],int,int)", "type": "constructor", "idx": 57371, "Desc": "constructs a kerberoskey from the given bytes when the key type and key version number are known . this can be used when reading the secret key information from a kerberos \" keytab \" ."}{"node_name": "KerberosKey(javax.security.auth.kerberos.KerberosPrincipal,char[],java.lang.String)", "type": "constructor", "idx": 57376, "Desc": "constructs a kerberoskey from a principal's password using the specified algorithm name . the algorithm name ( case insensitive ) should be provided as the encryption type string defined on the iana kerberos encryption type numbers page . the version number of the key generated will be 0 ."}{"node_name": "KerberosPrincipal(java.lang.String)", "type": "constructor", "idx": 57400, "Desc": "constructs a kerberosprincipal from the provided string input . the name type for this principal defaults to krb_nt_principal this string is assumed to contain a name in the format that is specified in section 2.1.1 . ( kerberos principal name form ) of rfc 1964 ( for example , duke@foo.com , where duke represents a principal , and foo.com represents a realm ) . if the input name does not contain a realm , the default realm is used . the default realm can be specified either in a kerberos configuration file or via the java.security.krb5.realm system property . for more information , see the kerberos requirements . additionally , if a security manager is installed , a servicepermission must be granted and the service principal of the permission must minimally be inside the kerberosprincipal's realm . for example , if the result of new kerberosprincipal ( \" user \") is user@example.com , then a servicepermission with service principal host / www.example.com@example.com ( and any action ) must be granted ."}{"node_name": "KerberosPrincipal(java.lang.String,int)", "type": "constructor", "idx": 57402, "Desc": "constructs a kerberosprincipal from the provided string and name type input . the string is assumed to contain a name in the format that is specified in section 2.1 ( mandatory name forms ) of rfc 1964 . valid name types are specified in section 6.2 ( principal names ) of rfc 4120 . the input name must be consistent with the provided name type . ( for example , duke@foo.com , is a valid input string for the name type , krb_nt_principal where duke represents a principal , and foo.com represents a realm ) . if the input name does not contain a realm , the default realm is used . the default realm can be specified either in a kerberos configuration file or via the java.security.krb5.realm system property . for more information , see the kerberos requirements . additionally , if a security manager is installed , a servicepermission must be granted and the service principal of the permission must minimally be inside the kerberosprincipal's realm . for example , if the result of new kerberosprincipal ( \" user \") is user@example.com , then a servicepermission with service principal host / www.example.com@example.com ( and any action ) must be granted ."}{"node_name": "KerberosTicket(byte[],javax.security.auth.kerberos.KerberosPrincipal,javax.security.auth.kerberos.KerberosPrincipal,byte[],int,boolean[],java.util.Date,java.util.Date,java.util.Date,java.util.Date,java.net.InetAddress[])", "type": "constructor", "idx": 57413, "Desc": "constructs a kerberosticket using credentials information that a client either receives from a kdc or reads from a cache ."}{"node_name": "ServicePermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57473, "Desc": "create a new servicepermission with the specified serviceprincipal and action ."}{"node_name": "AccountException()", "type": "constructor", "idx": 57484, "Desc": "constructs a accountexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountException(java.lang.String)", "type": "constructor", "idx": 57485, "Desc": "constructs a accountexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountExpiredException()", "type": "constructor", "idx": 57488, "Desc": "constructs a accountexpiredexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountExpiredException(java.lang.String)", "type": "constructor", "idx": 57489, "Desc": "constructs a accountexpiredexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountLockedException()", "type": "constructor", "idx": 57492, "Desc": "constructs a accountlockedexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountLockedException(java.lang.String)", "type": "constructor", "idx": 57493, "Desc": "constructs a accountlockedexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountNotFoundException()", "type": "constructor", "idx": 57496, "Desc": "constructs a accountnotfoundexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AccountNotFoundException(java.lang.String)", "type": "constructor", "idx": 57497, "Desc": "constructs a accountnotfoundexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "AppConfigurationEntry(java.lang.String,javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag,java.util.Map)", "type": "constructor", "idx": 57500, "Desc": "default constructor for this class . this entry represents a single loginmodule entry configured for the application specified in the getappconfigurationentry ( string appname ) method from the configuration class ."}{"node_name": "Configuration()", "type": "constructor", "idx": 57514, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "ConfigurationSpi()", "type": "constructor", "idx": 57537, "Desc": ""}{"node_name": "CredentialException()", "type": "constructor", "idx": 57542, "Desc": "constructs a credentialexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CredentialException(java.lang.String)", "type": "constructor", "idx": 57543, "Desc": "constructs a credentialexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CredentialExpiredException()", "type": "constructor", "idx": 57546, "Desc": "constructs a credentialexpiredexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CredentialExpiredException(java.lang.String)", "type": "constructor", "idx": 57547, "Desc": "constructs a credentialexpiredexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CredentialNotFoundException()", "type": "constructor", "idx": 57550, "Desc": "constructs a credentialnotfoundexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "CredentialNotFoundException(java.lang.String)", "type": "constructor", "idx": 57551, "Desc": "constructs a credentialnotfoundexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "FailedLoginException()", "type": "constructor", "idx": 57554, "Desc": "constructs a failedloginexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "FailedLoginException(java.lang.String)", "type": "constructor", "idx": 57555, "Desc": "constructs a failedloginexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "LoginContext(java.lang.String)", "type": "constructor", "idx": 57558, "Desc": "instantiate a new logincontext object with a name ."}{"node_name": "LoginContext(java.lang.String,javax.security.auth.Subject)", "type": "constructor", "idx": 57560, "Desc": "instantiate a new logincontext object with a name and a subject object ."}{"node_name": "LoginContext(java.lang.String,javax.security.auth.callback.CallbackHandler)", "type": "constructor", "idx": 57563, "Desc": "instantiate a new logincontext object with a name and a callbackhandler object ."}{"node_name": "LoginContext(java.lang.String,javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler)", "type": "constructor", "idx": 57566, "Desc": "instantiate a new logincontext object with a name , a subject to be authenticated , and a callbackhandler object ."}{"node_name": "LoginContext(java.lang.String,javax.security.auth.Subject,javax.security.auth.callback.CallbackHandler,javax.security.auth.login.Configuration)", "type": "constructor", "idx": 57570, "Desc": "instantiate a new logincontext object with a name , a subject to be authenticated , a callbackhandler object , and a login configuration ."}{"node_name": "LoginException()", "type": "constructor", "idx": 57579, "Desc": "constructs a loginexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "LoginException(java.lang.String)", "type": "constructor", "idx": 57580, "Desc": "constructs a loginexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "PrivateCredentialPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57583, "Desc": "creates a new privatecredentialpermission with the specified name . the name specifies both a credential class and a principal set ."}{"node_name": "RefreshFailedException()", "type": "constructor", "idx": 57599, "Desc": "constructs a refreshfailedexception with no detail message . a detail message is a string that describes this particular exception ."}{"node_name": "RefreshFailedException(java.lang.String)", "type": "constructor", "idx": 57600, "Desc": "constructs a refreshfailedexception with the specified detail message . a detail message is a string that describes this particular exception ."}{"node_name": "Subject()", "type": "constructor", "idx": 57613, "Desc": "create an instance of a subject with an empty set of principals and empty sets of public and private credentials . the newly constructed sets check whether this subject has been set read-only before permitting subsequent modifications . the newly created sets also prevent illegal modifications by ensuring that callers have sufficient permissions . these sets also prohibit null elements , and attempts to add or query a null element will result in a nullpointerexception . to modify the principals set , the caller must have authpermission ( \" modifyprincipals \") . to modify the public credential set , the caller must have authpermission ( \" modifypubliccredentials \") . to modify the private credential set , the caller must have authpermission ( \" modifyprivatecredentials \") ."}{"node_name": "Subject(boolean,java.util.Set,java.util.Set,java.util.Set)", "type": "constructor", "idx": 57614, "Desc": "create an instance of a subject with principals and credentials . the principals and credentials from the specified sets are copied into newly constructed sets . these newly created sets check whether this subject has been set read-only before permitting subsequent modifications . the newly created sets also prevent illegal modifications by ensuring that callers have sufficient permissions . these sets also prohibit null elements , and attempts to add or query a null element will result in a nullpointerexception . to modify the principals set , the caller must have authpermission ( \" modifyprincipals \") . to modify the public credential set , the caller must have authpermission ( \" modifypubliccredentials \") . to modify the private credential set , the caller must have authpermission ( \" modifyprivatecredentials \") ."}{"node_name": "SubjectDomainCombiner(javax.security.auth.Subject)", "type": "constructor", "idx": 57651, "Desc": "associate the provided subject with this subjectdomaincombiner ."}{"node_name": "X500Principal(java.lang.String)", "type": "constructor", "idx": 57661, "Desc": "creates an x500principal from a string representation of an x.500 distinguished name ( ex : \" cn =d uke , ou=javasoft , o=sun microsystems , c=us \") . the distinguished name must be specified using the grammar defined in rfc 1779 or rfc 2253 ( either format is acceptable ) . <init>(java.lang.String) recognizes the attribute type keywords defined in rfc 1779 and rfc 2253 ( and listed in getname ( string format )) , as well as the t , dnq or dnqualifier , surname , givenname , initials , generation , emailaddress , and serialnumber keywords whose object identifiers ( oids ) are defined in rfc 5280 . any other attribute type must be specified as an oid . this implementation enforces a more restrictive oid syntax than defined in rfc 1779 and 2253 . it uses the more correct syntax defined in rfc 4512 , which specifies that oids contain at least 2 digits : numericoid = number 1 * ( dot number )"}{"node_name": "X500Principal(java.lang.String,java.util.Map)", "type": "constructor", "idx": 57663, "Desc": "creates an x500principal from a string representation of an x.500 distinguished name ( ex : \" cn =d uke , ou=javasoft , o=sun microsystems , c=us \") . the distinguished name must be specified using the grammar defined in rfc 1779 or rfc 2253 ( either format is acceptable ) . <init>(java.lang.String,java.util.Map) recognizes the attribute type keywords specified in x500principal ( string ) and also recognizes additional keywords that have entries in the keywordmap parameter . keyword entries in the keywordmap take precedence over the default keywords recognized by x500principal ( string ) . keywords must be specified in all upper-case , otherwise they will be ignored . improperly specified keywords are ignored ; however if a keyword in the name maps to an improperly specified object identifier ( oid ) , an illegalargumentexception is thrown . it is permissible to have 2 different keywords that map to the same oid . this implementation enforces a more restrictive oid syntax than defined in rfc 1779 and 2253 . it uses the more correct syntax defined in rfc 4512 , which specifies that oids contain at least 2 digits : numericoid = number 1 * ( dot number )"}{"node_name": "X500Principal(byte[])", "type": "constructor", "idx": 57666, "Desc": "creates an x500principal from a distinguished name in asn.1 der encoded form . the asn.1 notation for this structure is as follows . name :: = choice { rdnsequence } rdnsequence :: = sequence of relativedistinguishedname relativedistinguishedname :: = set size ( 1 .. max ) of attributetypeandvalue attributetypeandvalue :: = sequence { type attributetype , value attributevalue } attributetype :: = object identifier attributevalue :: = any defined by attributetype .... directorystring :: = choice { teletexstring teletexstring ( size ( 1 .. max )) , printablestring printablestring ( size ( 1 .. max )) , universalstring universalstring ( size ( 1 .. max )) , utf8string utf8string ( size ( 1 .. max )) , bmpstring bmpstring ( size ( 1 .. max )) }"}{"node_name": "X500Principal(java.io.InputStream)", "type": "constructor", "idx": 57668, "Desc": "creates an x500principal from an inputstream containing the distinguished name in asn.1 der encoded form . the asn.1 notation for this structure is supplied in the documentation for x500principal ( byte [ ] name ) . the read position of the input stream is positioned to the next available byte after the encoded distinguished name ."}{"node_name": "X500PrivateCredential(java.security.cert.X509Certificate,java.security.PrivateKey)", "type": "constructor", "idx": 57682, "Desc": "creates an x500privatecredential that associates an x.509 certificate , a private key and the keystore alias ."}{"node_name": "X500PrivateCredential(java.security.cert.X509Certificate,java.security.PrivateKey,java.lang.String)", "type": "constructor", "idx": 57685, "Desc": "creates an x500privatecredential that associates an x.509 certificate , a private key and the keystore alias ."}{"node_name": "AuthenticationException()", "type": "constructor", "idx": 57702, "Desc": "constructs a new instance of authenticationexception . the root exception and the detailed message are null ."}{"node_name": "AuthenticationException(java.lang.String)", "type": "constructor", "idx": 57703, "Desc": "constructs a new instance of authenticationexception with a detailed message . the root exception is null ."}{"node_name": "AuthenticationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 57705, "Desc": "constructs a new instance of authenticationexception with a detailed message and a root exception ."}{"node_name": "AuthorizeCallback(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57709, "Desc": "constructs an instance of authorizecallback ."}{"node_name": "RealmCallback(java.lang.String)", "type": "constructor", "idx": 57721, "Desc": "constructs a realmcallback with a prompt ."}{"node_name": "RealmCallback(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57723, "Desc": "constructs a realmcallback with a prompt and default realm information ."}{"node_name": "RealmChoiceCallback(java.lang.String,java.lang.String[],int,boolean)", "type": "constructor", "idx": 57727, "Desc": "constructs a realmchoicecallback with a prompt , a list of choices and a default choice ."}{"node_name": "SaslException()", "type": "constructor", "idx": 57790, "Desc": "constructs a new instance of saslexception . the root exception and the detailed message are null ."}{"node_name": "SaslException(java.lang.String)", "type": "constructor", "idx": 57791, "Desc": "constructs a new instance of saslexception with a detailed message . the root exception is null ."}{"node_name": "SaslException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 57793, "Desc": "constructs a new instance of saslexception with a detailed message and a root exception . for example , a saslexception might result from a problem with the callback handler , which might throw a nosuchcallbackexception if it does not support the requested callback , or throw an ioexception if it had problems obtaining data for the callback . the saslexception's root exception would be then be the exception thrown by the callback handler ."}{"node_name": "ATR(byte[])", "type": "constructor", "idx": 57824, "Desc": "constructs an atr from a byte array ."}{"node_name": "Card()", "type": "constructor", "idx": 57833, "Desc": "constructs a new card object . <init>() is called by subclasses only . application should call the cardterminal.connect() method to obtain a card object ."}{"node_name": "CardChannel()", "type": "constructor", "idx": 57846, "Desc": "constructs a new cardchannel object . <init>() is called by subclasses only . application should call the card.getbasicchannel() and card.openlogicalchannel() methods to obtain a cardchannel object ."}{"node_name": "CardException(java.lang.String)", "type": "constructor", "idx": 57856, "Desc": "constructs a new cardexception with the specified detail message ."}{"node_name": "CardException(java.lang.Throwable)", "type": "constructor", "idx": 57858, "Desc": "constructs a new cardexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ."}{"node_name": "CardException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 57860, "Desc": "constructs a new cardexception with the specified detail message and cause ."}{"node_name": "CardNotPresentException(java.lang.String)", "type": "constructor", "idx": 57864, "Desc": "constructs a new cardnotpresentexception with the specified detail message ."}{"node_name": "CardNotPresentException(java.lang.Throwable)", "type": "constructor", "idx": 57866, "Desc": "constructs a new cardnotpresentexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ."}{"node_name": "CardNotPresentException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 57868, "Desc": "constructs a new cardnotpresentexception with the specified detail message and cause ."}{"node_name": "CardPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 57872, "Desc": "constructs a new cardpermission with the specified actions . terminalname is the name of a cardterminal or * if this permission applies to all terminals . actions contains a comma-separated list of the individual actions or * to signify all actions . for more information , see the documentation at the top of this class ."}{"node_name": "CardTerminal()", "type": "constructor", "idx": 57882, "Desc": "constructs a new cardterminal object . <init>() is called by subclasses only . application should call list() or getterminal() to obtain a cardterminal object ."}{"node_name": "CardTerminals()", "type": "constructor", "idx": 57892, "Desc": "constructs a new cardterminals object . <init>() is called by subclasses only . application should call terminalfactory.terminals() to obtain a cardterminals object ."}{"node_name": "CommandAPDU(byte[])", "type": "constructor", "idx": 57906, "Desc": "constructs a commandapdu from a byte array containing the complete apdu contents ( header and body ) . note that the apdu bytes are copied to protect against subsequent modification ."}{"node_name": "CommandAPDU(byte[],int,int)", "type": "constructor", "idx": 57908, "Desc": "constructs a commandapdu from a byte array containing the complete apdu contents ( header and body ) . the apdu starts at the index apduoffset in the byte array and is apdulength bytes long . note that the apdu bytes are copied to protect against subsequent modification ."}{"node_name": "CommandAPDU(java.nio.ByteBuffer)", "type": "constructor", "idx": 57912, "Desc": "creates a commandapdu from the bytebuffer containing the complete apdu contents ( header and body ) . the buffer's position must be set to the start of the apdu , its limit to the end of the apdu . upon return , the buffer's position is equal to its limit ; its limit remains unchanged . note that the data in the bytebuffer is copied to protect against subsequent modification ."}{"node_name": "CommandAPDU(int,int,int,int)", "type": "constructor", "idx": 57914, "Desc": "constructs a commandapdu from the four header bytes . this is case 1 in iso 7816 , no command body ."}{"node_name": "CommandAPDU(int,int,int,int,int)", "type": "constructor", "idx": 57919, "Desc": "constructs a commandapdu from the four header bytes and the expected response data length . this is case 2 in iso 7816 , empty command data field with ne specified . if ne is 0 , the apdu is encoded as iso 7816 case 1 ."}{"node_name": "CommandAPDU(int,int,int,int,byte[])", "type": "constructor", "idx": 57925, "Desc": "constructs a commandapdu from the four header bytes and command data . this is case 3 in iso 7816 , command data present and ne absent . the value nc is taken as data.length . if data is null or its length is 0 , the apdu is encoded as iso 7816 case 1 . note that the data bytes are copied to protect against subsequent modification ."}{"node_name": "CommandAPDU(int,int,int,int,byte[],int,int)", "type": "constructor", "idx": 57931, "Desc": "constructs a commandapdu from the four header bytes and command data . this is case 3 in iso 7816 , command data present and ne absent . the value nc is taken as datalength . if datalength is 0 , the apdu is encoded as iso 7816 case 1 . note that the data bytes are copied to protect against subsequent modification ."}{"node_name": "CommandAPDU(int,int,int,int,byte[],int)", "type": "constructor", "idx": 57939, "Desc": "constructs a commandapdu from the four header bytes , command data , and expected response data length . this is case 4 in iso 7816 , command data and ne present . the value nc is taken as data.length if data is non-null and as 0 otherwise . if ne or nc are zero , the apdu is encoded as case 1 , 2 , or 3 per iso 7816 . note that the data bytes are copied to protect against subsequent modification ."}{"node_name": "CommandAPDU(int,int,int,int,byte[],int,int,int)", "type": "constructor", "idx": 57946, "Desc": "constructs a commandapdu from the four header bytes , command data , and expected response data length . this is case 4 in iso 7816 , command data and le present . the value nc is taken as datalength . if ne or nc are zero , the apdu is encoded as case 1 , 2 , or 3 per iso 7816 . note that the data bytes are copied to protect against subsequent modification ."}{"node_name": "ResponseAPDU(byte[])", "type": "constructor", "idx": 57968, "Desc": "constructs a responseapdu from a byte array containing the complete apdu contents ( conditional body and trailed ) . note that the byte array is cloned to protect against subsequent modification ."}{"node_name": "TerminalFactorySpi()", "type": "constructor", "idx": 57999, "Desc": "constructs a new terminalfactoryspi object . this class is part of the service provider interface and not accessed directly by applications . applications should use terminalfactory objects , which can be obtained by calling one of the terminalfactory.getinstance() methods . concrete subclasses should define a constructor that takes an object as parameter . it will be invoked when an application calls one of the terminalfactory.getinstance() methods and receives the params object specified by the application ."}{"node_name": "Instrument(javax.sound.midi.Soundbank,javax.sound.midi.Patch,java.lang.String,java.lang.Class)", "type": "constructor", "idx": 58005, "Desc": "constructs a new midi instrument from the specified patch . when a subsequent request is made to load the instrument , the sound bank will search its contents for this instrument's patch , and the instrument will be loaded into the synthesizer at the bank and program location indicated by the patch object ."}{"node_name": "InvalidMidiDataException()", "type": "constructor", "idx": 58012, "Desc": "constructs an invalidmididataexception with null for its error detail message ."}{"node_name": "InvalidMidiDataException(java.lang.String)", "type": "constructor", "idx": 58013, "Desc": "constructs an invalidmididataexception with the specified detail message ."}{"node_name": "MetaMessage()", "type": "constructor", "idx": 58020, "Desc": "constructs a new metamessage . the contents of the message are not set here ; use setmessage to set them subsequently ."}{"node_name": "MetaMessage(int,byte[],int)", "type": "constructor", "idx": 58021, "Desc": "constructs a new metamessage and sets the message parameters . the contents of the message can be changed by using the setmessage method ."}{"node_name": "MetaMessage(byte[])", "type": "constructor", "idx": 58025, "Desc": "constructs a new metamessage ."}{"node_name": "Info(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 58083, "Desc": "constructs a device info object ."}{"node_name": "MidiEvent(javax.sound.midi.MidiMessage,long)", "type": "constructor", "idx": 58113, "Desc": "constructs a new midievent ."}{"node_name": "MidiFileFormat(int,float,int,int,long)", "type": "constructor", "idx": 58127, "Desc": "constructs a midifileformat ."}{"node_name": "MidiFileFormat(int,float,int,int,long,java.util.Map)", "type": "constructor", "idx": 58133, "Desc": "construct a midifileformat with a set of properties ."}{"node_name": "MidiMessage(byte[])", "type": "constructor", "idx": 58151, "Desc": "constructs a new midimessage . this protected constructor is called by concrete subclasses , which should ensure that the data array specifies a complete , valid midi message ."}{"node_name": "MidiUnavailableException()", "type": "constructor", "idx": 58205, "Desc": "constructs a midiunavailableexception that has null as its error detail message ."}{"node_name": "MidiUnavailableException(java.lang.String)", "type": "constructor", "idx": 58206, "Desc": "constructs a midiunavailableexception with the specified detail message ."}{"node_name": "Patch(int,int)", "type": "constructor", "idx": 58209, "Desc": "constructs a new patch object from the specified bank and program numbers ."}{"node_name": "Sequence(float,int)", "type": "constructor", "idx": 58228, "Desc": "constructs a new midi sequence with the specified timing division type and timing resolution . the division type must be one of the recognized midi timing types . for tempo-based timing , divisiontype is ppq ( pulses per quarter note ) and the resolution is specified in ticks per beat . for smtpe timing , divisiontype specifies the number of frames per second and the resolution is specified in ticks per frame . the sequence will contain no initial tracks . tracks may be added to or removed from the sequence using createtrack() and deletetrack ( javax.sound.midi.track ) ."}{"node_name": "Sequence(float,int,int)", "type": "constructor", "idx": 58231, "Desc": "constructs a new midi sequence with the specified timing division type , timing resolution , and number of tracks . the division type must be one of the recognized midi timing types . for tempo-based timing , divisiontype is ppq ( pulses per quarter note ) and the resolution is specified in ticks per beat . for smtpe timing , divisiontype specifies the number of frames per second and the resolution is specified in ticks per frame . the sequence will be initialized with the number of tracks specified by numtracks . these tracks are initially empty ( i.e. they contain only the meta-event end of track ) . the tracks may be retrieved for editing using the gettracks() method . additional tracks may be added , or existing tracks removed , using createtrack() and deletetrack ( javax.sound.midi.track ) ."}{"node_name": "SyncMode(java.lang.String)", "type": "constructor", "idx": 58321, "Desc": "constructs a synchronization mode ."}{"node_name": "ShortMessage()", "type": "constructor", "idx": 58346, "Desc": "constructs a new shortmessage . the contents of the new message are guaranteed to specify a valid midi message . subsequently , you may set the contents of the message using one of the setmessage methods ."}{"node_name": "ShortMessage(int)", "type": "constructor", "idx": 58347, "Desc": "constructs a new shortmessage which represents a midi message that takes no data bytes . the contents of the message can be changed by using one of the setmessage methods ."}{"node_name": "ShortMessage(int,int,int)", "type": "constructor", "idx": 58349, "Desc": "constructs a new shortmessage which represents a midi message that takes up to two data bytes . if the message only takes one data byte , the second data byte is ignored . if the message does not take any data bytes , both data bytes are ignored . the contents of the message can be changed by using one of the setmessage methods ."}{"node_name": "ShortMessage(int,int,int,int)", "type": "constructor", "idx": 58353, "Desc": "constructs a new shortmessage which represents a channel midi message that takes up to two data bytes . if the message only takes one data byte , the second data byte is ignored . if the message does not take any data bytes , both data bytes are ignored . the contents of the message can be changed by using one of the setmessage methods ."}{"node_name": "ShortMessage(byte[])", "type": "constructor", "idx": 58358, "Desc": "constructs a new shortmessage ."}{"node_name": "SoundbankResource(javax.sound.midi.Soundbank,java.lang.String,java.lang.Class)", "type": "constructor", "idx": 58388, "Desc": "constructs a new soundbankresource from the given sound bank and wavetable index . ( setting the soundbankresource's name , sampled audio data , and instruments is a subclass responsibility . )"}{"node_name": "MidiDeviceProvider()", "type": "constructor", "idx": 58397, "Desc": ""}{"node_name": "MidiFileReader()", "type": "constructor", "idx": 58404, "Desc": ""}{"node_name": "MidiFileWriter()", "type": "constructor", "idx": 58418, "Desc": ""}{"node_name": "SoundbankReader()", "type": "constructor", "idx": 58436, "Desc": ""}{"node_name": "SysexMessage()", "type": "constructor", "idx": 58473, "Desc": "constructs a new sysexmessage . the contents of the new message are guaranteed to specify a valid midi message . subsequently , you may set the contents of the message using one of the setmessage methods ."}{"node_name": "SysexMessage(byte[],int)", "type": "constructor", "idx": 58474, "Desc": "constructs a new sysexmessage and sets the data for the message . the first byte of the data array must be a valid system exclusive status byte ( 0xf0 or 0xf7 ) . the contents of the message can be changed by using one of the setmessage methods ."}{"node_name": "SysexMessage(int,byte[],int)", "type": "constructor", "idx": 58477, "Desc": "constructs a new sysexmessage and sets the data for the message . the contents of the message can be changed by using one of the setmessage methods ."}{"node_name": "SysexMessage(byte[])", "type": "constructor", "idx": 58481, "Desc": "constructs a new sysexmessage ."}{"node_name": "VoiceStatus()", "type": "constructor", "idx": 58513, "Desc": ""}{"node_name": "AudioFileFormat(javax.sound.sampled.AudioFileFormat.Type,int,javax.sound.sampled.AudioFormat,int)", "type": "constructor", "idx": 58515, "Desc": "constructs an audio file format object . this protected constructor is intended for use by providers of file-reading services when returning information about an audio file or about supported audio file formats ."}{"node_name": "AudioFileFormat(javax.sound.sampled.AudioFileFormat.Type,javax.sound.sampled.AudioFormat,int)", "type": "constructor", "idx": 58520, "Desc": "constructs an audio file format object . this public constructor may be used by applications to describe the properties of a requested audio file ."}{"node_name": "AudioFileFormat(javax.sound.sampled.AudioFileFormat.Type,javax.sound.sampled.AudioFormat,int,java.util.Map)", "type": "constructor", "idx": 58524, "Desc": "construct an audio file format object with a set of defined properties . this public constructor may be used by applications to describe the properties of a requested audio file . the properties map will be copied to prevent any changes to it ."}{"node_name": "Type(java.lang.String,java.lang.String)", "type": "constructor", "idx": 58543, "Desc": "constructs a file type ."}{"node_name": "Encoding(java.lang.String)", "type": "constructor", "idx": 58557, "Desc": "constructs a new encoding ."}{"node_name": "AudioFormat(javax.sound.sampled.AudioFormat.Encoding,float,int,int,int,float,boolean)", "type": "constructor", "idx": 58571, "Desc": "constructs an audioformat with the given parameters . the encoding specifies the convention used to represent the data . the other parameters are further explained in the class description ."}{"node_name": "AudioFormat(javax.sound.sampled.AudioFormat.Encoding,float,int,int,int,float,boolean,java.util.Map)", "type": "constructor", "idx": 58579, "Desc": "constructs an audioformat with the given parameters . the encoding specifies the convention used to represent the data . the other parameters are further explained in the class description ."}{"node_name": "AudioFormat(float,int,int,boolean,boolean)", "type": "constructor", "idx": 58588, "Desc": "constructs an audioformat with a linear pcm encoding and the given parameters . the frame size is set to the number of bytes required to contain one sample from each channel , and the frame rate is set to the sample rate ."}{"node_name": "AudioInputStream(java.io.InputStream,javax.sound.sampled.AudioFormat,long)", "type": "constructor", "idx": 58612, "Desc": "constructs an audio input stream that has the requested format and length in sample frames , using audio data from the specified input stream ."}{"node_name": "AudioInputStream(javax.sound.sampled.TargetDataLine)", "type": "constructor", "idx": 58616, "Desc": "constructs an audio input stream that reads its data from the target data line indicated . the format of the stream is the same as that of the target data line , and the length is audiosystem #not_specified ."}{"node_name": "AudioPermission(java.lang.String)", "type": "constructor", "idx": 58636, "Desc": "creates a new audiopermission object that has the specified symbolic name , such as \" play \" or \" record \" . an asterisk can be used to indicate all audio permissions ."}{"node_name": "AudioPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 58638, "Desc": "creates a new audiopermission object that has the specified symbolic name , such as \" play \" or \" record \" . the actions parameter is currently unused and should be null ."}{"node_name": "BooleanControl(javax.sound.sampled.BooleanControl.Type,boolean,java.lang.String,java.lang.String)", "type": "constructor", "idx": 58715, "Desc": "constructs a new boolean control object with the given parameters ."}{"node_name": "BooleanControl(javax.sound.sampled.BooleanControl.Type,boolean)", "type": "constructor", "idx": 58720, "Desc": "constructs a new boolean control object with the given parameters . the labels for the true and false states default to \" true \" and \" false \" ."}{"node_name": "Type(java.lang.String)", "type": "constructor", "idx": 58732, "Desc": "constructs a new boolean control type ."}{"node_name": "CompoundControl(javax.sound.sampled.CompoundControl.Type,javax.sound.sampled.Control[])", "type": "constructor", "idx": 58755, "Desc": "constructs a new compound control object with the given parameters ."}{"node_name": "Type(java.lang.String)", "type": "constructor", "idx": 58761, "Desc": "constructs a new compound control type ."}{"node_name": "Control(javax.sound.sampled.Control.Type)", "type": "constructor", "idx": 58764, "Desc": "constructs a control with the specified type ."}{"node_name": "Type(java.lang.String)", "type": "constructor", "idx": 58769, "Desc": "constructs a new control type with the name specified . the name should be a descriptive string appropriate for labelling the control in an application , such as \" gain \" or \" balance \" ."}{"node_name": "Info(java.lang.Class,javax.sound.sampled.AudioFormat[],int,int)", "type": "constructor", "idx": 58776, "Desc": "constructs a data line's info object from the specified information , which includes a set of supported audio formats and a range for the buffer size . <init>(java.lang.Class,javax.sound.sampled.AudioFormat[],int,int) is typically used by mixer implementations when returning information about a supported line ."}{"node_name": "Info(java.lang.Class,javax.sound.sampled.AudioFormat,int)", "type": "constructor", "idx": 58781, "Desc": "constructs a data line's info object from the specified information , which includes a single audio format and a desired buffer size . <init>(java.lang.Class,javax.sound.sampled.AudioFormat,int) is typically used by an application to describe a desired line ."}{"node_name": "Info(java.lang.Class,javax.sound.sampled.AudioFormat)", "type": "constructor", "idx": 58785, "Desc": "constructs a data line's info object from the specified information , which includes a single audio format . <init>(java.lang.Class,javax.sound.sampled.AudioFormat) is typically used by an application to describe a desired line ."}{"node_name": "EnumControl(javax.sound.sampled.EnumControl.Type,java.lang.Object[],java.lang.Object)", "type": "constructor", "idx": 58811, "Desc": "constructs a new enumerated control object with the given parameters ."}{"node_name": "Type(java.lang.String)", "type": "constructor", "idx": 58822, "Desc": "constructs a new enumerated control type ."}{"node_name": "FloatControl(javax.sound.sampled.FloatControl.Type,float,float,float,int,float,java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 58825, "Desc": "constructs a new float control object with the given parameters ."}{"node_name": "FloatControl(javax.sound.sampled.FloatControl.Type,float,float,float,int,float,java.lang.String)", "type": "constructor", "idx": 58836, "Desc": "constructs a new float control object with the given parameters . the labels for the minimum , maximum , and mid-point values are set to zero-length strings ."}{"node_name": "Type(java.lang.String)", "type": "constructor", "idx": 58870, "Desc": "constructs a new float control type ."}{"node_name": "Info(java.lang.Class)", "type": "constructor", "idx": 58873, "Desc": "constructs an info object that describes a line of the specified class . <init>(java.lang.Class) is typically used by an application to describe a desired line ."}{"node_name": "LineEvent(javax.sound.sampled.Line,javax.sound.sampled.LineEvent.Type,long)", "type": "constructor", "idx": 58894, "Desc": "constructs a new event of the specified type , originating from the specified line ."}{"node_name": "Type(java.lang.String)", "type": "constructor", "idx": 58907, "Desc": "constructs a new event type ."}{"node_name": "LineUnavailableException()", "type": "constructor", "idx": 58917, "Desc": "constructs a lineunavailableexception that has null as its error detail message ."}{"node_name": "LineUnavailableException(java.lang.String)", "type": "constructor", "idx": 58918, "Desc": "constructs a lineunavailableexception that has the specified detail message ."}{"node_name": "Info(java.lang.String,java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 58921, "Desc": "constructs a mixer's info object , passing it the given textual information ."}{"node_name": "Info(java.lang.Class,java.lang.String,boolean)", "type": "constructor", "idx": 58965, "Desc": "constructs a port's info object from the information given . <init>(java.lang.Class,java.lang.String,boolean) is typically used by an implementation of java sound to describe a supported line ."}{"node_name": "ReverbType(java.lang.String,int,float,int,float,int)", "type": "constructor", "idx": 58979, "Desc": "constructs a new reverb type that has the specified reverberation parameter values ."}{"node_name": "AudioFileReader()", "type": "constructor", "idx": 59007, "Desc": ""}{"node_name": "AudioFileWriter()", "type": "constructor", "idx": 59021, "Desc": ""}{"node_name": "FormatConversionProvider()", "type": "constructor", "idx": 59039, "Desc": ""}{"node_name": "MixerProvider()", "type": "constructor", "idx": 59064, "Desc": ""}{"node_name": "UnsupportedAudioFileException()", "type": "constructor", "idx": 59081, "Desc": "constructs an unsupportedaudiofileexception that has null as its error detail message ."}{"node_name": "UnsupportedAudioFileException(java.lang.String)", "type": "constructor", "idx": 59082, "Desc": "constructs an unsupportedaudiofileexception that has the specified detail message ."}{"node_name": "ConnectionEvent(javax.sql.PooledConnection)", "type": "constructor", "idx": 59094, "Desc": "constructs a connectionevent object initialized with the given pooledconnection object . sqlexception defaults to null ."}{"node_name": "ConnectionEvent(javax.sql.PooledConnection,java.sql.SQLException)", "type": "constructor", "idx": 59096, "Desc": "constructs a connectionevent object initialized with the given pooledconnection object and sqlexception object ."}{"node_name": "BaseRowSet()", "type": "constructor", "idx": 59158, "Desc": "constructs a new baserowset object initialized with a default vector object for its listeners field . the other default values with which it is initialized are listed in section 6.0 of the class comment for this class ."}{"node_name": "RowSetMetaDataImpl()", "type": "constructor", "idx": 59976, "Desc": ""}{"node_name": "RowSetProvider()", "type": "constructor", "idx": 60073, "Desc": "rowsetprovider constructor"}{"node_name": "RowSetWarning(java.lang.String)", "type": "constructor", "idx": 60079, "Desc": "constructs a rowsetwarning object with the given value for the reason ; sqlstate defaults to null , and vendorcode defaults to 0 ."}{"node_name": "RowSetWarning()", "type": "constructor", "idx": 60081, "Desc": "constructs a default rowsetwarning object . the reason defaults to null , sqlstate defaults to null and vendorcode defaults to 0 ."}{"node_name": "RowSetWarning(java.lang.String,java.lang.String)", "type": "constructor", "idx": 60082, "Desc": "constructs a rowsetwarning object initialized with the given values for the reason and sqlstate . the vendor code defaults to 0 . if the reason or sqlstate parameters are null , <init>(java.lang.String,java.lang.String) behaves like the default ( zero parameter ) rowsetwarning constructor ."}{"node_name": "RowSetWarning(java.lang.String,java.lang.String,int)", "type": "constructor", "idx": 60085, "Desc": "constructs a fully specified rowsetwarning object initialized with the given values for the reason , sqlstate and vendorcode . if the reason , or the sqlstate parameters are null , <init>(java.lang.String,java.lang.String,int) behaves like the default ( zero parameter ) rowsetwarning constructor ."}{"node_name": "SerialArray(java.sql.Array,java.util.Map)", "type": "constructor", "idx": 60093, "Desc": "constructs a new serialarray object from the given array object , using the given type map for the custom mapping of each element when the elements are sql udts . this method does custom mapping if the array elements are a udt and the given type map has an entry for that udt . custom mapping is recursive , meaning that if , for instance , an element of an sql structured type is an sql structured type that itself has an element that is an sql structured type , each structured type that has a custom mapping will be mapped according to the given type map . the new serialarray object contains the same elements as the array object from which it is built , except when the base type is the sql type struct , array , blob , clob , datalink or java_object . in this case , each element in the new serialarray object is the appropriate serialized form , that is , a serialstruct , serialarray , serialblob , serialclob , serialdatalink , or serialjavaobject object . note : ( 1 ) the array object from which a serialarray object is created must have materialized the sql array value's data on the client before it is passed to <init>(java.sql.Array,java.util.Map) . otherwise , the new serialarray object will contain no data . note : ( 2 ) if the array contains java.sql.types.java_object types , the serialjavaobject constructor is called where checks are made to ensure this object is serializable . note : ( 3 ) the array object supplied to <init>(java.sql.Array,java.util.Map) cannot return null for any array.getarray() methods . serialarray cannot serialize null array values ."}{"node_name": "SerialArray(java.sql.Array)", "type": "constructor", "idx": 60096, "Desc": "constructs a new serialarray object from the given array object . <init>(java.sql.Array) does not do custom mapping . if the base type of the array is an sql structured type and custom mapping is desired , <init>(java.sql.Array) serialarray ( array array , map map ) should be used . the new serialarray object contains the same elements as the array object from which it is built , except when the base type is the sql type blob , clob , datalink or java_object . in this case , each element in the new serialarray object is the appropriate serialized form , that is , a serialblob , serialclob , serialdatalink , or serialjavaobject object . note : ( 1 ) the array object from which a serialarray object is created must have materialized the sql array value's data on the client before it is passed to <init>(java.sql.Array) . otherwise , the new serialarray object will contain no data . note : ( 2 ) the array object supplied to <init>(java.sql.Array) cannot return null for any array.getarray() methods . serialarray cannot serialize null array values ."}{"node_name": "SerialBlob(byte[])", "type": "constructor", "idx": 60126, "Desc": "constructs a serialblob object that is a serialized version of the given byte array . the new serialblob object is initialized with the data from the byte array , thus allowing disconnected rowset objects to establish serialized blob objects without touching the data source ."}{"node_name": "SerialBlob(java.sql.Blob)", "type": "constructor", "idx": 60128, "Desc": "constructs a serialblob object that is a serialized version of the given blob object . the new serialblob object is initialized with the data from the blob object ; therefore , the blob object should have previously brought the sql blob value's data over to the client from the database . otherwise , the new serialblob object will contain no data ."}{"node_name": "SerialClob(char[])", "type": "constructor", "idx": 60162, "Desc": "constructs a serialclob object that is a serialized version of the given char array . the new serialclob object is initialized with the data from the char array , thus allowing disconnected rowset objects to establish a serialized clob object without touching the data source ."}{"node_name": "SerialClob(java.sql.Clob)", "type": "constructor", "idx": 60164, "Desc": "constructs a serialclob object that is a serialized version of the given clob object . the new serialclob object is initialized with the data from the clob object ; therefore , the clob object should have previously brought the sql clob value's data over to the client from the database . otherwise , the new serialclob object object will contain no data . note : the clob object supplied to <init>(java.sql.Clob) must return non-null for both the clob.getcharacterstream() and clob.getasciistream methods . this serialclob constructor cannot serialize a clob object in this instance and will throw an sqlexception object ."}{"node_name": "SerialDatalink(java.net.URL)", "type": "constructor", "idx": 60201, "Desc": "constructs a new serialdatalink object from the given java.net.url object ."}{"node_name": "SerialException()", "type": "constructor", "idx": 60209, "Desc": "creates a new serialexception without a message ."}{"node_name": "SerialException(java.lang.String)", "type": "constructor", "idx": 60210, "Desc": "creates a new serialexception with the specified message ."}{"node_name": "SerialJavaObject(java.lang.Object)", "type": "constructor", "idx": 60213, "Desc": "constructor for serialjavaobject helper class ."}{"node_name": "SerialRef(java.sql.Ref)", "type": "constructor", "idx": 60222, "Desc": "constructs a serialref object from the given ref object ."}{"node_name": "SerialStruct(java.sql.Struct,java.util.Map)", "type": "constructor", "idx": 60235, "Desc": "constructs a serialstruct object from the given struct object , using the given java.util.map object for custom mapping the sql structured type or any of its attributes that are sql structured types ."}{"node_name": "SerialStruct(java.sql.SQLData,java.util.Map)", "type": "constructor", "idx": 60238, "Desc": "constructs a serialstruct object from the given sqldata object , using the given type map to custom map it to a class in the java programming language . the type map gives the sql type and the class to which it is mapped . the sqldata object defines the class to which the sql type will be mapped ."}{"node_name": "SQLInputImpl(java.lang.Object[],java.util.Map)", "type": "constructor", "idx": 60250, "Desc": "creates an sqlinputimpl object initialized with the given array of attributes and the given type map . if any of the attributes is a udt whose name is in an entry in the type map , the attribute will be mapped according to the corresponding sqldata implementation ."}{"node_name": "SQLOutputImpl(java.util.Vector,java.util.Map)", "type": "constructor", "idx": 60281, "Desc": "creates a new sqloutputimpl object initialized with the given vector of attributes and type map . the driver will use the type map to determine which sqldata.writesql method to invoke . this method will then call the appropriate sqloutputimpl writer methods in order and thereby write the attributes to the new output stream ."}{"node_name": "SyncFactoryException()", "type": "constructor", "idx": 60359, "Desc": "creates new syncfactoryexception without detail message ."}{"node_name": "SyncFactoryException(java.lang.String)", "type": "constructor", "idx": 60360, "Desc": "constructs an syncfactoryexception with the specified detail message ."}{"node_name": "SyncProvider()", "type": "constructor", "idx": 60374, "Desc": "creates a default syncprovider object ."}{"node_name": "SyncProviderException()", "type": "constructor", "idx": 60386, "Desc": "creates a new syncproviderexception object without a detail message ."}{"node_name": "SyncProviderException(java.lang.String)", "type": "constructor", "idx": 60387, "Desc": "constructs a syncproviderexception object with the specified detail message ."}{"node_name": "SyncProviderException(javax.sql.rowset.spi.SyncResolver)", "type": "constructor", "idx": 60389, "Desc": "constructs a syncproviderexception object with the specified syncresolver instance ."}{"node_name": "RowSetEvent(javax.sql.RowSet)", "type": "constructor", "idx": 60443, "Desc": "constructs a rowsetevent object initialized with the given rowset object ."}{"node_name": "StatementEvent(javax.sql.PooledConnection,java.sql.PreparedStatement)", "type": "constructor", "idx": 60517, "Desc": "constructs a statementevent with the specified pooledconnection and preparedstatement . the sqlexception contained in the event defaults to null ."}{"node_name": "StatementEvent(javax.sql.PooledConnection,java.sql.PreparedStatement,java.sql.SQLException)", "type": "constructor", "idx": 60520, "Desc": "constructs a statementevent with the specified pooledconnection , preparedstatement and sqlexception"}{"node_name": "AbstractAction()", "type": "constructor", "idx": 60558, "Desc": "creates an action ."}{"node_name": "AbstractAction(java.lang.String)", "type": "constructor", "idx": 60559, "Desc": "creates an action with the specified name ."}{"node_name": "AbstractAction(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 60561, "Desc": "creates an action with the specified name and small icon ."}{"node_name": "AccessibleAbstractButton()", "type": "constructor", "idx": 60584, "Desc": ""}{"node_name": "AbstractButton()", "type": "constructor", "idx": 60650, "Desc": ""}{"node_name": "AbstractCellEditor()", "type": "constructor", "idx": 60800, "Desc": ""}{"node_name": "AbstractListModel()", "type": "constructor", "idx": 60816, "Desc": ""}{"node_name": "AbstractSpinnerModel()", "type": "constructor", "idx": 60838, "Desc": ""}{"node_name": "ActionMap()", "type": "constructor", "idx": 60874, "Desc": "creates an actionmap with no parent and no mappings ."}{"node_name": "AbstractBorder()", "type": "constructor", "idx": 60890, "Desc": ""}{"node_name": "BevelBorder(int)", "type": "constructor", "idx": 60931, "Desc": "creates a bevel border with the specified type and whose colors will be derived from the background color of the component passed into the paintborder method ."}{"node_name": "BevelBorder(int,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 60933, "Desc": "creates a bevel border with the specified type , highlight and shadow colors ."}{"node_name": "BevelBorder(int,java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 60937, "Desc": "creates a bevel border with the specified type , highlight and shadow colors ."}{"node_name": "CompoundBorder()", "type": "constructor", "idx": 60995, "Desc": "creates a compound border with null outside and inside borders ."}{"node_name": "CompoundBorder(javax.swing.border.Border,javax.swing.border.Border)", "type": "constructor", "idx": 60996, "Desc": "creates a compound border with the specified outside and inside borders . either border may be null ."}{"node_name": "EmptyBorder(int,int,int,int)", "type": "constructor", "idx": 61017, "Desc": "creates an empty border with the specified insets ."}{"node_name": "EmptyBorder(java.awt.Insets)", "type": "constructor", "idx": 61022, "Desc": "creates an empty border with the specified insets ."}{"node_name": "EtchedBorder()", "type": "constructor", "idx": 61042, "Desc": "creates a lowered etched border whose colors will be derived from the background color of the component passed into the paintborder method ."}{"node_name": "EtchedBorder(int)", "type": "constructor", "idx": 61043, "Desc": "creates an etched border with the specified etch-type whose colors will be derived from the background color of the component passed into the paintborder method ."}{"node_name": "EtchedBorder(java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 61045, "Desc": "creates a lowered etched border with the specified highlight and shadow colors ."}{"node_name": "EtchedBorder(int,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 61048, "Desc": "creates an etched border with the specified etch-type , highlight and shadow colors ."}{"node_name": "LineBorder(java.awt.Color)", "type": "constructor", "idx": 61074, "Desc": "creates a line border with the specified color and a thickness = 1 ."}{"node_name": "LineBorder(java.awt.Color,int)", "type": "constructor", "idx": 61076, "Desc": "creates a line border with the specified color and thickness ."}{"node_name": "LineBorder(java.awt.Color,int,boolean)", "type": "constructor", "idx": 61079, "Desc": "creates a line border with the specified color , thickness , and corner shape ."}{"node_name": "MatteBorder(int,int,int,int,java.awt.Color)", "type": "constructor", "idx": 61102, "Desc": "creates a matte border with the specified insets and color ."}{"node_name": "MatteBorder(java.awt.Insets,java.awt.Color)", "type": "constructor", "idx": 61108, "Desc": "creates a matte border with the specified insets and color ."}{"node_name": "MatteBorder(int,int,int,int,javax.swing.Icon)", "type": "constructor", "idx": 61111, "Desc": "creates a matte border with the specified insets and tile icon ."}{"node_name": "MatteBorder(java.awt.Insets,javax.swing.Icon)", "type": "constructor", "idx": 61117, "Desc": "creates a matte border with the specified insets and tile icon ."}{"node_name": "MatteBorder(javax.swing.Icon)", "type": "constructor", "idx": 61120, "Desc": "creates a matte border with the specified tile icon . the insets will be calculated dynamically based on the size of the tile icon , where the top and bottom will be equal to the tile icon's height , and the left and right will be equal to the tile icon's width ."}{"node_name": "SoftBevelBorder(int)", "type": "constructor", "idx": 61137, "Desc": "creates a bevel border with the specified type and whose colors will be derived from the background color of the component passed into the paintborder method ."}{"node_name": "SoftBevelBorder(int,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 61139, "Desc": "creates a bevel border with the specified type , highlight and shadow colors ."}{"node_name": "SoftBevelBorder(int,java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 61143, "Desc": "creates a bevel border with the specified type , highlight shadow colors ."}{"node_name": "StrokeBorder(java.awt.BasicStroke)", "type": "constructor", "idx": 61161, "Desc": "creates a border of the specified stroke . the component's foreground color will be used to render the border ."}{"node_name": "StrokeBorder(java.awt.BasicStroke,java.awt.Paint)", "type": "constructor", "idx": 61163, "Desc": "creates a border of the specified stroke and paint . if the specified paint is null , the component's foreground color will be used to render the border ."}{"node_name": "TitledBorder(java.lang.String)", "type": "constructor", "idx": 61201, "Desc": "creates a titledborder instance ."}{"node_name": "TitledBorder(javax.swing.border.Border)", "type": "constructor", "idx": 61203, "Desc": "creates a titledborder instance with the specified border and an empty title ."}{"node_name": "TitledBorder(javax.swing.border.Border,java.lang.String)", "type": "constructor", "idx": 61205, "Desc": "creates a titledborder instance with the specified border and title ."}{"node_name": "TitledBorder(javax.swing.border.Border,java.lang.String,int,int)", "type": "constructor", "idx": 61208, "Desc": "creates a titledborder instance with the specified border , title , title-justification , and title-position ."}{"node_name": "TitledBorder(javax.swing.border.Border,java.lang.String,int,int,java.awt.Font)", "type": "constructor", "idx": 61213, "Desc": "creates a titledborder instance with the specified border , title , title-justification , title-position , and title-font ."}{"node_name": "TitledBorder(javax.swing.border.Border,java.lang.String,int,int,java.awt.Font,java.awt.Color)", "type": "constructor", "idx": 61219, "Desc": "creates a titledborder instance with the specified border , title , title-justification , title-position , title-font , and title-color ."}{"node_name": "AccessibleBox()", "type": "constructor", "idx": 61404, "Desc": ""}{"node_name": "AccessibleBoxFiller()", "type": "constructor", "idx": 61407, "Desc": ""}{"node_name": "Filler(java.awt.Dimension,java.awt.Dimension,java.awt.Dimension)", "type": "constructor", "idx": 61410, "Desc": "constructor to create shape with the given size ranges ."}{"node_name": "Box(int)", "type": "constructor", "idx": 61422, "Desc": "creates a box that displays its components along the specified axis ."}{"node_name": "BoxLayout(java.awt.Container,int)", "type": "constructor", "idx": 61445, "Desc": "creates a layout manager that will lay out components along the given axis ."}{"node_name": "ButtonGroup()", "type": "constructor", "idx": 61474, "Desc": "creates a new buttongroup ."}{"node_name": "AccessibleCellRendererPane()", "type": "constructor", "idx": 61538, "Desc": ""}{"node_name": "CellRendererPane()", "type": "constructor", "idx": 61542, "Desc": "construct a cellrendererpane object ."}{"node_name": "AbstractColorChooserPanel()", "type": "constructor", "idx": 61577, "Desc": ""}{"node_name": "DefaultColorSelectionModel()", "type": "constructor", "idx": 61610, "Desc": "creates a defaultcolorselectionmodel with the current color set to color.white . this is the default constructor ."}{"node_name": "DefaultColorSelectionModel(java.awt.Color)", "type": "constructor", "idx": 61611, "Desc": "creates a defaultcolorselectionmodel with the current color set to color , which should be non-null . note that setting the color to null is undefined and may have unpredictable results ."}{"node_name": "ComponentInputMap(javax.swing.JComponent)", "type": "constructor", "idx": 61637, "Desc": "creates a componentinputmap associated with the specified component ."}{"node_name": "DebugGraphics()", "type": "constructor", "idx": 61653, "Desc": "constructs a new debug graphics context that supports slowed down drawing ."}{"node_name": "DebugGraphics(java.awt.Graphics,javax.swing.JComponent)", "type": "constructor", "idx": 61654, "Desc": "constructs a debug graphics context from an existing graphics context that slows down drawing for the specified component ."}{"node_name": "DebugGraphics(java.awt.Graphics)", "type": "constructor", "idx": 61657, "Desc": "constructs a debug graphics context from an existing graphics context that supports slowed down drawing ."}{"node_name": "DefaultBoundedRangeModel()", "type": "constructor", "idx": 61872, "Desc": "initializes all of the properties with default values . those values are : value = 0 extent = 0 minimum = 0 maximum = 100 adjusting = false"}{"node_name": "DefaultBoundedRangeModel(int,int,int,int)", "type": "constructor", "idx": 61873, "Desc": "initializes value , extent , minimum and maximum . adjusting is false . throws an illegalargumentexception if the following constraints aren't satisfied : min <= value <= value+extent <= max"}{"node_name": "DefaultButtonModel()", "type": "constructor", "idx": 61920, "Desc": "constructs a defaultbuttonmodel ."}{"node_name": "EditorDelegate()", "type": "constructor", "idx": 61935, "Desc": ""}{"node_name": "DefaultCellEditor(javax.swing.JTextField)", "type": "constructor", "idx": 61955, "Desc": "constructs a defaultcelleditor that uses a text field ."}{"node_name": "DefaultCellEditor(javax.swing.JCheckBox)", "type": "constructor", "idx": 61957, "Desc": "constructs a defaultcelleditor object that uses a check box ."}{"node_name": "DefaultCellEditor(javax.swing.JComboBox)", "type": "constructor", "idx": 61959, "Desc": "constructs a defaultcelleditor object that uses a combo box ."}{"node_name": "DefaultComboBoxModel()", "type": "constructor", "idx": 61986, "Desc": "constructs an empty defaultcomboboxmodel object ."}{"node_name": "DefaultComboBoxModel(java.lang.Object[])", "type": "constructor", "idx": 61987, "Desc": "constructs a defaultcomboboxmodel object initialized with an array of objects ."}{"node_name": "DefaultComboBoxModel(java.util.Vector)", "type": "constructor", "idx": 61989, "Desc": "constructs a defaultcomboboxmodel object initialized with a vector ."}{"node_name": "DefaultDesktopManager()", "type": "constructor", "idx": 62002, "Desc": ""}{"node_name": "DefaultFocusManager()", "type": "constructor", "idx": 62048, "Desc": "constructs a defaultfocusmanager ."}{"node_name": "DefaultListCellRenderer()", "type": "constructor", "idx": 62064, "Desc": "constructs a default renderer object for an item in a list ."}{"node_name": "UIResource()", "type": "constructor", "idx": 62115, "Desc": ""}{"node_name": "DefaultListModel()", "type": "constructor", "idx": 62117, "Desc": ""}{"node_name": "DefaultListSelectionModel()", "type": "constructor", "idx": 62185, "Desc": ""}{"node_name": "DefaultRowSorter()", "type": "constructor", "idx": 62228, "Desc": "creates an empty defaultrowsorter ."}{"node_name": "ModelWrapper()", "type": "constructor", "idx": 62278, "Desc": "creates a new modelwrapper ."}{"node_name": "DefaultSingleSelectionModel()", "type": "constructor", "idx": 62293, "Desc": ""}{"node_name": "AncestorEvent(javax.swing.JComponent,int,java.awt.Container,java.awt.Container)", "type": "constructor", "idx": 62352, "Desc": "constructs an ancestorevent object to identify a change in an ancestor-component ' s display-status ."}{"node_name": "CaretEvent(java.lang.Object)", "type": "constructor", "idx": 62368, "Desc": "creates a new caretevent object ."}{"node_name": "ChangeEvent(java.lang.Object)", "type": "constructor", "idx": 62381, "Desc": "constructs a changeevent object ."}{"node_name": "EventListenerList()", "type": "constructor", "idx": 62412, "Desc": ""}{"node_name": "HyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL)", "type": "constructor", "idx": 62432, "Desc": "creates a new object representing a hypertext link event . the other constructor is preferred , as it provides more information if a url could not be formed . <init>(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL) is primarily for backward compatibility ."}{"node_name": "HyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String)", "type": "constructor", "idx": 62436, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "HyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String,javax.swing.text.Element)", "type": "constructor", "idx": 62441, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "HyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String,javax.swing.text.Element,java.awt.event.InputEvent)", "type": "constructor", "idx": 62447, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "InternalFrameAdapter()", "type": "constructor", "idx": 62463, "Desc": ""}{"node_name": "InternalFrameEvent(javax.swing.JInternalFrame,int)", "type": "constructor", "idx": 62488, "Desc": "constructs an internalframeevent object ."}{"node_name": "ListDataEvent(java.lang.Object,int,int,int)", "type": "constructor", "idx": 62512, "Desc": "constructs a listdataevent object . if index0 is > index1 , index0 and index1 will be swapped such that index0 will always be <= index1 ."}{"node_name": "ListSelectionEvent(java.lang.Object,int,int,boolean)", "type": "constructor", "idx": 62529, "Desc": "represents a change in selection status between firstindex and lastindex , inclusive . firstindex is less than or equal to lastindex . the selection of at least one index within the range will have changed ."}{"node_name": "MenuDragMouseEvent(java.awt.Component,int,long,int,int,int,int,boolean,javax.swing.MenuElement[],javax.swing.MenuSelectionManager)", "type": "constructor", "idx": 62542, "Desc": "constructs a menudragmouseevent object . absolute coordinates xabs and yabs are set to source's location on screen plus relative coordinates x and y . xabs and yabs are set to zero if the source is not showing ."}{"node_name": "MenuDragMouseEvent(java.awt.Component,int,long,int,int,int,int,int,int,boolean,javax.swing.MenuElement[],javax.swing.MenuSelectionManager)", "type": "constructor", "idx": 62553, "Desc": "constructs a menudragmouseevent object . even if inconsistent values for relative and absolute coordinates are passed to <init>(java.awt.Component,int,long,int,int,int,int,int,int,boolean,javax.swing.MenuElement[],javax.swing.MenuSelectionManager) , the menudragmouseevent instance is still created ."}{"node_name": "MenuEvent(java.lang.Object)", "type": "constructor", "idx": 62578, "Desc": "constructs a menuevent object ."}{"node_name": "MenuKeyEvent(java.awt.Component,int,long,int,int,char,javax.swing.MenuElement[],javax.swing.MenuSelectionManager)", "type": "constructor", "idx": 62581, "Desc": "constructs a menukeyevent object ."}{"node_name": "MouseInputAdapter()", "type": "constructor", "idx": 62607, "Desc": ""}{"node_name": "PopupMenuEvent(java.lang.Object)", "type": "constructor", "idx": 62610, "Desc": "constructs a popupmenuevent object ."}{"node_name": "RowSorterEvent(javax.swing.RowSorter)", "type": "constructor", "idx": 62620, "Desc": "creates a rowsorterevent of type sort_order_changed ."}{"node_name": "RowSorterEvent(javax.swing.RowSorter,javax.swing.event.RowSorterEvent.Type,int[])", "type": "constructor", "idx": 62622, "Desc": "creates a rowsorterevent ."}{"node_name": "SwingPropertyChangeSupport(java.lang.Object)", "type": "constructor", "idx": 62639, "Desc": "constructs a swingpropertychangesupport object ."}{"node_name": "SwingPropertyChangeSupport(java.lang.Object,boolean)", "type": "constructor", "idx": 62641, "Desc": "constructs a swingpropertychangesupport object ."}{"node_name": "TableColumnModelEvent(javax.swing.table.TableColumnModel,int,int)", "type": "constructor", "idx": 62650, "Desc": "constructs a tablecolumnmodelevent object ."}{"node_name": "TableModelEvent(javax.swing.table.TableModel)", "type": "constructor", "idx": 62677, "Desc": "all row data in the table has changed , listeners should discard any state that was based on the rows and requery the tablemodel to get the new row count and all the appropriate values . the jtable will repaint the entire visible region on receiving this event , querying the model for the cell values that are visible . the structure of the table ie , the column names , types and order have not changed ."}{"node_name": "TableModelEvent(javax.swing.table.TableModel,int)", "type": "constructor", "idx": 62679, "Desc": "this row of data has been updated . to denote the arrival of a completely new table with a different structure use header_row as the value for the row . when the jtable receives this event and its autocreatecolumnsfrommodel flag is set it discards any tablecolumns that it had and reallocates default ones in the order they appear in the model . this is the same as calling setmodel ( tablemodel ) on the jtable ."}{"node_name": "TableModelEvent(javax.swing.table.TableModel,int,int)", "type": "constructor", "idx": 62682, "Desc": "the data in rows [ firstrow , lastrow ] have been updated ."}{"node_name": "TableModelEvent(javax.swing.table.TableModel,int,int,int)", "type": "constructor", "idx": 62686, "Desc": "the cells in column column in the range [ firstrow , lastrow ] have been updated ."}{"node_name": "TableModelEvent(javax.swing.table.TableModel,int,int,int,int)", "type": "constructor", "idx": 62691, "Desc": "the cells from ( firstrow , column ) to ( lastrow , column ) have been changed . the column refers to the column index of the cell in the model's co-ordinate system . when column is all_columns , all cells in the specified range of rows are considered changed . the type should be one of : insert , update and delete ."}{"node_name": "TreeExpansionEvent(java.lang.Object,javax.swing.tree.TreePath)", "type": "constructor", "idx": 62706, "Desc": "constructs a treeexpansionevent object ."}{"node_name": "TreeModelEvent(java.lang.Object,java.lang.Object[],int[],java.lang.Object[])", "type": "constructor", "idx": 62719, "Desc": "used to create an event when nodes have been changed , inserted , or removed , identifying the path to the parent of the modified items as an array of objects . all of the modified objects are siblings which are direct descendents ( not grandchildren ) of the specified parent . the positions at which the inserts , deletes , or changes occurred are specified by an array of int . the indexes in that array must be in order , from lowest to highest . for changes , the indexes in the model correspond exactly to the indexes of items currently displayed in the ui . as a result , it is not really critical if the indexes are not in their exact order . but after multiple inserts or deletes , the items currently in the ui no longer correspond to the items in the model . it is therefore critical to specify the indexes properly for inserts and deletes . for inserts , the indexes represent the final state of the tree , after the inserts have occurred . since the indexes must be specified in order , the most natural processing methodology is to do the inserts starting at the lowest index and working towards the highest . accumulate a vector of integer objects that specify the insert-locations as you go , then convert the vector to an array of int to create the event . when the postition-index equals zero , the node is inserted at the beginning of the list . when the position index equals the size of the list , the node is \" inserted \" at ( appended to ) the end of the list . for deletes , the indexes represent the initial state of the tree , before the deletes have occurred . since the indexes must be specified in order , the most natural processing methodology is to use a delete-counter . start by initializing the counter to zero and start work through the list from lowest to highest . every time you do a delete , add the current value of the delete-counter to the index-position where the delete occurred , and append the result to a vector of delete-locations , using addelement() . then increment the delete-counter . the index positions stored in the vector therefore reflect the effects of all previous deletes , so they represent each object's position in the initial tree . ( you could also start at the highest index and working back towards the lowest , accumulating a vector of delete-locations as you go using the insertelementat ( integer , 0 ) . ) however you produce the vector of initial-positions , you then need to convert the vector of integer objects to an array of int to create the event . notes : like the insertnodeinto method in the defaulttreemodel class , insertelementat appends to the vector when the index matches the size of the vector . so you can use insertelementat ( integer , 0 ) even when the vector is empty . to create a node changed event for the root node , specify the parent and the child indices as null ."}{"node_name": "TreeModelEvent(java.lang.Object,javax.swing.tree.TreePath,int[],java.lang.Object[])", "type": "constructor", "idx": 62724, "Desc": "used to create an event when nodes have been changed , inserted , or removed , identifying the path to the parent of the modified items as a treepath object . for more information on how to specify the indexes and objects , see treemodelevent ( object , object [ ] , int [ ] , object [ ]) ."}{"node_name": "TreeModelEvent(java.lang.Object,java.lang.Object[])", "type": "constructor", "idx": 62729, "Desc": "used to create an event when the node structure has changed in some way , identifying the path to the root of a modified subtree as an array of objects . a structure change event might involve nodes swapping position , for example , or it might encapsulate multiple inserts and deletes in the subtree stemming from the node , where the changes may have taken place at different levels of the subtree . note : jtree collapses all nodes under the specified node , so that only its immediate children are visible ."}{"node_name": "TreeModelEvent(java.lang.Object,javax.swing.tree.TreePath)", "type": "constructor", "idx": 62732, "Desc": "used to create an event when the node structure has changed in some way , identifying the path to the root of the modified subtree as a treepath object . for more information on this event specification , see treemodelevent ( object , object [ ]) ."}{"node_name": "TreeSelectionEvent(java.lang.Object,javax.swing.tree.TreePath[],boolean[],javax.swing.tree.TreePath,javax.swing.tree.TreePath)", "type": "constructor", "idx": 62754, "Desc": "represents a change in the selection of a treeselectionmodel . paths identifies the paths that have been either added or removed from the selection ."}{"node_name": "TreeSelectionEvent(java.lang.Object,javax.swing.tree.TreePath,boolean,javax.swing.tree.TreePath,javax.swing.tree.TreePath)", "type": "constructor", "idx": 62760, "Desc": "represents a change in the selection of a treeselectionmodel . path identifies the path that has been either added or removed from the selection ."}{"node_name": "UndoableEditEvent(java.lang.Object,javax.swing.undo.UndoableEdit)", "type": "constructor", "idx": 62786, "Desc": "constructs an undoableeditevent object ."}{"node_name": "FileFilter()", "type": "constructor", "idx": 62794, "Desc": ""}{"node_name": "FileNameExtensionFilter(java.lang.String,java.lang.String...)", "type": "constructor", "idx": 62799, "Desc": "creates a filenameextensionfilter with the specified description and file name extensions . the returned filenameextensionfilter will accept all directories and any file with a file name extension contained in extensions ."}{"node_name": "FileSystemView()", "type": "constructor", "idx": 62808, "Desc": "constructs a filesystemview ."}{"node_name": "FileView()", "type": "constructor", "idx": 62862, "Desc": ""}{"node_name": "FocusManager()", "type": "constructor", "idx": 62875, "Desc": ""}{"node_name": "GrayFilter(boolean,int)", "type": "constructor", "idx": 62880, "Desc": "constructs a grayfilter object that filters a color image to a grayscale image . used by buttons to create disabled ( \" grayed out \") button images ."}{"node_name": "GroupLayout(java.awt.Container)", "type": "constructor", "idx": 62912, "Desc": "creates a grouplayout for the specified container ."}{"node_name": "AccessibleImageIcon()", "type": "constructor", "idx": 63059, "Desc": ""}{"node_name": "ImageIcon(java.lang.String,java.lang.String)", "type": "constructor", "idx": 63074, "Desc": "creates an imageicon from the specified file . the image will be preloaded by using mediatracker to monitor the loading state of the image ."}{"node_name": "ImageIcon(java.lang.String)", "type": "constructor", "idx": 63077, "Desc": "creates an imageicon from the specified file . the image will be preloaded by using mediatracker to monitor the loading state of the image . the specified string can be a file name or a file path . when specifying a path , use the internet-standard forward-slash ( \" / \") as a separator . ( the string is converted to an url , so the forward-slash works on all systems . ) for example , specify : new imageicon ( \" images / myimage.gif \") the description is initialized to the filename string ."}{"node_name": "ImageIcon(java.net.URL,java.lang.String)", "type": "constructor", "idx": 63079, "Desc": "creates an imageicon from the specified url . the image will be preloaded by using mediatracker to monitor the loaded state of the image ."}{"node_name": "ImageIcon(java.net.URL)", "type": "constructor", "idx": 63082, "Desc": "creates an imageicon from the specified url . the image will be preloaded by using mediatracker to monitor the loaded state of the image . the icon's description is initialized to be a string representation of the url ."}{"node_name": "ImageIcon(java.awt.Image,java.lang.String)", "type": "constructor", "idx": 63084, "Desc": "creates an imageicon from the image ."}{"node_name": "ImageIcon(java.awt.Image)", "type": "constructor", "idx": 63087, "Desc": "creates an imageicon from an image object . if the image has a \" comment \" property that is a string , then the string is used as the description of this icon ."}{"node_name": "ImageIcon(byte[],java.lang.String)", "type": "constructor", "idx": 63089, "Desc": "creates an imageicon from an array of bytes which were read from an image file containing a supported image format , such as gif , jpeg , or ( as of 1.3 ) png . normally this array is created by reading an image using class.getresourceasstream() , but the byte array may also be statically stored in a class ."}{"node_name": "ImageIcon(byte[])", "type": "constructor", "idx": 63092, "Desc": "creates an imageicon from an array of bytes which were read from an image file containing a supported image format , such as gif , jpeg , or ( as of 1.3 ) png . normally this array is created by reading an image using class.getresourceasstream() , but the byte array may also be statically stored in a class . if the resulting image has a \" comment \" property that is a string , then the string is used as the description of this icon ."}{"node_name": "ImageIcon()", "type": "constructor", "idx": 63094, "Desc": "creates an uninitialized image icon ."}{"node_name": "InputMap()", "type": "constructor", "idx": 63117, "Desc": "creates an inputmap with no parent and no mappings ."}{"node_name": "InputVerifier()", "type": "constructor", "idx": 63133, "Desc": ""}{"node_name": "InternalFrameFocusTraversalPolicy()", "type": "constructor", "idx": 63142, "Desc": ""}{"node_name": "AccessibleJApplet()", "type": "constructor", "idx": 63146, "Desc": ""}{"node_name": "AccessibleJButton()", "type": "constructor", "idx": 63149, "Desc": ""}{"node_name": "JButton()", "type": "constructor", "idx": 63152, "Desc": "creates a button with no set text or icon ."}{"node_name": "JButton(javax.swing.Icon)", "type": "constructor", "idx": 63153, "Desc": "creates a button with an icon ."}{"node_name": "JButton(java.lang.String)", "type": "constructor", "idx": 63155, "Desc": "creates a button with text ."}{"node_name": "JButton(javax.swing.Action)", "type": "constructor", "idx": 63157, "Desc": "creates a button where properties are taken from the action supplied ."}{"node_name": "JButton(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 63159, "Desc": "creates a button with initial text and an icon ."}{"node_name": "AccessibleJCheckBox()", "type": "constructor", "idx": 63172, "Desc": ""}{"node_name": "JCheckBox()", "type": "constructor", "idx": 63176, "Desc": "creates an initially unselected check box button with no text , no icon ."}{"node_name": "JCheckBox(javax.swing.Icon)", "type": "constructor", "idx": 63177, "Desc": "creates an initially unselected check box with an icon ."}{"node_name": "JCheckBox(javax.swing.Icon,boolean)", "type": "constructor", "idx": 63179, "Desc": "creates a check box with an icon and specifies whether or not it is initially selected ."}{"node_name": "JCheckBox(java.lang.String)", "type": "constructor", "idx": 63182, "Desc": "creates an initially unselected check box with text ."}{"node_name": "JCheckBox(javax.swing.Action)", "type": "constructor", "idx": 63184, "Desc": "creates a check box where properties are taken from the action supplied ."}{"node_name": "JCheckBox(java.lang.String,boolean)", "type": "constructor", "idx": 63186, "Desc": "creates a check box with text and specifies whether or not it is initially selected ."}{"node_name": "JCheckBox(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 63189, "Desc": "creates an initially unselected check box with the specified text and icon ."}{"node_name": "JCheckBox(java.lang.String,javax.swing.Icon,boolean)", "type": "constructor", "idx": 63192, "Desc": "creates a check box with text and icon , and specifies whether or not it is initially selected ."}{"node_name": "AccessibleJCheckBoxMenuItem()", "type": "constructor", "idx": 63204, "Desc": ""}{"node_name": "JCheckBoxMenuItem()", "type": "constructor", "idx": 63207, "Desc": "creates an initially unselected check box menu item with no set text or icon ."}{"node_name": "JCheckBoxMenuItem(javax.swing.Icon)", "type": "constructor", "idx": 63208, "Desc": "creates an initially unselected check box menu item with an icon ."}{"node_name": "JCheckBoxMenuItem(java.lang.String)", "type": "constructor", "idx": 63210, "Desc": "creates an initially unselected check box menu item with text ."}{"node_name": "JCheckBoxMenuItem(javax.swing.Action)", "type": "constructor", "idx": 63212, "Desc": "creates a menu item whose properties are taken from the action supplied ."}{"node_name": "JCheckBoxMenuItem(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 63214, "Desc": "creates an initially unselected check box menu item with the specified text and icon ."}{"node_name": "JCheckBoxMenuItem(java.lang.String,boolean)", "type": "constructor", "idx": 63217, "Desc": "creates a check box menu item with the specified text and selection state ."}{"node_name": "JCheckBoxMenuItem(java.lang.String,javax.swing.Icon,boolean)", "type": "constructor", "idx": 63220, "Desc": "creates a check box menu item with the specified text , icon , and selection state ."}{"node_name": "AccessibleJColorChooser()", "type": "constructor", "idx": 63232, "Desc": ""}{"node_name": "JColorChooser()", "type": "constructor", "idx": 63239, "Desc": "creates a color chooser pane with an initial color of white ."}{"node_name": "JColorChooser(java.awt.Color)", "type": "constructor", "idx": 63240, "Desc": "creates a color chooser pane with the specified initial color ."}{"node_name": "JColorChooser(javax.swing.colorchooser.ColorSelectionModel)", "type": "constructor", "idx": 63242, "Desc": "creates a color chooser pane with the specified colorselectionmodel ."}{"node_name": "AccessibleJComboBox()", "type": "constructor", "idx": 63293, "Desc": "returns an accessiblejcombobox instance"}{"node_name": "JComboBox(javax.swing.ComboBoxModel)", "type": "constructor", "idx": 63327, "Desc": "creates a jcombobox that takes its items from an existing comboboxmodel . since the comboboxmodel is provided , a combo box created using <init>(javax.swing.ComboBoxModel) does not create a default combo box model and may impact how the insert , remove and add methods behave ."}{"node_name": "JComboBox(java.lang.Object[])", "type": "constructor", "idx": 63329, "Desc": "creates a jcombobox that contains the elements in the specified array . by default the first item in the array ( and therefore the data model ) becomes selected ."}{"node_name": "JComboBox(java.util.Vector)", "type": "constructor", "idx": 63331, "Desc": "creates a jcombobox that contains the elements in the specified vector . by default the first item in the vector ( and therefore the data model ) becomes selected ."}{"node_name": "JComboBox()", "type": "constructor", "idx": 63333, "Desc": "creates a jcombobox with a default data model . the default data model is an empty list of objects . use additem to add items . by default the first item in the data model becomes selected ."}{"node_name": "AccessibleContainerHandler()", "type": "constructor", "idx": 63449, "Desc": ""}{"node_name": "AccessibleJComponent()", "type": "constructor", "idx": 63452, "Desc": "though the class is abstract , this should be called by all sub-classes ."}{"node_name": "JComponent()", "type": "constructor", "idx": 63477, "Desc": "default jcomponent constructor . <init>() does very little initialization beyond calling the container constructor . for example , the initial layout manager is null . it does , however , set the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "AccessibleJDesktopPane()", "type": "constructor", "idx": 63707, "Desc": ""}{"node_name": "JDesktopPane()", "type": "constructor", "idx": 63712, "Desc": "creates a new jdesktoppane ."}{"node_name": "AccessibleJDialog()", "type": "constructor", "idx": 63745, "Desc": ""}{"node_name": "JDialog()", "type": "constructor", "idx": 63752, "Desc": "creates a modeless dialog without a title and without a specified frame owner . a shared , hidden frame will be set as the owner of the dialog . <init>() sets the component's locale property to the value returned by jcomponent.getdefaultlocale . note : <init>() does not allow you to create an unowned jdialog . to create an unowned jdialog you must use either the jdialog ( window ) or jdialog ( dialog ) constructor with an argument of null ."}{"node_name": "JDialog(java.awt.Frame)", "type": "constructor", "idx": 63753, "Desc": "creates a modeless dialog with the specified frame as its owner and an empty title . if owner is null , a shared , hidden frame will be set as the owner of the dialog . <init>(java.awt.Frame) sets the component's locale property to the value returned by jcomponent.getdefaultlocale . note : <init>(java.awt.Frame) does not allow you to create an unowned jdialog . to create an unowned jdialog you must use either the jdialog ( window ) or jdialog ( dialog ) constructor with an argument of null ."}{"node_name": "JDialog(java.awt.Frame,boolean)", "type": "constructor", "idx": 63755, "Desc": "creates a dialog with an empty title and the specified modality and frame as its owner . if owner is null , a shared , hidden frame will be set as the owner of the dialog . <init>(java.awt.Frame,boolean) sets the component's locale property to the value returned by jcomponent.getdefaultlocale . note : <init>(java.awt.Frame,boolean) does not allow you to create an unowned jdialog . to create an unowned jdialog you must use either the jdialog ( window ) or jdialog ( dialog ) constructor with an argument of null ."}{"node_name": "JDialog(java.awt.Frame,java.lang.String)", "type": "constructor", "idx": 63758, "Desc": "creates a modeless dialog with the specified title and with the specified owner frame . if owner is null , a shared , hidden frame will be set as the owner of the dialog . <init>(java.awt.Frame,java.lang.String) sets the component's locale property to the value returned by jcomponent.getdefaultlocale . note : <init>(java.awt.Frame,java.lang.String) does not allow you to create an unowned jdialog . to create an unowned jdialog you must use either the jdialog ( window ) or jdialog ( dialog ) constructor with an argument of null ."}{"node_name": "JDialog(java.awt.Frame,java.lang.String,boolean)", "type": "constructor", "idx": 63761, "Desc": "creates a dialog with the specified title , owner frame and modality . if owner is null , a shared , hidden frame will be set as the owner of this dialog . <init>(java.awt.Frame,java.lang.String,boolean) sets the component's locale property to the value returned by jcomponent.getdefaultlocale . note : any popup components ( jcombobox , jpopupmenu , jmenubar ) created within a modal dialog will be forced to be lightweight . note : <init>(java.awt.Frame,java.lang.String,boolean) does not allow you to create an unowned jdialog . to create an unowned jdialog you must use either the jdialog ( window ) or jdialog ( dialog ) constructor with an argument of null ."}{"node_name": "JDialog(java.awt.Frame,java.lang.String,boolean,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 63765, "Desc": "creates a dialog with the specified title , owner frame , modality and graphicsconfiguration . if owner is null , a shared , hidden frame will be set as the owner of this dialog . <init>(java.awt.Frame,java.lang.String,boolean,java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale . note : any popup components ( jcombobox , jpopupmenu , jmenubar ) created within a modal dialog will be forced to be lightweight . note : <init>(java.awt.Frame,java.lang.String,boolean,java.awt.GraphicsConfiguration) does not allow you to create an unowned jdialog . to create an unowned jdialog you must use either the jdialog ( window ) or jdialog ( dialog ) constructor with an argument of null ."}{"node_name": "JDialog(java.awt.Dialog)", "type": "constructor", "idx": 63770, "Desc": "creates a modeless dialog with the specified dialog as its owner and an empty title . <init>(java.awt.Dialog) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Dialog,boolean)", "type": "constructor", "idx": 63772, "Desc": "creates a dialog with an empty title and the specified modality and dialog as its owner . <init>(java.awt.Dialog,boolean) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Dialog,java.lang.String)", "type": "constructor", "idx": 63775, "Desc": "creates a modeless dialog with the specified title and with the specified owner dialog . <init>(java.awt.Dialog,java.lang.String) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Dialog,java.lang.String,boolean)", "type": "constructor", "idx": 63778, "Desc": "creates a dialog with the specified title , modality and the specified owner dialog . <init>(java.awt.Dialog,java.lang.String,boolean) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Dialog,java.lang.String,boolean,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 63782, "Desc": "creates a dialog with the specified title , owner dialog , modality and graphicsconfiguration . note : any popup components ( jcombobox , jpopupmenu , jmenubar ) created within a modal dialog will be forced to be lightweight . <init>(java.awt.Dialog,java.lang.String,boolean,java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Window)", "type": "constructor", "idx": 63787, "Desc": "creates a modeless dialog with the specified window as its owner and an empty title . <init>(java.awt.Window) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Window,java.awt.Dialog.ModalityType)", "type": "constructor", "idx": 63789, "Desc": "creates a dialog with an empty title and the specified modality and window as its owner . <init>(java.awt.Window,java.awt.Dialog.ModalityType) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Window,java.lang.String)", "type": "constructor", "idx": 63792, "Desc": "creates a modeless dialog with the specified title and owner window . <init>(java.awt.Window,java.lang.String) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Window,java.lang.String,java.awt.Dialog.ModalityType)", "type": "constructor", "idx": 63795, "Desc": "creates a dialog with the specified title , owner window and modality . <init>(java.awt.Window,java.lang.String,java.awt.Dialog.ModalityType) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JDialog(java.awt.Window,java.lang.String,java.awt.Dialog.ModalityType,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 63799, "Desc": "creates a dialog with the specified title , owner window , modality and graphicsconfiguration . note : any popup components ( jcombobox , jpopupmenu , jmenubar ) created within a modal dialog will be forced to be lightweight . <init>(java.awt.Window,java.lang.String,java.awt.Dialog.ModalityType,java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "AccessibleJEditorPane()", "type": "constructor", "idx": 63855, "Desc": ""}{"node_name": "AccessibleJEditorPaneHTML()", "type": "constructor", "idx": 63859, "Desc": "constructs an accessiblejeditorpanehtml ."}{"node_name": "HTMLLink(javax.swing.text.Element)", "type": "constructor", "idx": 63867, "Desc": "constructs a htmllink ."}{"node_name": "JEditorPaneAccessibleHypertextSupport()", "type": "constructor", "idx": 63882, "Desc": "make one of these puppies"}{"node_name": "JEditorPane()", "type": "constructor", "idx": 63893, "Desc": "creates a new jeditorpane . the document model is set to null ."}{"node_name": "JEditorPane(java.net.URL)", "type": "constructor", "idx": 63894, "Desc": "creates a jeditorpane based on a specified url for input ."}{"node_name": "JEditorPane(java.lang.String)", "type": "constructor", "idx": 63896, "Desc": "creates a jeditorpane based on a string containing a url specification ."}{"node_name": "JEditorPane(java.lang.String,java.lang.String)", "type": "constructor", "idx": 63898, "Desc": "creates a jeditorpane that has been initialized to the given text . this is a convenience constructor that calls the setcontenttype and settext methods ."}{"node_name": "AccessibleJFileChooser()", "type": "constructor", "idx": 63955, "Desc": ""}{"node_name": "JFileChooser()", "type": "constructor", "idx": 63988, "Desc": "constructs a jfilechooser pointing to the user's default directory . this default depends on the operating system . it is typically the \" my documents \" folder on windows , and the user's home directory on unix ."}{"node_name": "JFileChooser(java.lang.String)", "type": "constructor", "idx": 63989, "Desc": "constructs a jfilechooser using the given path . passing in a null string causes the file chooser to point to the user's default directory . this default depends on the operating system . it is typically the \" my documents \" folder on windows , and the user's home directory on unix ."}{"node_name": "JFileChooser(java.io.File)", "type": "constructor", "idx": 63991, "Desc": "constructs a jfilechooser using the given file as the path . passing in a null file causes the file chooser to point to the user's default directory . this default depends on the operating system . it is typically the \" my documents \" folder on windows , and the user's home directory on unix ."}{"node_name": "JFileChooser(javax.swing.filechooser.FileSystemView)", "type": "constructor", "idx": 63993, "Desc": "constructs a jfilechooser using the given filesystemview ."}{"node_name": "JFileChooser(java.io.File,javax.swing.filechooser.FileSystemView)", "type": "constructor", "idx": 63995, "Desc": "constructs a jfilechooser using the given current directory and filesystemview ."}{"node_name": "JFileChooser(java.lang.String,javax.swing.filechooser.FileSystemView)", "type": "constructor", "idx": 63998, "Desc": "constructs a jfilechooser using the given current directory path and filesystemview ."}{"node_name": "AbstractFormatter()", "type": "constructor", "idx": 64108, "Desc": ""}{"node_name": "AbstractFormatterFactory()", "type": "constructor", "idx": 64125, "Desc": ""}{"node_name": "JFormattedTextField()", "type": "constructor", "idx": 64133, "Desc": "creates a jformattedtextfield with no abstractformatterfactory . use setmask or setformatterfactory to configure the jformattedtextfield to edit a particular type of value ."}{"node_name": "JFormattedTextField(java.lang.Object)", "type": "constructor", "idx": 64134, "Desc": "creates a jformattedtextfield with the specified value . this will create an abstractformatterfactory based on the type of value ."}{"node_name": "JFormattedTextField(java.text.Format)", "type": "constructor", "idx": 64136, "Desc": "creates a jformattedtextfield . format is wrapped in an appropriate abstractformatter which is then wrapped in an abstractformatterfactory ."}{"node_name": "JFormattedTextField(javax.swing.JFormattedTextField.AbstractFormatter)", "type": "constructor", "idx": 64138, "Desc": "creates a jformattedtextfield with the specified abstractformatter . the abstractformatter is placed in an abstractformatterfactory ."}{"node_name": "JFormattedTextField(javax.swing.JFormattedTextField.AbstractFormatterFactory)", "type": "constructor", "idx": 64140, "Desc": "creates a jformattedtextfield with the specified abstractformatterfactory ."}{"node_name": "JFormattedTextField(javax.swing.JFormattedTextField.AbstractFormatterFactory,java.lang.Object)", "type": "constructor", "idx": 64142, "Desc": "creates a jformattedtextfield with the specified abstractformatterfactory and initial value ."}{"node_name": "AccessibleJFrame()", "type": "constructor", "idx": 64169, "Desc": ""}{"node_name": "JFrame()", "type": "constructor", "idx": 64176, "Desc": "constructs a new frame that is initially invisible . <init>() sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JFrame(java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 64177, "Desc": "creates a frame in the specified graphicsconfiguration of a screen device and a blank title . <init>(java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JFrame(java.lang.String)", "type": "constructor", "idx": 64179, "Desc": "creates a new , initially invisible frame with the specified title . <init>(java.lang.String) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JFrame(java.lang.String,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 64181, "Desc": "creates a jframe with the specified title and the specified graphicsconfiguration of a screen device . <init>(java.lang.String,java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "AccessibleJInternalFrame()", "type": "constructor", "idx": 64235, "Desc": ""}{"node_name": "AccessibleJDesktopIcon()", "type": "constructor", "idx": 64245, "Desc": ""}{"node_name": "JDesktopIcon(javax.swing.JInternalFrame)", "type": "constructor", "idx": 64254, "Desc": "creates an icon for an internal frame ."}{"node_name": "JInternalFrame()", "type": "constructor", "idx": 64291, "Desc": "creates a non-resizable , non-closable , non-maximizable , non-iconifiable jinternalframe with no title ."}{"node_name": "JInternalFrame(java.lang.String)", "type": "constructor", "idx": 64292, "Desc": "creates a non-resizable , non-closable , non-maximizable , non-iconifiable jinternalframe with the specified title . note that passing in a null title results in unspecified behavior and possibly an exception ."}{"node_name": "JInternalFrame(java.lang.String,boolean)", "type": "constructor", "idx": 64294, "Desc": "creates a non-closable , non-maximizable , non-iconifiable jinternalframe with the specified title and resizability ."}{"node_name": "JInternalFrame(java.lang.String,boolean,boolean)", "type": "constructor", "idx": 64297, "Desc": "creates a non-maximizable , non-iconifiable jinternalframe with the specified title , resizability , and closability ."}{"node_name": "JInternalFrame(java.lang.String,boolean,boolean,boolean)", "type": "constructor", "idx": 64301, "Desc": "creates a non-iconifiable jinternalframe with the specified title , resizability , closability , and maximizability ."}{"node_name": "JInternalFrame(java.lang.String,boolean,boolean,boolean,boolean)", "type": "constructor", "idx": 64306, "Desc": "creates a jinternalframe with the specified title , resizability , closability , maximizability , and iconifiability . all jinternalframe constructors use this one ."}{"node_name": "AccessibleJLabel()", "type": "constructor", "idx": 64424, "Desc": ""}{"node_name": "JLabel(java.lang.String,javax.swing.Icon,int)", "type": "constructor", "idx": 64454, "Desc": "creates a jlabel instance with the specified text , image , and horizontal alignment . the label is centered vertically in its display area . the text is on the trailing edge of the image ."}{"node_name": "JLabel(java.lang.String,int)", "type": "constructor", "idx": 64458, "Desc": "creates a jlabel instance with the specified text and horizontal alignment . the label is centered vertically in its display area ."}{"node_name": "JLabel(java.lang.String)", "type": "constructor", "idx": 64461, "Desc": "creates a jlabel instance with the specified text . the label is aligned against the leading edge of its display area , and centered vertically ."}{"node_name": "JLabel(javax.swing.Icon,int)", "type": "constructor", "idx": 64463, "Desc": "creates a jlabel instance with the specified image and horizontal alignment . the label is centered vertically in its display area ."}{"node_name": "JLabel(javax.swing.Icon)", "type": "constructor", "idx": 64466, "Desc": "creates a jlabel instance with the specified image . the label is centered vertically and horizontally in its display area ."}{"node_name": "JLabel()", "type": "constructor", "idx": 64468, "Desc": "creates a jlabel instance with no image and with an empty string for the title . the label is centered vertically in its display area . the label's contents , once set , will be displayed on the leading edge of the label's display area ."}{"node_name": "JLayer()", "type": "constructor", "idx": 64525, "Desc": "creates a new jlayer object with a null view component and default layerui ."}{"node_name": "JLayer(java.awt.Component)", "type": "constructor", "idx": 64526, "Desc": "creates a new jlayer object with default layerui ."}{"node_name": "JLayer(java.awt.Component,javax.swing.plaf.LayerUI)", "type": "constructor", "idx": 64528, "Desc": "creates a new jlayer object with the specified view component and layerui object ."}{"node_name": "AccessibleJLayeredPane()", "type": "constructor", "idx": 64586, "Desc": ""}{"node_name": "JLayeredPane()", "type": "constructor", "idx": 64596, "Desc": "create a new jlayeredpane"}{"node_name": "AccessibleJListChild(javax.swing.JList,int)", "type": "constructor", "idx": 64645, "Desc": "constructs an accessiblejlistchild ."}{"node_name": "AccessibleJList()", "type": "constructor", "idx": 64658, "Desc": "constructs an accessiblejlist ."}{"node_name": "JList(javax.swing.ListModel)", "type": "constructor", "idx": 64696, "Desc": "constructs a jlist that displays elements from the specified , non-null , model . all jlist constructors delegate to this one . <init>(javax.swing.ListModel) registers the list with the tooltipmanager , allowing for tooltips to be provided by the cell renderers ."}{"node_name": "JList(java.lang.Object[])", "type": "constructor", "idx": 64698, "Desc": "constructs a jlist that displays the elements in the specified array . <init>(java.lang.Object[]) creates a read-only model for the given array , and then delegates to <init>(java.lang.Object[]) that takes a listmodel . attempts to pass a null value to this method results in undefined behavior and , most likely , exceptions . the created model references the given array directly . attempts to modify the array after constructing the list results in undefined behavior ."}{"node_name": "JList(java.util.Vector)", "type": "constructor", "idx": 64700, "Desc": "constructs a jlist that displays the elements in the specified vector . <init>(java.util.Vector) creates a read-only model for the given vector , and then delegates to <init>(java.util.Vector) that takes a listmodel . attempts to pass a null value to this method results in undefined behavior and , most likely , exceptions . the created model references the given vector directly . attempts to modify the vector after constructing the list results in undefined behavior ."}{"node_name": "JList()", "type": "constructor", "idx": 64702, "Desc": "constructs a jlist with an empty , read-only , model ."}{"node_name": "AccessibleJMenu()", "type": "constructor", "idx": 64824, "Desc": ""}{"node_name": "JMenu()", "type": "constructor", "idx": 64843, "Desc": "constructs a new jmenu with no text ."}{"node_name": "JMenu(java.lang.String)", "type": "constructor", "idx": 64844, "Desc": "constructs a new jmenu with the supplied string as its text ."}{"node_name": "JMenu(javax.swing.Action)", "type": "constructor", "idx": 64846, "Desc": "constructs a menu whose properties are taken from the action supplied ."}{"node_name": "JMenu(java.lang.String,boolean)", "type": "constructor", "idx": 64848, "Desc": "constructs a new jmenu with the supplied string as its text and specified as a tear-off menu or not ."}{"node_name": "WinListener(javax.swing.JPopupMenu)", "type": "constructor", "idx": 64939, "Desc": "create the window listener for the specified popup ."}{"node_name": "AccessibleJMenuBar()", "type": "constructor", "idx": 64944, "Desc": ""}{"node_name": "JMenuBar()", "type": "constructor", "idx": 64960, "Desc": "creates a new menu bar ."}{"node_name": "JMenuItem()", "type": "constructor", "idx": 65016, "Desc": "creates a jmenuitem with no set text or icon ."}{"node_name": "JMenuItem(javax.swing.Icon)", "type": "constructor", "idx": 65017, "Desc": "creates a jmenuitem with the specified icon ."}{"node_name": "JMenuItem(java.lang.String)", "type": "constructor", "idx": 65019, "Desc": "creates a jmenuitem with the specified text ."}{"node_name": "JMenuItem(javax.swing.Action)", "type": "constructor", "idx": 65021, "Desc": "creates a menu item whose properties are taken from the specified action ."}{"node_name": "JMenuItem(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 65023, "Desc": "creates a jmenuitem with the specified text and icon ."}{"node_name": "JMenuItem(java.lang.String,int)", "type": "constructor", "idx": 65026, "Desc": "creates a jmenuitem with the specified text and keyboard mnemonic ."}{"node_name": "AccessibleJOptionPane()", "type": "constructor", "idx": 65092, "Desc": ""}{"node_name": "JOptionPane()", "type": "constructor", "idx": 65132, "Desc": "creates a joptionpane with a test message ."}{"node_name": "JOptionPane(java.lang.Object)", "type": "constructor", "idx": 65133, "Desc": "creates a instance of joptionpane to display a message using the plain-message message type and the default options delivered by the ui ."}{"node_name": "JOptionPane(java.lang.Object,int)", "type": "constructor", "idx": 65135, "Desc": "creates an instance of joptionpane to display a message with the specified message type and the default options ,"}{"node_name": "JOptionPane(java.lang.Object,int,int)", "type": "constructor", "idx": 65138, "Desc": "creates an instance of joptionpane to display a message with the specified message type and options ."}{"node_name": "JOptionPane(java.lang.Object,int,int,javax.swing.Icon)", "type": "constructor", "idx": 65142, "Desc": "creates an instance of joptionpane to display a message with the specified message type , options , and icon ."}{"node_name": "JOptionPane(java.lang.Object,int,int,javax.swing.Icon,java.lang.Object[])", "type": "constructor", "idx": 65147, "Desc": "creates an instance of joptionpane to display a message with the specified message type , icon , and options . none of the options is initially selected . the options objects should contain either instances of components , ( which are added directly ) or strings ( which are wrapped in a jbutton ) . if you provide components , you must ensure that when the component is clicked it messages setvalue in the created joptionpane ."}{"node_name": "JOptionPane(java.lang.Object,int,int,javax.swing.Icon,java.lang.Object[],java.lang.Object)", "type": "constructor", "idx": 65153, "Desc": "creates an instance of joptionpane to display a message with the specified message type , icon , and options , with the initially-selected option specified ."}{"node_name": "AccessibleJPanel()", "type": "constructor", "idx": 65347, "Desc": ""}{"node_name": "JPanel(java.awt.LayoutManager,boolean)", "type": "constructor", "idx": 65350, "Desc": "creates a new jpanel with the specified layout manager and buffering strategy ."}{"node_name": "JPanel(java.awt.LayoutManager)", "type": "constructor", "idx": 65353, "Desc": "create a new buffered jpanel with the specified layout manager"}{"node_name": "JPanel(boolean)", "type": "constructor", "idx": 65355, "Desc": "creates a new jpanel with flowlayout and the specified buffering strategy . if isdoublebuffered is true , the jpanel will use a double buffer ."}{"node_name": "JPanel()", "type": "constructor", "idx": 65357, "Desc": "creates a new jpanel with a double buffer and a flow layout ."}{"node_name": "AccessibleJPasswordField()", "type": "constructor", "idx": 65366, "Desc": ""}{"node_name": "JPasswordField()", "type": "constructor", "idx": 65391, "Desc": "constructs a new jpasswordfield , with a default document , null starting text string , and 0 column width ."}{"node_name": "JPasswordField(java.lang.String)", "type": "constructor", "idx": 65392, "Desc": "constructs a new jpasswordfield initialized with the specified text . the document model is set to the default , and the number of columns to 0 ."}{"node_name": "JPasswordField(int)", "type": "constructor", "idx": 65394, "Desc": "constructs a new empty jpasswordfield with the specified number of columns . a default model is created , and the initial string is set to null ."}{"node_name": "JPasswordField(java.lang.String,int)", "type": "constructor", "idx": 65396, "Desc": "constructs a new jpasswordfield initialized with the specified text and columns . the document model is set to the default ."}{"node_name": "JPasswordField(javax.swing.text.Document,java.lang.String,int)", "type": "constructor", "idx": 65399, "Desc": "constructs a new jpasswordfield that uses the given text storage model and the given number of columns . this is <init>(javax.swing.text.Document,java.lang.String,int) through which the other constructors feed . the echo character is set to ' * ' , but may be changed by the current look and feel . if the document model is null , a default one will be created ."}{"node_name": "AccessibleJPopupMenu()", "type": "constructor", "idx": 65415, "Desc": "accessiblejpopupmenu constructor"}{"node_name": "JPopupMenu()", "type": "constructor", "idx": 65420, "Desc": "constructs a jpopupmenu without an \" invoker \" ."}{"node_name": "JPopupMenu(java.lang.String)", "type": "constructor", "idx": 65421, "Desc": "constructs a jpopupmenu with the specified title ."}{"node_name": "Separator()", "type": "constructor", "idx": 65520, "Desc": "constructs a popup menu-specific separator ."}{"node_name": "AccessibleJProgressBar()", "type": "constructor", "idx": 65523, "Desc": ""}{"node_name": "JProgressBar()", "type": "constructor", "idx": 65540, "Desc": "creates a horizontal progress bar that displays a border but no progress string . the initial and minimum values are 0 , and the maximum is 100 ."}{"node_name": "JProgressBar(int)", "type": "constructor", "idx": 65541, "Desc": "creates a progress bar with the specified orientation , which can be either swingconstants.vertical or swingconstants.horizontal . by default , a border is painted but a progress string is not . the initial and minimum values are 0 , and the maximum is 100 ."}{"node_name": "JProgressBar(int,int)", "type": "constructor", "idx": 65543, "Desc": "creates a horizontal progress bar with the specified minimum and maximum . sets the initial value of the progress bar to the specified minimum . by default , a border is painted but a progress string is not . the boundedrangemodel that holds the progress bar's data handles any issues that may arise from improperly setting the minimum , initial , and maximum values on the progress bar . see the boundedrangemodel documentation for details ."}{"node_name": "JProgressBar(int,int,int)", "type": "constructor", "idx": 65546, "Desc": "creates a progress bar using the specified orientation , minimum , and maximum . by default , a border is painted but a progress string is not . sets the initial value of the progress bar to the specified minimum . the boundedrangemodel that holds the progress bar's data handles any issues that may arise from improperly setting the minimum , initial , and maximum values on the progress bar . see the boundedrangemodel documentation for details ."}{"node_name": "JProgressBar(javax.swing.BoundedRangeModel)", "type": "constructor", "idx": 65550, "Desc": "creates a horizontal progress bar that uses the specified model to hold the progress bar's data . by default , a border is painted but a progress string is not ."}{"node_name": "AccessibleJRadioButton()", "type": "constructor", "idx": 65597, "Desc": ""}{"node_name": "JRadioButton()", "type": "constructor", "idx": 65600, "Desc": "creates an initially unselected radio button with no set text ."}{"node_name": "JRadioButton(javax.swing.Icon)", "type": "constructor", "idx": 65601, "Desc": "creates an initially unselected radio button with the specified image but no text ."}{"node_name": "JRadioButton(javax.swing.Action)", "type": "constructor", "idx": 65603, "Desc": "creates a radiobutton where properties are taken from the action supplied ."}{"node_name": "JRadioButton(javax.swing.Icon,boolean)", "type": "constructor", "idx": 65605, "Desc": "creates a radio button with the specified image and selection state , but no text ."}{"node_name": "JRadioButton(java.lang.String)", "type": "constructor", "idx": 65608, "Desc": "creates an unselected radio button with the specified text ."}{"node_name": "JRadioButton(java.lang.String,boolean)", "type": "constructor", "idx": 65610, "Desc": "creates a radio button with the specified text and selection state ."}{"node_name": "JRadioButton(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 65613, "Desc": "creates a radio button that has the specified text and image , and that is initially unselected ."}{"node_name": "JRadioButton(java.lang.String,javax.swing.Icon,boolean)", "type": "constructor", "idx": 65616, "Desc": "creates a radio button that has the specified text , image , and selection state ."}{"node_name": "AccessibleJRadioButtonMenuItem()", "type": "constructor", "idx": 65625, "Desc": ""}{"node_name": "JRadioButtonMenuItem()", "type": "constructor", "idx": 65628, "Desc": "creates a jradiobuttonmenuitem with no set text or icon ."}{"node_name": "JRadioButtonMenuItem(javax.swing.Icon)", "type": "constructor", "idx": 65629, "Desc": "creates a jradiobuttonmenuitem with an icon ."}{"node_name": "JRadioButtonMenuItem(java.lang.String)", "type": "constructor", "idx": 65631, "Desc": "creates a jradiobuttonmenuitem with text ."}{"node_name": "JRadioButtonMenuItem(javax.swing.Action)", "type": "constructor", "idx": 65633, "Desc": "creates a radio button menu item whose properties are taken from the action supplied ."}{"node_name": "JRadioButtonMenuItem(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 65635, "Desc": "creates a radio button menu item with the specified text and icon ."}{"node_name": "JRadioButtonMenuItem(java.lang.String,boolean)", "type": "constructor", "idx": 65638, "Desc": "creates a radio button menu item with the specified text and selection state ."}{"node_name": "JRadioButtonMenuItem(javax.swing.Icon,boolean)", "type": "constructor", "idx": 65641, "Desc": "creates a radio button menu item with the specified image and selection state , but no text ."}{"node_name": "JRadioButtonMenuItem(java.lang.String,javax.swing.Icon,boolean)", "type": "constructor", "idx": 65644, "Desc": "creates a radio button menu item that has the specified text , image , and selection state . all other constructors defer to this one ."}{"node_name": "AccessibleJRootPane()", "type": "constructor", "idx": 65652, "Desc": ""}{"node_name": "JRootPane()", "type": "constructor", "idx": 65672, "Desc": "creates a jrootpane , setting up its glasspane , layeredpane , and contentpane ."}{"node_name": "RootLayout()", "type": "constructor", "idx": 65711, "Desc": ""}{"node_name": "AccessibleJScrollBar()", "type": "constructor", "idx": 65721, "Desc": ""}{"node_name": "JScrollBar(int,int,int,int,int)", "type": "constructor", "idx": 65735, "Desc": "creates a scrollbar with the specified orientation , value , extent , minimum , and maximum . the \" extent \" is the size of the viewable area . it is also known as the \" visible amount \" . note : use setblockincrement to set the block increment to a size slightly smaller than the view's extent . that way , when the user jumps the knob to an adjacent position , one or two lines of the original contents remain in view ."}{"node_name": "JScrollBar(int)", "type": "constructor", "idx": 65741, "Desc": "creates a scrollbar with the specified orientation and the following initial values : minimum = 0 maximum = 100 value = 0 extent = 10"}{"node_name": "JScrollBar()", "type": "constructor", "idx": 65743, "Desc": "creates a vertical scrollbar with the following initial values : minimum = 0 maximum = 100 value = 0 extent = 10"}{"node_name": "AccessibleJScrollPane()", "type": "constructor", "idx": 65802, "Desc": "accessiblejscrollpane constructor"}{"node_name": "JScrollPane(java.awt.Component,int,int)", "type": "constructor", "idx": 65821, "Desc": "creates a jscrollpane that displays the view component in a viewport whose view position can be controlled with a pair of scrollbars . the scrollbar policies specify when the scrollbars are displayed , for example , if vsbpolicy is vertical_scrollbar_as_needed then the vertical scrollbar only appears if the view doesn't fit vertically . the available policy settings are listed at setverticalscrollbarpolicy ( int ) and sethorizontalscrollbarpolicy ( int ) ."}{"node_name": "JScrollPane(java.awt.Component)", "type": "constructor", "idx": 65825, "Desc": "creates a jscrollpane that displays the contents of the specified component , where both horizontal and vertical scrollbars appear whenever the component's contents are larger than the view ."}{"node_name": "JScrollPane(int,int)", "type": "constructor", "idx": 65827, "Desc": "creates an empty ( no viewport view ) jscrollpane with specified scrollbar policies . the available policy settings are listed at setverticalscrollbarpolicy ( int ) and sethorizontalscrollbarpolicy ( int ) ."}{"node_name": "JScrollPane()", "type": "constructor", "idx": 65830, "Desc": "creates an empty ( no viewport view ) jscrollpane where both horizontal and vertical scrollbars appear when needed ."}{"node_name": "ScrollBar(int)", "type": "constructor", "idx": 65886, "Desc": "creates a scrollbar with the specified orientation . the options are : scrollpaneconstants.vertical scrollpaneconstants.horizontal"}{"node_name": "AccessibleJSeparator()", "type": "constructor", "idx": 65897, "Desc": ""}{"node_name": "JSeparator()", "type": "constructor", "idx": 65900, "Desc": "creates a new horizontal separator ."}{"node_name": "JSeparator(int)", "type": "constructor", "idx": 65901, "Desc": "creates a new separator with the specified horizontal or vertical orientation ."}{"node_name": "AccessibleJSlider()", "type": "constructor", "idx": 65914, "Desc": ""}{"node_name": "JSlider()", "type": "constructor", "idx": 65931, "Desc": "creates a horizontal slider with the range 0 to 100 and an initial value of 50 ."}{"node_name": "JSlider(int)", "type": "constructor", "idx": 65932, "Desc": "creates a slider using the specified orientation with the range 0 to 100 and an initial value of 50 . the orientation can be either swingconstants.vertical or swingconstants.horizontal ."}{"node_name": "JSlider(int,int)", "type": "constructor", "idx": 65934, "Desc": "creates a horizontal slider using the specified min and max with an initial value equal to the average of the min plus max . the boundedrangemodel that holds the slider's data handles any issues that may arise from improperly setting the minimum and maximum values on the slider . see the boundedrangemodel documentation for details ."}{"node_name": "JSlider(int,int,int)", "type": "constructor", "idx": 65937, "Desc": "creates a horizontal slider using the specified min , max and value . the boundedrangemodel that holds the slider's data handles any issues that may arise from improperly setting the minimum , initial , and maximum values on the slider . see the boundedrangemodel documentation for details ."}{"node_name": "JSlider(int,int,int,int)", "type": "constructor", "idx": 65941, "Desc": "creates a slider with the specified orientation and the specified minimum , maximum , and initial values . the orientation can be either swingconstants.vertical or swingconstants.horizontal . the boundedrangemodel that holds the slider's data handles any issues that may arise from improperly setting the minimum , initial , and maximum values on the slider . see the boundedrangemodel documentation for details ."}{"node_name": "JSlider(javax.swing.BoundedRangeModel)", "type": "constructor", "idx": 65946, "Desc": "creates a horizontal slider using the specified boundedrangemodel ."}{"node_name": "AccessibleJSpinner()", "type": "constructor", "idx": 66023, "Desc": "accessiblejspinner constructor"}{"node_name": "DateEditor(javax.swing.JSpinner)", "type": "constructor", "idx": 66091, "Desc": "construct a jspinner editor that supports displaying and editing the value of a spinnerdatemodel with a jformattedtextfield . this dateeditor becomes both a changelistener on the spinner and a propertychangelistener on the new jformattedtextfield ."}{"node_name": "DateEditor(javax.swing.JSpinner,java.lang.String)", "type": "constructor", "idx": 66093, "Desc": "construct a jspinner editor that supports displaying and editing the value of a spinnerdatemodel with a jformattedtextfield . this dateeditor becomes both a changelistener on the spinner and a propertychangelistener on the new jformattedtextfield ."}{"node_name": "DefaultEditor(javax.swing.JSpinner)", "type": "constructor", "idx": 66099, "Desc": "constructs an editor component for the specified jspinner . this defaulteditor is it's own layout manager and it is added to the spinner's changelistener list . <init>(javax.swing.JSpinner) creates a single jformattedtextfield child , initializes it's value to be the spinner model's current value and adds it to this defaulteditor ."}{"node_name": "JSpinner(javax.swing.SpinnerModel)", "type": "constructor", "idx": 66126, "Desc": "constructs a spinner for the given model . the spinner has a set of previous / next buttons , and an editor appropriate for the model ."}{"node_name": "JSpinner()", "type": "constructor", "idx": 66128, "Desc": "constructs a spinner with an integer spinnernumbermodel with initial value 0 and no minimum or maximum limits ."}{"node_name": "ListEditor(javax.swing.JSpinner)", "type": "constructor", "idx": 66156, "Desc": "construct a jspinner editor that supports displaying and editing the value of a spinnerlistmodel with a jformattedtextfield . this listeditor becomes both a changelistener on the spinner and a propertychangelistener on the new jformattedtextfield ."}{"node_name": "NumberEditor(javax.swing.JSpinner)", "type": "constructor", "idx": 66160, "Desc": "construct a jspinner editor that supports displaying and editing the value of a spinnernumbermodel with a jformattedtextfield . this numbereditor becomes both a changelistener on the spinner and a propertychangelistener on the new jformattedtextfield ."}{"node_name": "NumberEditor(javax.swing.JSpinner,java.lang.String)", "type": "constructor", "idx": 66162, "Desc": "construct a jspinner editor that supports displaying and editing the value of a spinnernumbermodel with a jformattedtextfield . this numbereditor becomes both a changelistener on the spinner and a propertychangelistener on the new jformattedtextfield ."}{"node_name": "AccessibleJSplitPane()", "type": "constructor", "idx": 66168, "Desc": ""}{"node_name": "JSplitPane()", "type": "constructor", "idx": 66199, "Desc": "creates a new jsplitpane configured to arrange the child components side-by-side horizontally , using two buttons for the components ."}{"node_name": "JSplitPane(int)", "type": "constructor", "idx": 66200, "Desc": "creates a new jsplitpane configured with the specified orientation ."}{"node_name": "JSplitPane(int,boolean)", "type": "constructor", "idx": 66202, "Desc": "creates a new jsplitpane with the specified orientation and redrawing style ."}{"node_name": "JSplitPane(int,java.awt.Component,java.awt.Component)", "type": "constructor", "idx": 66205, "Desc": "creates a new jsplitpane with the specified orientation and the specified components ."}{"node_name": "JSplitPane(int,boolean,java.awt.Component,java.awt.Component)", "type": "constructor", "idx": 66209, "Desc": "creates a new jsplitpane with the specified orientation and redrawing style , and with the specified components ."}{"node_name": "AccessibleJTabbedPane()", "type": "constructor", "idx": 66272, "Desc": "constructs an accessiblejtabbedpane"}{"node_name": "JTabbedPane()", "type": "constructor", "idx": 66288, "Desc": "creates an empty tabbedpane with a default tab placement of jtabbedpane.top ."}{"node_name": "JTabbedPane(int)", "type": "constructor", "idx": 66289, "Desc": "creates an empty tabbedpane with the specified tab placement of either : jtabbedpane.top , jtabbedpane.bottom , jtabbedpane.left , or jtabbedpane.right ."}{"node_name": "JTabbedPane(int,int)", "type": "constructor", "idx": 66291, "Desc": "creates an empty tabbedpane with the specified tab placement and tab layout policy . tab placement may be either : jtabbedpane.top , jtabbedpane.bottom , jtabbedpane.left , or jtabbedpane.right . tab layout policy may be either : jtabbedpane.wrap_tab_layout or jtabbedpane.scroll_tab_layout ."}{"node_name": "ModelListener()", "type": "constructor", "idx": 66436, "Desc": ""}{"node_name": "AccessibleJTableCell(javax.swing.JTable,int,int,int)", "type": "constructor", "idx": 66438, "Desc": "constructs an accessiblejtableheaderentry ."}{"node_name": "AccessibleJTableModelChange(int,int,int,int,int)", "type": "constructor", "idx": 66502, "Desc": "constructs an accessiblejtablemodelchange ."}{"node_name": "AccessibleJTable()", "type": "constructor", "idx": 66514, "Desc": "accessiblejtable constructor"}{"node_name": "JTable()", "type": "constructor", "idx": 66643, "Desc": "constructs a default jtable that is initialized with a default data model , a default column model , and a default selection model ."}{"node_name": "JTable(javax.swing.table.TableModel)", "type": "constructor", "idx": 66644, "Desc": "constructs a jtable that is initialized with dm as the data model , a default column model , and a default selection model ."}{"node_name": "JTable(javax.swing.table.TableModel,javax.swing.table.TableColumnModel)", "type": "constructor", "idx": 66646, "Desc": "constructs a jtable that is initialized with dm as the data model , cm as the column model , and a default selection model ."}{"node_name": "JTable(javax.swing.table.TableModel,javax.swing.table.TableColumnModel,javax.swing.ListSelectionModel)", "type": "constructor", "idx": 66649, "Desc": "constructs a jtable that is initialized with dm as the data model , cm as the column model , and sm as the selection model . if any of the parameters are null this method will initialize the table with the corresponding default model . the autocreatecolumnsfrommodel flag is set to false if cm is non-null , otherwise it is set to true and the column model is populated with suitable tablecolumns for the columns in dm ."}{"node_name": "JTable(int,int)", "type": "constructor", "idx": 66653, "Desc": "constructs a jtable with numrows and numcolumns of empty cells using defaulttablemodel . the columns will have names of the form \" a \" , \" b \" , \" c \" , etc ."}{"node_name": "JTable(java.util.Vector,java.util.Vector)", "type": "constructor", "idx": 66656, "Desc": "constructs a jtable to display the values in the vector of vectors , rowdata , with column names , columnnames . the vectors contained in rowdata should contain the values for that row . in other words , the value of the cell at row 1 , column 5 can be obtained with the following code : (( vector ) rowdata.elementat ( 1 )) .elementat ( 5 );"}{"node_name": "JTable(java.lang.Object[][],java.lang.Object[])", "type": "constructor", "idx": 66659, "Desc": "constructs a jtable to display the values in the two dimensional array , rowdata , with column names , columnnames . rowdata is an array of rows , so the value of the cell at row 1 , column 5 can be obtained with the following code : rowdata [ 1 ] [ 5 ]; all rows must be of the same length as columnnames ."}{"node_name": "AccessibleJTextArea()", "type": "constructor", "idx": 66955, "Desc": ""}{"node_name": "JTextArea()", "type": "constructor", "idx": 66958, "Desc": "constructs a new textarea . a default model is set , the initial string is null , and rows / columns are set to 0 ."}{"node_name": "JTextArea(java.lang.String)", "type": "constructor", "idx": 66959, "Desc": "constructs a new textarea with the specified text displayed . a default model is created and rows / columns are set to 0 ."}{"node_name": "JTextArea(int,int)", "type": "constructor", "idx": 66961, "Desc": "constructs a new empty textarea with the specified number of rows and columns . a default model is created , and the initial string is null ."}{"node_name": "JTextArea(java.lang.String,int,int)", "type": "constructor", "idx": 66964, "Desc": "constructs a new textarea with the specified text and number of rows and columns . a default model is created ."}{"node_name": "JTextArea(javax.swing.text.Document)", "type": "constructor", "idx": 66968, "Desc": "constructs a new jtextarea with the given document model , and defaults for all of the other arguments ( null , 0 , 0 ) ."}{"node_name": "JTextArea(javax.swing.text.Document,java.lang.String,int,int)", "type": "constructor", "idx": 66970, "Desc": "constructs a new jtextarea with the specified number of rows and columns , and the given model . all of <init>(javax.swing.text.Document,java.lang.String,int,int)s feed through <init>(javax.swing.text.Document,java.lang.String,int,int) ."}{"node_name": "AccessibleJTextField()", "type": "constructor", "idx": 67022, "Desc": ""}{"node_name": "JTextField()", "type": "constructor", "idx": 67026, "Desc": "constructs a new textfield . a default model is created , the initial string is null , and the number of columns is set to 0 ."}{"node_name": "JTextField(java.lang.String)", "type": "constructor", "idx": 67027, "Desc": "constructs a new textfield initialized with the specified text . a default model is created and the number of columns is 0 ."}{"node_name": "JTextField(int)", "type": "constructor", "idx": 67029, "Desc": "constructs a new empty textfield with the specified number of columns . a default model is created and the initial string is set to null ."}{"node_name": "JTextField(java.lang.String,int)", "type": "constructor", "idx": 67031, "Desc": "constructs a new textfield initialized with the specified text and columns . a default model is created ."}{"node_name": "JTextField(javax.swing.text.Document,java.lang.String,int)", "type": "constructor", "idx": 67034, "Desc": "constructs a new jtextfield that uses the given text storage model and the given number of columns . this is <init>(javax.swing.text.Document,java.lang.String,int) through which the other constructors feed . if the document is null , a default model is created ."}{"node_name": "JTextPane()", "type": "constructor", "idx": 67082, "Desc": "creates a new jtextpane . a new instance of stylededitorkit is created and set , and the document model set to null ."}{"node_name": "JTextPane(javax.swing.text.StyledDocument)", "type": "constructor", "idx": 67083, "Desc": "creates a new jtextpane , with a specified document model . a new instance of javax.swing.text.stylededitorkit is created and set ."}{"node_name": "AccessibleJToggleButton()", "type": "constructor", "idx": 67122, "Desc": "constructs accessiblejtogglebutton"}{"node_name": "JToggleButton()", "type": "constructor", "idx": 67127, "Desc": "creates an initially unselected toggle button without setting the text or image ."}{"node_name": "JToggleButton(javax.swing.Icon)", "type": "constructor", "idx": 67128, "Desc": "creates an initially unselected toggle button with the specified image but no text ."}{"node_name": "JToggleButton(javax.swing.Icon,boolean)", "type": "constructor", "idx": 67130, "Desc": "creates a toggle button with the specified image and selection state , but no text ."}{"node_name": "JToggleButton(java.lang.String)", "type": "constructor", "idx": 67133, "Desc": "creates an unselected toggle button with the specified text ."}{"node_name": "JToggleButton(java.lang.String,boolean)", "type": "constructor", "idx": 67135, "Desc": "creates a toggle button with the specified text and selection state ."}{"node_name": "JToggleButton(javax.swing.Action)", "type": "constructor", "idx": 67138, "Desc": "creates a toggle button where properties are taken from the action supplied ."}{"node_name": "JToggleButton(java.lang.String,javax.swing.Icon)", "type": "constructor", "idx": 67140, "Desc": "creates a toggle button that has the specified text and image , and that is initially unselected ."}{"node_name": "JToggleButton(java.lang.String,javax.swing.Icon,boolean)", "type": "constructor", "idx": 67143, "Desc": "creates a toggle button with the specified text , image , and selection state ."}{"node_name": "ToggleButtonModel()", "type": "constructor", "idx": 67156, "Desc": "creates a new togglebutton model"}{"node_name": "AccessibleJToolBar()", "type": "constructor", "idx": 67163, "Desc": ""}{"node_name": "JToolBar()", "type": "constructor", "idx": 67167, "Desc": "creates a new tool bar ; orientation defaults to horizontal ."}{"node_name": "JToolBar(int)", "type": "constructor", "idx": 67168, "Desc": "creates a new tool bar with the specified orientation . the orientation must be either horizontal or vertical ."}{"node_name": "JToolBar(java.lang.String)", "type": "constructor", "idx": 67170, "Desc": "creates a new tool bar with the specified name . the name is used as the title of the undocked tool bar . the default orientation is horizontal ."}{"node_name": "JToolBar(java.lang.String,int)", "type": "constructor", "idx": 67172, "Desc": "creates a new tool bar with a specified name and orientation . all other constructors call <init>(java.lang.String,int) . if orientation is an invalid value , an exception will be thrown ."}{"node_name": "Separator()", "type": "constructor", "idx": 67217, "Desc": "creates a new toolbar separator with the default size as defined by the current look and feel ."}{"node_name": "Separator(java.awt.Dimension)", "type": "constructor", "idx": 67218, "Desc": "creates a new toolbar separator with the specified size ."}{"node_name": "AccessibleJToolTip()", "type": "constructor", "idx": 67228, "Desc": ""}{"node_name": "JToolTip()", "type": "constructor", "idx": 67232, "Desc": "creates a tool tip ."}{"node_name": "AccessibleJTreeNode(javax.swing.JTree,javax.swing.tree.TreePath,javax.accessibility.Accessible)", "type": "constructor", "idx": 67245, "Desc": "constructs an accessiblejtreenode"}{"node_name": "AccessibleJTree()", "type": "constructor", "idx": 67297, "Desc": "constructs accessiblejtree"}{"node_name": "DynamicUtilTreeNode(java.lang.Object,java.lang.Object)", "type": "constructor", "idx": 67340, "Desc": "creates a node with the specified object as its value and with the specified children . for the node to allow children , the children-object must be an array of objects , a vector , or a hashtable -- even if empty . otherwise , the node is not allowed to have children ."}{"node_name": "EmptySelectionModel()", "type": "constructor", "idx": 67354, "Desc": ""}{"node_name": "JTree()", "type": "constructor", "idx": 67406, "Desc": "returns a jtree with a sample model . the default model used by the tree defines a leaf node as any node without children ."}{"node_name": "JTree(java.lang.Object[])", "type": "constructor", "idx": 67407, "Desc": "returns a jtree with each element of the specified array as the child of a new root node which is not displayed . by default , the tree defines a leaf node as any node without children ."}{"node_name": "JTree(java.util.Vector)", "type": "constructor", "idx": 67409, "Desc": "returns a jtree with each element of the specified vector as the child of a new root node which is not displayed . by default , the tree defines a leaf node as any node without children ."}{"node_name": "JTree(java.util.Hashtable)", "type": "constructor", "idx": 67411, "Desc": "returns a jtree created from a hashtable which does not display with root . each value-half of the key / value pairs in the hashtable becomes a child of the new root node . by default , the tree defines a leaf node as any node without children ."}{"node_name": "JTree(javax.swing.tree.TreeNode)", "type": "constructor", "idx": 67413, "Desc": "returns a jtree with the specified treenode as its root , which displays the root node . by default , the tree defines a leaf node as any node without children ."}{"node_name": "JTree(javax.swing.tree.TreeNode,boolean)", "type": "constructor", "idx": 67415, "Desc": "returns a jtree with the specified treenode as its root , which displays the root node and which decides whether a node is a leaf node in the specified manner ."}{"node_name": "JTree(javax.swing.tree.TreeModel)", "type": "constructor", "idx": 67418, "Desc": "returns an instance of jtree which displays the root node -- the tree is created using the specified data model ."}{"node_name": "TreeModelHandler()", "type": "constructor", "idx": 67656, "Desc": ""}{"node_name": "TreeSelectionRedirector()", "type": "constructor", "idx": 67658, "Desc": ""}{"node_name": "AccessibleJViewport()", "type": "constructor", "idx": 67662, "Desc": ""}{"node_name": "JViewport()", "type": "constructor", "idx": 67672, "Desc": "creates a jviewport ."}{"node_name": "ViewListener()", "type": "constructor", "idx": 67748, "Desc": ""}{"node_name": "AccessibleJWindow()", "type": "constructor", "idx": 67750, "Desc": ""}{"node_name": "JWindow()", "type": "constructor", "idx": 67755, "Desc": "creates a window with no specified owner . this window will not be focusable . <init>() sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JWindow(java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 67756, "Desc": "creates a window with the specified graphicsconfiguration of a screen device . this window will not be focusable . <init>(java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JWindow(java.awt.Frame)", "type": "constructor", "idx": 67758, "Desc": "creates a window with the specified owner frame . if owner is null , the shared owner will be used and this window will not be focusable . also , this window will not be focusable unless its owner is showing on the screen . <init>(java.awt.Frame) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JWindow(java.awt.Window)", "type": "constructor", "idx": 67760, "Desc": "creates a window with the specified owner window . this window will not be focusable unless its owner is showing on the screen . if owner is null , the shared owner will be used and this window will not be focusable . <init>(java.awt.Window) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "JWindow(java.awt.Window,java.awt.GraphicsConfiguration)", "type": "constructor", "idx": 67762, "Desc": "creates a window with the specified owner window and graphicsconfiguration of a screen device . if owner is null , the shared owner will be used and this window will not be focusable . <init>(java.awt.Window,java.awt.GraphicsConfiguration) sets the component's locale property to the value returned by jcomponent.getdefaultlocale ."}{"node_name": "LayoutFocusTraversalPolicy()", "type": "constructor", "idx": 67822, "Desc": "constructs a layoutfocustraversalpolicy ."}{"node_name": "LayoutStyle()", "type": "constructor", "idx": 67840, "Desc": "creates a new layoutstyle . you generally don't create a layoutstyle . instead use the method getinstance to obtain the current layoutstyle ."}{"node_name": "LookAndFeel()", "type": "constructor", "idx": 67914, "Desc": ""}{"node_name": "MenuSelectionManager()", "type": "constructor", "idx": 67984, "Desc": ""}{"node_name": "OverlayLayout(java.awt.Container)", "type": "constructor", "idx": 68016, "Desc": "constructs a layout manager that performs overlay arrangement of the children . the layout manager created is dedicated to the given container ."}{"node_name": "ActionMapUIResource()", "type": "constructor", "idx": 68048, "Desc": "constructs an actionmapuiresource ."}{"node_name": "BasicArrowButton(int,java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68051, "Desc": "creates a basicarrowbutton whose arrow is drawn in the specified direction and with the specified colors ."}{"node_name": "BasicArrowButton(int)", "type": "constructor", "idx": 68057, "Desc": "creates a basicarrowbutton whose arrow is drawn in the specified direction ."}{"node_name": "ButtonBorder(java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68078, "Desc": "constructs a new instance of a buttonborder ."}{"node_name": "FieldBorder(java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68088, "Desc": "constructs a new instance of a fieldborder ."}{"node_name": "BasicBorders()", "type": "constructor", "idx": 68094, "Desc": ""}{"node_name": "MarginBorder()", "type": "constructor", "idx": 68105, "Desc": ""}{"node_name": "MenuBarBorder(java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68107, "Desc": "constructs a new instance of a menubarborder ."}{"node_name": "RadioButtonBorder(java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68111, "Desc": "constructs a new instance of a radiobuttonborder ."}{"node_name": "RolloverButtonBorder(java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68117, "Desc": "constructs a new instance of a rolloverbuttonborder ."}{"node_name": "SplitPaneBorder(java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68125, "Desc": "constructs a new instance of a splitpaneborder ."}{"node_name": "ToggleButtonBorder(java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 68129, "Desc": "constructs a new instance of a togglebuttonborder ."}{"node_name": "BasicButtonListener(javax.swing.AbstractButton)", "type": "constructor", "idx": 68135, "Desc": "constructs a new instance of basicbuttonlistener ."}{"node_name": "BasicButtonUI()", "type": "constructor", "idx": 68146, "Desc": ""}{"node_name": "BasicCheckBoxMenuItemUI()", "type": "constructor", "idx": 68199, "Desc": ""}{"node_name": "BasicCheckBoxUI()", "type": "constructor", "idx": 68208, "Desc": ""}{"node_name": "BasicColorChooserUI()", "type": "constructor", "idx": 68216, "Desc": ""}{"node_name": "PropertyHandler()", "type": "constructor", "idx": 68229, "Desc": ""}{"node_name": "BasicComboBoxEditor()", "type": "constructor", "idx": 68232, "Desc": "constructs a new instance of basiccomboboxeditor ."}{"node_name": "UIResource()", "type": "constructor", "idx": 68237, "Desc": ""}{"node_name": "BasicComboBoxRenderer()", "type": "constructor", "idx": 68240, "Desc": "constructs a new instance of basiccomboboxrenderer ."}{"node_name": "UIResource()", "type": "constructor", "idx": 68242, "Desc": ""}{"node_name": "ComboBoxLayoutManager()", "type": "constructor", "idx": 68244, "Desc": ""}{"node_name": "FocusHandler()", "type": "constructor", "idx": 68246, "Desc": ""}{"node_name": "ItemHandler()", "type": "constructor", "idx": 68248, "Desc": ""}{"node_name": "BasicComboBoxUI()", "type": "constructor", "idx": 68269, "Desc": ""}{"node_name": "KeyHandler()", "type": "constructor", "idx": 68331, "Desc": ""}{"node_name": "ListDataHandler()", "type": "constructor", "idx": 68333, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 68335, "Desc": ""}{"node_name": "InvocationKeyHandler()", "type": "constructor", "idx": 68337, "Desc": ""}{"node_name": "InvocationMouseHandler()", "type": "constructor", "idx": 68339, "Desc": ""}{"node_name": "InvocationMouseMotionHandler()", "type": "constructor", "idx": 68345, "Desc": ""}{"node_name": "ItemHandler()", "type": "constructor", "idx": 68347, "Desc": ""}{"node_name": "BasicComboPopup(javax.swing.JComboBox)", "type": "constructor", "idx": 68368, "Desc": "constructs a new instance of basiccombopopup ."}{"node_name": "ListDataHandler()", "type": "constructor", "idx": 68422, "Desc": ""}{"node_name": "ListMouseHandler()", "type": "constructor", "idx": 68424, "Desc": ""}{"node_name": "ListMouseMotionHandler()", "type": "constructor", "idx": 68426, "Desc": ""}{"node_name": "ListSelectionHandler()", "type": "constructor", "idx": 68428, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 68430, "Desc": ""}{"node_name": "BasicDesktopIconUI()", "type": "constructor", "idx": 68435, "Desc": "constructs a new instance of basicdesktopiconui ."}{"node_name": "MouseInputHandler()", "type": "constructor", "idx": 68451, "Desc": ""}{"node_name": "CloseAction()", "type": "constructor", "idx": 68459, "Desc": ""}{"node_name": "BasicDesktopPaneUI()", "type": "constructor", "idx": 68463, "Desc": "constructs a new instance of basicdesktoppaneui ."}{"node_name": "MaximizeAction()", "type": "constructor", "idx": 68478, "Desc": ""}{"node_name": "MinimizeAction()", "type": "constructor", "idx": 68480, "Desc": ""}{"node_name": "NavigateAction()", "type": "constructor", "idx": 68482, "Desc": ""}{"node_name": "OpenAction()", "type": "constructor", "idx": 68484, "Desc": ""}{"node_name": "BasicDirectoryModel(javax.swing.JFileChooser)", "type": "constructor", "idx": 68486, "Desc": "constructs a new instance of basicdirectorymodel ."}{"node_name": "BasicEditorPaneUI()", "type": "constructor", "idx": 68519, "Desc": "creates a new basiceditorpaneui ."}{"node_name": "AcceptAllFileFilter()", "type": "constructor", "idx": 68532, "Desc": "constructs an acceptallfilefilter ."}{"node_name": "ApproveSelectionAction()", "type": "constructor", "idx": 68536, "Desc": "constructs an approveselectionaction ."}{"node_name": "BasicFileView()", "type": "constructor", "idx": 68539, "Desc": "constructs a basicfileview ."}{"node_name": "CancelSelectionAction()", "type": "constructor", "idx": 68549, "Desc": ""}{"node_name": "ChangeToParentDirectoryAction()", "type": "constructor", "idx": 68551, "Desc": "constructs a changetoparentdirectoryaction ."}{"node_name": "DoubleClickListener(javax.swing.JList)", "type": "constructor", "idx": 68553, "Desc": "constucts a doubleclicklistener ."}{"node_name": "GoHomeAction()", "type": "constructor", "idx": 68558, "Desc": "constructs a gohomeaction ."}{"node_name": "BasicFileChooserUI(javax.swing.JFileChooser)", "type": "constructor", "idx": 68589, "Desc": "constructs a basicfilechooserui ."}{"node_name": "NewFolderAction()", "type": "constructor", "idx": 68658, "Desc": "constructs a newfolderaction ."}{"node_name": "SelectionListener()", "type": "constructor", "idx": 68660, "Desc": ""}{"node_name": "UpdateAction()", "type": "constructor", "idx": 68662, "Desc": ""}{"node_name": "BasicFormattedTextFieldUI()", "type": "constructor", "idx": 68664, "Desc": ""}{"node_name": "BasicGraphicsUtils()", "type": "constructor", "idx": 68669, "Desc": ""}{"node_name": "BasicHTML()", "type": "constructor", "idx": 68758, "Desc": ""}{"node_name": "BasicIconFactory()", "type": "constructor", "idx": 68772, "Desc": ""}{"node_name": "CloseAction()", "type": "constructor", "idx": 68782, "Desc": "constructs a new instance of a closeaction ."}{"node_name": "IconifyAction()", "type": "constructor", "idx": 68784, "Desc": "constructs a new instance of an iconifyaction ."}{"node_name": "BasicInternalFrameTitlePane(javax.swing.JInternalFrame)", "type": "constructor", "idx": 68813, "Desc": "constructs a new instance of basicinternalframetitlepane ."}{"node_name": "MaximizeAction()", "type": "constructor", "idx": 68842, "Desc": "constructs a new instance of a maximizeaction ."}{"node_name": "MoveAction()", "type": "constructor", "idx": 68844, "Desc": "constructs a new instance of a moveaction ."}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 68846, "Desc": ""}{"node_name": "RestoreAction()", "type": "constructor", "idx": 68848, "Desc": "constructs a new instance of a restoreaction ."}{"node_name": "SizeAction()", "type": "constructor", "idx": 68850, "Desc": "constructs a new instance of a sizeaction ."}{"node_name": "SystemMenuBar()", "type": "constructor", "idx": 68852, "Desc": ""}{"node_name": "TitlePaneLayout()", "type": "constructor", "idx": 68854, "Desc": ""}{"node_name": "BasicInternalFrameListener()", "type": "constructor", "idx": 68856, "Desc": ""}{"node_name": "BorderListener()", "type": "constructor", "idx": 68859, "Desc": ""}{"node_name": "ComponentHandler()", "type": "constructor", "idx": 68861, "Desc": ""}{"node_name": "GlassPaneDispatcher()", "type": "constructor", "idx": 68865, "Desc": ""}{"node_name": "InternalFrameLayout()", "type": "constructor", "idx": 68867, "Desc": ""}{"node_name": "InternalFramePropertyChangeListener()", "type": "constructor", "idx": 68869, "Desc": ""}{"node_name": "BasicInternalFrameUI(javax.swing.JInternalFrame)", "type": "constructor", "idx": 68884, "Desc": "constructs a basicinternalframeui ."}{"node_name": "BasicLabelUI()", "type": "constructor", "idx": 68966, "Desc": ""}{"node_name": "FocusHandler()", "type": "constructor", "idx": 69019, "Desc": ""}{"node_name": "BasicListUI()", "type": "constructor", "idx": 69040, "Desc": ""}{"node_name": "ListDataHandler()", "type": "constructor", "idx": 69091, "Desc": ""}{"node_name": "ListSelectionHandler()", "type": "constructor", "idx": 69093, "Desc": ""}{"node_name": "MouseInputHandler()", "type": "constructor", "idx": 69095, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 69097, "Desc": ""}{"node_name": "BasicLookAndFeel()", "type": "constructor", "idx": 69099, "Desc": ""}{"node_name": "BasicMenuBarUI()", "type": "constructor", "idx": 69120, "Desc": ""}{"node_name": "BasicMenuItemUI()", "type": "constructor", "idx": 69148, "Desc": ""}{"node_name": "MouseInputHandler()", "type": "constructor", "idx": 69199, "Desc": ""}{"node_name": "ChangeHandler(javax.swing.JMenu,javax.swing.plaf.basic.BasicMenuUI)", "type": "constructor", "idx": 69205, "Desc": "constructs a new instance of changehandler ."}{"node_name": "BasicMenuUI()", "type": "constructor", "idx": 69211, "Desc": ""}{"node_name": "MouseInputHandler()", "type": "constructor", "idx": 69221, "Desc": ""}{"node_name": "ButtonActionListener(int)", "type": "constructor", "idx": 69232, "Desc": "constructs a new instance of buttonactionlistener ."}{"node_name": "ButtonAreaLayout(boolean,int)", "type": "constructor", "idx": 69238, "Desc": "constructs a new instance of buttonarealayout ."}{"node_name": "BasicOptionPaneUI()", "type": "constructor", "idx": 69259, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 69314, "Desc": ""}{"node_name": "BasicPanelUI()", "type": "constructor", "idx": 69318, "Desc": ""}{"node_name": "BasicPasswordFieldUI()", "type": "constructor", "idx": 69332, "Desc": ""}{"node_name": "BasicPopupMenuSeparatorUI()", "type": "constructor", "idx": 69340, "Desc": ""}{"node_name": "BasicPopupMenuUI()", "type": "constructor", "idx": 69345, "Desc": "constructs a new instance of basicpopupmenuui ."}{"node_name": "ChangeHandler()", "type": "constructor", "idx": 69355, "Desc": ""}{"node_name": "BasicProgressBarUI()", "type": "constructor", "idx": 69360, "Desc": ""}{"node_name": "BasicRadioButtonMenuItemUI()", "type": "constructor", "idx": 69426, "Desc": ""}{"node_name": "BasicRadioButtonUI()", "type": "constructor", "idx": 69436, "Desc": ""}{"node_name": "BasicRootPaneUI()", "type": "constructor", "idx": 69450, "Desc": ""}{"node_name": "ArrowButtonListener()", "type": "constructor", "idx": 69472, "Desc": ""}{"node_name": "BasicScrollBarUI()", "type": "constructor", "idx": 69501, "Desc": ""}{"node_name": "ModelListener()", "type": "constructor", "idx": 69564, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 69566, "Desc": ""}{"node_name": "ScrollListener()", "type": "constructor", "idx": 69568, "Desc": "constructs a scrolllistener ."}{"node_name": "ScrollListener(int,boolean)", "type": "constructor", "idx": 69569, "Desc": "constructs a scrolllistener ."}{"node_name": "TrackListener()", "type": "constructor", "idx": 69580, "Desc": ""}{"node_name": "HSBChangeListener()", "type": "constructor", "idx": 69588, "Desc": ""}{"node_name": "BasicScrollPaneUI()", "type": "constructor", "idx": 69595, "Desc": ""}{"node_name": "MouseWheelHandler()", "type": "constructor", "idx": 69633, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 69637, "Desc": ""}{"node_name": "ViewportChangeHandler()", "type": "constructor", "idx": 69639, "Desc": ""}{"node_name": "VSBChangeListener()", "type": "constructor", "idx": 69641, "Desc": ""}{"node_name": "BasicSeparatorUI()", "type": "constructor", "idx": 69645, "Desc": ""}{"node_name": "ActionScroller(javax.swing.JSlider,int,boolean)", "type": "constructor", "idx": 69657, "Desc": "constructs an actionscroller ."}{"node_name": "ChangeHandler()", "type": "constructor", "idx": 69662, "Desc": ""}{"node_name": "ComponentHandler()", "type": "constructor", "idx": 69664, "Desc": ""}{"node_name": "FocusHandler()", "type": "constructor", "idx": 69666, "Desc": ""}{"node_name": "BasicSliderUI(javax.swing.JSlider)", "type": "constructor", "idx": 69690, "Desc": "constructs a basicsliderui ."}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 69823, "Desc": ""}{"node_name": "ScrollListener()", "type": "constructor", "idx": 69825, "Desc": "constructs a scrolllistener"}{"node_name": "ScrollListener(int,boolean)", "type": "constructor", "idx": 69826, "Desc": "constructs a scrolllistener"}{"node_name": "TrackListener()", "type": "constructor", "idx": 69837, "Desc": ""}{"node_name": "BasicSpinnerUI()", "type": "constructor", "idx": 69846, "Desc": ""}{"node_name": "DividerLayout()", "type": "constructor", "idx": 69877, "Desc": ""}{"node_name": "DragController(java.awt.event.MouseEvent)", "type": "constructor", "idx": 69879, "Desc": "constructs a new instance of dragcontroller ."}{"node_name": "BasicSplitPaneDivider(javax.swing.plaf.basic.BasicSplitPaneUI)", "type": "constructor", "idx": 69909, "Desc": "creates an instance of basicsplitpanedivider . registers this instance for mouse events and mouse dragged events ."}{"node_name": "MouseHandler()", "type": "constructor", "idx": 69939, "Desc": ""}{"node_name": "VerticalDragController(java.awt.event.MouseEvent)", "type": "constructor", "idx": 69953, "Desc": "constructs a new instance of verticaldragcontroller ."}{"node_name": "BasicVerticalLayoutManager()", "type": "constructor", "idx": 70008, "Desc": "constructs a new instance of basicverticallayoutmanager ."}{"node_name": "FocusHandler()", "type": "constructor", "idx": 70010, "Desc": ""}{"node_name": "BasicSplitPaneUI()", "type": "constructor", "idx": 70023, "Desc": ""}{"node_name": "KeyboardDownRightHandler()", "type": "constructor", "idx": 70086, "Desc": ""}{"node_name": "KeyboardEndHandler()", "type": "constructor", "idx": 70088, "Desc": ""}{"node_name": "KeyboardHomeHandler()", "type": "constructor", "idx": 70090, "Desc": ""}{"node_name": "KeyboardResizeToggleHandler()", "type": "constructor", "idx": 70092, "Desc": ""}{"node_name": "KeyboardUpLeftHandler()", "type": "constructor", "idx": 70094, "Desc": ""}{"node_name": "PropertyHandler()", "type": "constructor", "idx": 70096, "Desc": ""}{"node_name": "FocusHandler()", "type": "constructor", "idx": 70100, "Desc": ""}{"node_name": "BasicTabbedPaneUI()", "type": "constructor", "idx": 70125, "Desc": ""}{"node_name": "MouseHandler()", "type": "constructor", "idx": 70367, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 70369, "Desc": ""}{"node_name": "TabbedPaneLayout()", "type": "constructor", "idx": 70371, "Desc": ""}{"node_name": "TabSelectionHandler()", "type": "constructor", "idx": 70401, "Desc": ""}{"node_name": "BasicTableHeaderUI()", "type": "constructor", "idx": 70406, "Desc": ""}{"node_name": "MouseInputHandler()", "type": "constructor", "idx": 70431, "Desc": ""}{"node_name": "FocusHandler()", "type": "constructor", "idx": 70433, "Desc": ""}{"node_name": "BasicTableUI()", "type": "constructor", "idx": 70440, "Desc": ""}{"node_name": "KeyHandler()", "type": "constructor", "idx": 70468, "Desc": ""}{"node_name": "MouseInputHandler()", "type": "constructor", "idx": 70470, "Desc": ""}{"node_name": "BasicTextAreaUI()", "type": "constructor", "idx": 70472, "Desc": "constructs a new basictextareaui object ."}{"node_name": "BasicTextFieldUI()", "type": "constructor", "idx": 70491, "Desc": "creates a new basictextfieldui ."}{"node_name": "BasicTextPaneUI()", "type": "constructor", "idx": 70504, "Desc": "creates a new basictextpaneui ."}{"node_name": "BasicCaret()", "type": "constructor", "idx": 70511, "Desc": ""}{"node_name": "BasicHighlighter()", "type": "constructor", "idx": 70513, "Desc": ""}{"node_name": "BasicTextUI()", "type": "constructor", "idx": 70515, "Desc": "creates a new ui ."}{"node_name": "BasicToggleButtonUI()", "type": "constructor", "idx": 70578, "Desc": ""}{"node_name": "BasicToolBarSeparatorUI()", "type": "constructor", "idx": 70587, "Desc": ""}{"node_name": "DockingListener(javax.swing.JToolBar)", "type": "constructor", "idx": 70594, "Desc": "constructs a new instance of dockinglistener ."}{"node_name": "FrameListener()", "type": "constructor", "idx": 70607, "Desc": ""}{"node_name": "BasicToolBarUI()", "type": "constructor", "idx": 70621, "Desc": ""}{"node_name": "PropertyListener()", "type": "constructor", "idx": 70693, "Desc": ""}{"node_name": "ToolBarContListener()", "type": "constructor", "idx": 70695, "Desc": ""}{"node_name": "ToolBarFocusListener()", "type": "constructor", "idx": 70697, "Desc": ""}{"node_name": "BasicToolTipUI()", "type": "constructor", "idx": 70699, "Desc": "constructs a new instance of basictooltipui ."}{"node_name": "CellEditorHandler()", "type": "constructor", "idx": 70711, "Desc": ""}{"node_name": "ComponentHandler()", "type": "constructor", "idx": 70719, "Desc": ""}{"node_name": "FocusHandler()", "type": "constructor", "idx": 70725, "Desc": ""}{"node_name": "BasicTreeUI()", "type": "constructor", "idx": 70758, "Desc": "constructs a new instance of basictreeui ."}{"node_name": "KeyHandler()", "type": "constructor", "idx": 71010, "Desc": ""}{"node_name": "MouseHandler()", "type": "constructor", "idx": 71014, "Desc": ""}{"node_name": "MouseInputHandler(java.awt.Component,java.awt.Component,java.awt.event.MouseEvent)", "type": "constructor", "idx": 71022, "Desc": "constructs a new instance of mouseinputhandler ."}{"node_name": "NodeDimensionsHandler()", "type": "constructor", "idx": 71028, "Desc": ""}{"node_name": "PropertyChangeHandler()", "type": "constructor", "idx": 71039, "Desc": ""}{"node_name": "SelectionModelPropertyChangeHandler()", "type": "constructor", "idx": 71041, "Desc": ""}{"node_name": "TreeCancelEditingAction(java.lang.String)", "type": "constructor", "idx": 71043, "Desc": "constructs a new instance of treecanceleditingaction ."}{"node_name": "TreeExpansionHandler()", "type": "constructor", "idx": 71046, "Desc": ""}{"node_name": "TreeHomeAction(int,java.lang.String)", "type": "constructor", "idx": 71053, "Desc": "constructs a new instance of treehomeaction ."}{"node_name": "TreeIncrementAction(int,java.lang.String)", "type": "constructor", "idx": 71058, "Desc": "constructs a new instance of treeincrementaction ."}{"node_name": "TreeModelHandler()", "type": "constructor", "idx": 71062, "Desc": ""}{"node_name": "TreePageAction(int,java.lang.String)", "type": "constructor", "idx": 71065, "Desc": "constructs a new instance of treepageaction ."}{"node_name": "TreeSelectionHandler()", "type": "constructor", "idx": 71069, "Desc": ""}{"node_name": "TreeToggleAction(java.lang.String)", "type": "constructor", "idx": 71073, "Desc": "constructs a new instance of treetoggleaction ."}{"node_name": "TreeTraverseAction(int,java.lang.String)", "type": "constructor", "idx": 71077, "Desc": "constructs a new instance of treetraverseaction ."}{"node_name": "BasicViewportUI()", "type": "constructor", "idx": 71081, "Desc": ""}{"node_name": "DefaultMenuLayout(java.awt.Container,int)", "type": "constructor", "idx": 71098, "Desc": "constructs a new instance of defaultmenulayout ."}{"node_name": "BevelBorderUIResource(int)", "type": "constructor", "idx": 71102, "Desc": "constructs a bevelborderuiresource ."}{"node_name": "BevelBorderUIResource(int,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 71104, "Desc": "constructs a bevelborderuiresource ."}{"node_name": "BevelBorderUIResource(int,java.awt.Color,java.awt.Color,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 71108, "Desc": "constructs a bevelborderuiresource ."}{"node_name": "CompoundBorderUIResource(javax.swing.border.Border,javax.swing.border.Border)", "type": "constructor", "idx": 71115, "Desc": "constructs a compoundborderuiresource ."}{"node_name": "EmptyBorderUIResource(int,int,int,int)", "type": "constructor", "idx": 71119, "Desc": "constructs an emptyborderuiresource ."}{"node_name": "EmptyBorderUIResource(java.awt.Insets)", "type": "constructor", "idx": 71124, "Desc": "constructs an emptyborderuiresource ."}{"node_name": "EtchedBorderUIResource()", "type": "constructor", "idx": 71127, "Desc": "constructs an etchedborderuiresource ."}{"node_name": "EtchedBorderUIResource(int)", "type": "constructor", "idx": 71128, "Desc": "constructs an etchedborderuiresource ."}{"node_name": "EtchedBorderUIResource(java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 71130, "Desc": "constructs an etchedborderuiresource ."}{"node_name": "EtchedBorderUIResource(int,java.awt.Color,java.awt.Color)", "type": "constructor", "idx": 71133, "Desc": "constructs an etchedborderuiresource ."}{"node_name": "BorderUIResource(javax.swing.border.Border)", "type": "constructor", "idx": 71138, "Desc": "creates a uiresource border object which wraps an existing border instance ."}{"node_name": "LineBorderUIResource(java.awt.Color)", "type": "constructor", "idx": 71145, "Desc": "constructs a lineborderuiresource ."}{"node_name": "LineBorderUIResource(java.awt.Color,int)", "type": "constructor", "idx": 71147, "Desc": "constructs a lineborderuiresource ."}{"node_name": "MatteBorderUIResource(int,int,int,int,java.awt.Color)", "type": "constructor", "idx": 71151, "Desc": "constructs a matteborderuiresource ."}{"node_name": "MatteBorderUIResource(int,int,int,int,javax.swing.Icon)", "type": "constructor", "idx": 71157, "Desc": "constructs a matteborderuiresource ."}{"node_name": "MatteBorderUIResource(javax.swing.Icon)", "type": "constructor", "idx": 71163, "Desc": "constructs a matteborderuiresource ."}{"node_name": "TitledBorderUIResource(java.lang.String)", "type": "constructor", "idx": 71166, "Desc": "constructs a titledborderuiresource ."}{"node_name": "TitledBorderUIResource(javax.swing.border.Border)", "type": "constructor", "idx": 71168, "Desc": "constructs a titledborderuiresource ."}{"node_name": "TitledBorderUIResource(javax.swing.border.Border,java.lang.String)", "type": "constructor", "idx": 71170, "Desc": "constructs a titledborderuiresource ."}{"node_name": "TitledBorderUIResource(javax.swing.border.Border,java.lang.String,int,int)", "type": "constructor", "idx": 71173, "Desc": "constructs a titledborderuiresource ."}{"node_name": "TitledBorderUIResource(javax.swing.border.Border,java.lang.String,int,int,java.awt.Font)", "type": "constructor", "idx": 71178, "Desc": "constructs a titledborderuiresource ."}{"node_name": "TitledBorderUIResource(javax.swing.border.Border,java.lang.String,int,int,java.awt.Font,java.awt.Color)", "type": "constructor", "idx": 71184, "Desc": "constructs a titledborderuiresource ."}{"node_name": "ButtonUI()", "type": "constructor", "idx": 71192, "Desc": ""}{"node_name": "ColorChooserUI()", "type": "constructor", "idx": 71194, "Desc": ""}{"node_name": "ColorUIResource(int,int,int)", "type": "constructor", "idx": 71196, "Desc": "constructs a coloruiresource ."}{"node_name": "ColorUIResource(int)", "type": "constructor", "idx": 71200, "Desc": "constructs a coloruiresource ."}{"node_name": "ColorUIResource(float,float,float)", "type": "constructor", "idx": 71202, "Desc": "constructs a coloruiresource ."}{"node_name": "ColorUIResource(java.awt.Color)", "type": "constructor", "idx": 71206, "Desc": "constructs a coloruiresource ."}{"node_name": "ComboBoxUI()", "type": "constructor", "idx": 71209, "Desc": ""}{"node_name": "ComponentInputMapUIResource(javax.swing.JComponent)", "type": "constructor", "idx": 71218, "Desc": "constructs a componentinputmapuiresource ."}{"node_name": "ComponentUI()", "type": "constructor", "idx": 71221, "Desc": "sole constructor . ( for invocation by subclass constructors , typically implicit . )"}{"node_name": "DesktopIconUI()", "type": "constructor", "idx": 71256, "Desc": ""}{"node_name": "DesktopPaneUI()", "type": "constructor", "idx": 71258, "Desc": ""}{"node_name": "DimensionUIResource(int,int)", "type": "constructor", "idx": 71260, "Desc": "constructs a dimensionuiresource ."}{"node_name": "FileChooserUI()", "type": "constructor", "idx": 71264, "Desc": ""}{"node_name": "FontUIResource(java.lang.String,int,int)", "type": "constructor", "idx": 71281, "Desc": "constructs a fontuiresource ."}{"node_name": "FontUIResource(java.awt.Font)", "type": "constructor", "idx": 71285, "Desc": "constructs a fontuiresource ."}{"node_name": "IconUIResource(javax.swing.Icon)", "type": "constructor", "idx": 71288, "Desc": "creates a uiresource icon object which wraps an existing icon instance ."}{"node_name": "InputMapUIResource()", "type": "constructor", "idx": 71291, "Desc": "constructs an inputmapuiresource ."}{"node_name": "InsetsUIResource(int,int,int,int)", "type": "constructor", "idx": 71293, "Desc": "constructs an insetsuiresource ."}{"node_name": "InternalFrameUI()", "type": "constructor", "idx": 71299, "Desc": ""}{"node_name": "LabelUI()", "type": "constructor", "idx": 71301, "Desc": ""}{"node_name": "LayerUI()", "type": "constructor", "idx": 71303, "Desc": ""}{"node_name": "ListUI()", "type": "constructor", "idx": 71392, "Desc": ""}{"node_name": "MenuBarUI()", "type": "constructor", "idx": 71404, "Desc": ""}{"node_name": "MenuItemUI()", "type": "constructor", "idx": 71406, "Desc": ""}{"node_name": "DefaultMetalTheme()", "type": "constructor", "idx": 71408, "Desc": "creates and returns an instance of defaultmetaltheme ."}{"node_name": "ButtonBorder()", "type": "constructor", "idx": 71424, "Desc": ""}{"node_name": "Flush3DBorder()", "type": "constructor", "idx": 71426, "Desc": ""}{"node_name": "InternalFrameBorder()", "type": "constructor", "idx": 71428, "Desc": ""}{"node_name": "MetalBorders()", "type": "constructor", "idx": 71430, "Desc": ""}{"node_name": "MenuBarBorder()", "type": "constructor", "idx": 71438, "Desc": ""}{"node_name": "MenuItemBorder()", "type": "constructor", "idx": 71441, "Desc": ""}{"node_name": "OptionDialogBorder()", "type": "constructor", "idx": 71443, "Desc": ""}{"node_name": "PaletteBorder()", "type": "constructor", "idx": 71445, "Desc": ""}{"node_name": "PopupMenuBorder()", "type": "constructor", "idx": 71448, "Desc": ""}{"node_name": "RolloverButtonBorder()", "type": "constructor", "idx": 71450, "Desc": ""}{"node_name": "ScrollPaneBorder()", "type": "constructor", "idx": 71452, "Desc": ""}{"node_name": "TableHeaderBorder()", "type": "constructor", "idx": 71455, "Desc": ""}{"node_name": "TextFieldBorder()", "type": "constructor", "idx": 71457, "Desc": ""}{"node_name": "ToolBarBorder()", "type": "constructor", "idx": 71460, "Desc": ""}{"node_name": "MetalButtonUI()", "type": "constructor", "idx": 71465, "Desc": ""}{"node_name": "MetalCheckBoxIcon()", "type": "constructor", "idx": 71475, "Desc": ""}{"node_name": "MetalCheckBoxUI()", "type": "constructor", "idx": 71483, "Desc": ""}{"node_name": "MetalComboBoxButton(javax.swing.JComboBox,javax.swing.Icon,javax.swing.CellRendererPane,javax.swing.JList)", "type": "constructor", "idx": 71492, "Desc": "constructs a new instance of metalcomboboxbutton ."}{"node_name": "MetalComboBoxButton(javax.swing.JComboBox,javax.swing.Icon,boolean,javax.swing.CellRendererPane,javax.swing.JList)", "type": "constructor", "idx": 71497, "Desc": "constructs a new instance of metalcomboboxbutton ."}{"node_name": "MetalComboBoxEditor()", "type": "constructor", "idx": 71514, "Desc": "constructs a new instance of metalcomboboxeditor ."}{"node_name": "UIResource()", "type": "constructor", "idx": 71516, "Desc": ""}{"node_name": "MetalComboBoxIcon()", "type": "constructor", "idx": 71518, "Desc": ""}{"node_name": "MetalComboBoxUI()", "type": "constructor", "idx": 71527, "Desc": ""}{"node_name": "MetalComboBoxLayoutManager()", "type": "constructor", "idx": 71546, "Desc": ""}{"node_name": "MetalPropertyChangeListener()", "type": "constructor", "idx": 71551, "Desc": ""}{"node_name": "MetalDesktopIconUI()", "type": "constructor", "idx": 71553, "Desc": "constructs a new instance of metaldesktopiconui ."}{"node_name": "DirectoryComboBoxAction()", "type": "constructor", "idx": 71557, "Desc": "constructs a new instance of directorycomboboxaction ."}{"node_name": "DirectoryComboBoxModel()", "type": "constructor", "idx": 71559, "Desc": "constructs an instance of directorycomboboxmodel ."}{"node_name": "FilterComboBoxModel()", "type": "constructor", "idx": 71565, "Desc": "constructs an instance of filtercomboboxmodel ."}{"node_name": "FilterComboBoxRenderer()", "type": "constructor", "idx": 71567, "Desc": ""}{"node_name": "MetalFileChooserUI(javax.swing.JFileChooser)", "type": "constructor", "idx": 71569, "Desc": "constructs a new instance of metalfilechooserui ."}{"node_name": "FileIcon16()", "type": "constructor", "idx": 71604, "Desc": ""}{"node_name": "FolderIcon16()", "type": "constructor", "idx": 71608, "Desc": ""}{"node_name": "MetalIconFactory()", "type": "constructor", "idx": 71614, "Desc": ""}{"node_name": "PaletteCloseIcon()", "type": "constructor", "idx": 71646, "Desc": ""}{"node_name": "TreeControlIcon(boolean)", "type": "constructor", "idx": 71649, "Desc": "constructs an instance of treecontrolicon ."}{"node_name": "TreeFolderIcon()", "type": "constructor", "idx": 71657, "Desc": ""}{"node_name": "TreeLeafIcon()", "type": "constructor", "idx": 71659, "Desc": ""}{"node_name": "MetalInternalFrameTitlePane(javax.swing.JInternalFrame)", "type": "constructor", "idx": 71664, "Desc": "constructs a new instance of metalinternalframetitlepane"}{"node_name": "MetalInternalFrameUI(javax.swing.JInternalFrame)", "type": "constructor", "idx": 71677, "Desc": "constructs a new metalinternalframeui instance ."}{"node_name": "MetalLabelUI()", "type": "constructor", "idx": 71687, "Desc": ""}{"node_name": "MetalLookAndFeel()", "type": "constructor", "idx": 71697, "Desc": ""}{"node_name": "MetalMenuBarUI()", "type": "constructor", "idx": 71767, "Desc": ""}{"node_name": "MetalPopupMenuSeparatorUI()", "type": "constructor", "idx": 71778, "Desc": ""}{"node_name": "MetalProgressBarUI()", "type": "constructor", "idx": 71782, "Desc": ""}{"node_name": "MetalRadioButtonUI()", "type": "constructor", "idx": 71795, "Desc": ""}{"node_name": "MetalRootPaneUI()", "type": "constructor", "idx": 71802, "Desc": ""}{"node_name": "MetalScrollBarUI()", "type": "constructor", "idx": 71817, "Desc": ""}{"node_name": "MetalScrollButton(int,int,boolean)", "type": "constructor", "idx": 71830, "Desc": "constructs an instance of metalscrollbutton ."}{"node_name": "MetalScrollPaneUI()", "type": "constructor", "idx": 71838, "Desc": ""}{"node_name": "MetalSeparatorUI()", "type": "constructor", "idx": 71843, "Desc": ""}{"node_name": "MetalSliderUI()", "type": "constructor", "idx": 71857, "Desc": "constructs a metalsliderui instance ."}{"node_name": "MetalPropertyListener()", "type": "constructor", "idx": 71867, "Desc": ""}{"node_name": "MetalSplitPaneUI()", "type": "constructor", "idx": 71869, "Desc": ""}{"node_name": "MetalTabbedPaneUI()", "type": "constructor", "idx": 71878, "Desc": ""}{"node_name": "TabbedPaneLayout()", "type": "constructor", "idx": 71944, "Desc": "constructs tabbedpanelayout ."}{"node_name": "MetalTextFieldUI()", "type": "constructor", "idx": 71946, "Desc": ""}{"node_name": "MetalTheme()", "type": "constructor", "idx": 71952, "Desc": ""}{"node_name": "MetalToggleButtonUI()", "type": "constructor", "idx": 72008, "Desc": ""}{"node_name": "MetalToolBarUI()", "type": "constructor", "idx": 72024, "Desc": ""}{"node_name": "MetalContainerListener()", "type": "constructor", "idx": 72035, "Desc": ""}{"node_name": "MetalDockingListener(javax.swing.JToolBar)", "type": "constructor", "idx": 72037, "Desc": "constructs the metaldockinglistener ."}{"node_name": "MetalRolloverListener()", "type": "constructor", "idx": 72040, "Desc": ""}{"node_name": "MetalToolTipUI()", "type": "constructor", "idx": 72043, "Desc": "constructs an instance of the metaltooltipui ."}{"node_name": "MetalTreeUI()", "type": "constructor", "idx": 72049, "Desc": "constructs the metaltreeui ."}{"node_name": "OceanTheme()", "type": "constructor", "idx": 72063, "Desc": "creates an instance of oceantheme"}{"node_name": "MultiButtonUI()", "type": "constructor", "idx": 72080, "Desc": ""}{"node_name": "MultiColorChooserUI()", "type": "constructor", "idx": 72111, "Desc": ""}{"node_name": "MultiComboBoxUI()", "type": "constructor", "idx": 72142, "Desc": ""}{"node_name": "MultiDesktopIconUI()", "type": "constructor", "idx": 72180, "Desc": ""}{"node_name": "MultiDesktopPaneUI()", "type": "constructor", "idx": 72211, "Desc": ""}{"node_name": "MultiFileChooserUI()", "type": "constructor", "idx": 72242, "Desc": ""}{"node_name": "MultiInternalFrameUI()", "type": "constructor", "idx": 72286, "Desc": ""}{"node_name": "MultiLabelUI()", "type": "constructor", "idx": 72317, "Desc": ""}{"node_name": "MultiListUI()", "type": "constructor", "idx": 72348, "Desc": ""}{"node_name": "MultiLookAndFeel()", "type": "constructor", "idx": 72388, "Desc": ""}{"node_name": "MultiMenuBarUI()", "type": "constructor", "idx": 72403, "Desc": ""}{"node_name": "MultiMenuItemUI()", "type": "constructor", "idx": 72434, "Desc": ""}{"node_name": "MultiOptionPaneUI()", "type": "constructor", "idx": 72465, "Desc": ""}{"node_name": "MultiPanelUI()", "type": "constructor", "idx": 72500, "Desc": ""}{"node_name": "MultiPopupMenuUI()", "type": "constructor", "idx": 72531, "Desc": ""}{"node_name": "MultiProgressBarUI()", "type": "constructor", "idx": 72568, "Desc": ""}{"node_name": "MultiRootPaneUI()", "type": "constructor", "idx": 72599, "Desc": ""}{"node_name": "MultiScrollBarUI()", "type": "constructor", "idx": 72630, "Desc": ""}{"node_name": "MultiScrollPaneUI()", "type": "constructor", "idx": 72661, "Desc": ""}{"node_name": "MultiSeparatorUI()", "type": "constructor", "idx": 72692, "Desc": ""}{"node_name": "MultiSliderUI()", "type": "constructor", "idx": 72723, "Desc": ""}{"node_name": "MultiSpinnerUI()", "type": "constructor", "idx": 72754, "Desc": ""}{"node_name": "MultiSplitPaneUI()", "type": "constructor", "idx": 72785, "Desc": ""}{"node_name": "MultiTabbedPaneUI()", "type": "constructor", "idx": 72830, "Desc": ""}{"node_name": "MultiTableHeaderUI()", "type": "constructor", "idx": 72870, "Desc": ""}{"node_name": "MultiTableUI()", "type": "constructor", "idx": 72901, "Desc": ""}{"node_name": "MultiTextUI()", "type": "constructor", "idx": 72932, "Desc": ""}{"node_name": "MultiToolBarUI()", "type": "constructor", "idx": 72986, "Desc": ""}{"node_name": "MultiToolTipUI()", "type": "constructor", "idx": 73017, "Desc": ""}{"node_name": "MultiTreeUI()", "type": "constructor", "idx": 73048, "Desc": ""}{"node_name": "MultiViewportUI()", "type": "constructor", "idx": 73105, "Desc": ""}{"node_name": "AbstractRegionPainter()", "type": "constructor", "idx": 73135, "Desc": "create a new abstractregionpainter"}{"node_name": "PaintContext(java.awt.Insets,java.awt.Dimension,boolean)", "type": "constructor", "idx": 73192, "Desc": "creates a new paintcontext which does not attempt to cache or scale any cached images ."}{"node_name": "PaintContext(java.awt.Insets,java.awt.Dimension,boolean,javax.swing.plaf.nimbus.AbstractRegionPainter.PaintContext.CacheMode,double,double)", "type": "constructor", "idx": 73196, "Desc": "creates a new paintcontext ."}{"node_name": "NimbusLookAndFeel()", "type": "constructor", "idx": 73204, "Desc": "create a new nimbuslookandfeel ."}{"node_name": "State(java.lang.String)", "type": "constructor", "idx": 73266, "Desc": "create a new custom state . specify the name for the state . the name should be unique within the states set for any one particular component . the name of the state should coincide with the name used in uidefaults . for example , the following would be correct : defaults.put ( \" button.states \" , \" enabled , foo , disabled \") ; defaults.put ( \" button.foo \" , new foostate ( \" foo \")) ;"}{"node_name": "OptionPaneUI()", "type": "constructor", "idx": 73271, "Desc": ""}{"node_name": "PanelUI()", "type": "constructor", "idx": 73277, "Desc": ""}{"node_name": "PopupMenuUI()", "type": "constructor", "idx": 73279, "Desc": ""}{"node_name": "ProgressBarUI()", "type": "constructor", "idx": 73287, "Desc": ""}{"node_name": "RootPaneUI()", "type": "constructor", "idx": 73289, "Desc": ""}{"node_name": "ScrollBarUI()", "type": "constructor", "idx": 73291, "Desc": ""}{"node_name": "ScrollPaneUI()", "type": "constructor", "idx": 73293, "Desc": ""}{"node_name": "SeparatorUI()", "type": "constructor", "idx": 73295, "Desc": ""}{"node_name": "SliderUI()", "type": "constructor", "idx": 73297, "Desc": ""}{"node_name": "SpinnerUI()", "type": "constructor", "idx": 73299, "Desc": ""}{"node_name": "SplitPaneUI()", "type": "constructor", "idx": 73301, "Desc": ""}{"node_name": "ColorType(java.lang.String)", "type": "constructor", "idx": 73323, "Desc": "creates a new colortype with the specified description ."}{"node_name": "Region(java.lang.String,java.lang.String,boolean)", "type": "constructor", "idx": 73385, "Desc": "creates a region with the specified name . this should only be used if you are creating your own jcomponent subclass with a custom componentui class ."}{"node_name": "SynthButtonUI()", "type": "constructor", "idx": 73393, "Desc": ""}{"node_name": "SynthCheckBoxMenuItemUI()", "type": "constructor", "idx": 73412, "Desc": ""}{"node_name": "SynthCheckBoxUI()", "type": "constructor", "idx": 73416, "Desc": ""}{"node_name": "SynthColorChooserUI()", "type": "constructor", "idx": 73420, "Desc": ""}{"node_name": "SynthComboBoxUI()", "type": "constructor", "idx": 73433, "Desc": ""}{"node_name": "SynthContext(javax.swing.JComponent,javax.swing.plaf.synth.Region,javax.swing.plaf.synth.SynthStyle,int)", "type": "constructor", "idx": 73461, "Desc": "creates a synthcontext with the specified values . this is meant for subclasses and custom ui implementors . you very rarely need to construct a synthcontext , though some methods will take one ."}{"node_name": "SynthDesktopIconUI()", "type": "constructor", "idx": 73471, "Desc": ""}{"node_name": "SynthDesktopPaneUI()", "type": "constructor", "idx": 73484, "Desc": ""}{"node_name": "SynthEditorPaneUI()", "type": "constructor", "idx": 73497, "Desc": ""}{"node_name": "SynthFormattedTextFieldUI()", "type": "constructor", "idx": 73509, "Desc": ""}{"node_name": "SynthGraphicsUtils()", "type": "constructor", "idx": 73514, "Desc": "creates a synthgraphicsutils ."}{"node_name": "SynthInternalFrameUI(javax.swing.JInternalFrame)", "type": "constructor", "idx": 73637, "Desc": "constructs a synthinternalframeui ."}{"node_name": "SynthLabelUI()", "type": "constructor", "idx": 73651, "Desc": ""}{"node_name": "SynthListUI()", "type": "constructor", "idx": 73664, "Desc": ""}{"node_name": "SynthLookAndFeel()", "type": "constructor", "idx": 73671, "Desc": "creates a synthlookandfeel . for the returned synthlookandfeel to be useful you need to invoke load to specify the set of synthstyles , or invoke setstylefactory ."}{"node_name": "SynthMenuBarUI()", "type": "constructor", "idx": 73701, "Desc": ""}{"node_name": "SynthMenuItemUI()", "type": "constructor", "idx": 73714, "Desc": ""}{"node_name": "SynthMenuUI()", "type": "constructor", "idx": 73727, "Desc": ""}{"node_name": "SynthOptionPaneUI()", "type": "constructor", "idx": 73740, "Desc": ""}{"node_name": "SynthPainter()", "type": "constructor", "idx": 73754, "Desc": ""}{"node_name": "SynthPanelUI()", "type": "constructor", "idx": 74744, "Desc": ""}{"node_name": "SynthPasswordFieldUI()", "type": "constructor", "idx": 74761, "Desc": ""}{"node_name": "SynthPopupMenuUI()", "type": "constructor", "idx": 74768, "Desc": ""}{"node_name": "SynthProgressBarUI()", "type": "constructor", "idx": 74781, "Desc": ""}{"node_name": "SynthRadioButtonMenuItemUI()", "type": "constructor", "idx": 74798, "Desc": ""}{"node_name": "SynthRadioButtonUI()", "type": "constructor", "idx": 74802, "Desc": ""}{"node_name": "SynthRootPaneUI()", "type": "constructor", "idx": 74808, "Desc": ""}{"node_name": "SynthScrollBarUI()", "type": "constructor", "idx": 74823, "Desc": ""}{"node_name": "SynthScrollPaneUI()", "type": "constructor", "idx": 74846, "Desc": ""}{"node_name": "SynthSeparatorUI()", "type": "constructor", "idx": 74859, "Desc": ""}{"node_name": "SynthSliderUI(javax.swing.JSlider)", "type": "constructor", "idx": 74880, "Desc": "constructs a synthsliderui ."}{"node_name": "SynthSpinnerUI()", "type": "constructor", "idx": 74905, "Desc": ""}{"node_name": "SynthSplitPaneUI()", "type": "constructor", "idx": 74924, "Desc": ""}{"node_name": "SynthStyle()", "type": "constructor", "idx": 74942, "Desc": "constructs a synthstyle ."}{"node_name": "SynthStyleFactory()", "type": "constructor", "idx": 74985, "Desc": "creates a synthstylefactory ."}{"node_name": "SynthTabbedPaneUI()", "type": "constructor", "idx": 74990, "Desc": ""}{"node_name": "SynthTableHeaderUI()", "type": "constructor", "idx": 75005, "Desc": ""}{"node_name": "SynthTableUI()", "type": "constructor", "idx": 75018, "Desc": ""}{"node_name": "SynthTextAreaUI()", "type": "constructor", "idx": 75033, "Desc": ""}{"node_name": "SynthTextFieldUI()", "type": "constructor", "idx": 75047, "Desc": ""}{"node_name": "SynthTextPaneUI()", "type": "constructor", "idx": 75061, "Desc": ""}{"node_name": "SynthToggleButtonUI()", "type": "constructor", "idx": 75070, "Desc": ""}{"node_name": "SynthToolBarUI()", "type": "constructor", "idx": 75074, "Desc": ""}{"node_name": "SynthToolTipUI()", "type": "constructor", "idx": 75098, "Desc": ""}{"node_name": "SynthTreeUI()", "type": "constructor", "idx": 75111, "Desc": ""}{"node_name": "SynthViewportUI()", "type": "constructor", "idx": 75134, "Desc": ""}{"node_name": "TabbedPaneUI()", "type": "constructor", "idx": 75162, "Desc": ""}{"node_name": "TableHeaderUI()", "type": "constructor", "idx": 75173, "Desc": ""}{"node_name": "TableUI()", "type": "constructor", "idx": 75175, "Desc": ""}{"node_name": "TextUI()", "type": "constructor", "idx": 75177, "Desc": ""}{"node_name": "ToolBarUI()", "type": "constructor", "idx": 75210, "Desc": ""}{"node_name": "ToolTipUI()", "type": "constructor", "idx": 75212, "Desc": ""}{"node_name": "TreeUI()", "type": "constructor", "idx": 75214, "Desc": ""}{"node_name": "ViewportUI()", "type": "constructor", "idx": 75243, "Desc": ""}{"node_name": "Popup(java.awt.Component,java.awt.Component,int,int)", "type": "constructor", "idx": 75245, "Desc": "creates a popup for the component owner containing the component contents . owner is used to determine which window the new popup will parent the component the popup creates to . a null owner implies there is no valid parent . x and y specify the preferred initial location to place the popup at . based on screen size , or other paramaters , the popup may not display at x and y ."}{"node_name": "Popup()", "type": "constructor", "idx": 75250, "Desc": "creates a popup . this is provided for subclasses ."}{"node_name": "PopupFactory()", "type": "constructor", "idx": 75254, "Desc": ""}{"node_name": "AccessibleProgressMonitor()", "type": "constructor", "idx": 75270, "Desc": "accessibleprogressmonitor constructor"}{"node_name": "ProgressMonitor(java.awt.Component,java.lang.Object,java.lang.String,int,int)", "type": "constructor", "idx": 75310, "Desc": "constructs a graphic object that shows progress , typically by filling in a rectangular bar as the process nears completion ."}{"node_name": "ProgressMonitorInputStream(java.awt.Component,java.lang.Object,java.io.InputStream)", "type": "constructor", "idx": 75337, "Desc": "constructs an object to monitor the progress of an input stream ."}{"node_name": "RepaintManager()", "type": "constructor", "idx": 75359, "Desc": "create a new repaintmanager instance . you rarely call <init>() . directly . to get the default repaintmanager , use repaintmanager.currentmanager ( jcomponent ) ( normally \" this \") ."}{"node_name": "Entry()", "type": "constructor", "idx": 75423, "Desc": "creates an entry ."}{"node_name": "RowFilter()", "type": "constructor", "idx": 75432, "Desc": ""}{"node_name": "RowSorter()", "type": "constructor", "idx": 75453, "Desc": "creates a rowsorter ."}{"node_name": "SortKey(int,javax.swing.SortOrder)", "type": "constructor", "idx": 75489, "Desc": "creates a sortkey for the specified column with the specified sort order ."}{"node_name": "ScrollPaneLayout()", "type": "constructor", "idx": 75543, "Desc": ""}{"node_name": "UIResource()", "type": "constructor", "idx": 75574, "Desc": ""}{"node_name": "SizeRequirements()", "type": "constructor", "idx": 75590, "Desc": "creates a sizerequirements object with the minimum , preferred , and maximum sizes set to zero and an alignment value of 0.5 ( centered ) ."}{"node_name": "SizeRequirements(int,int,int,float)", "type": "constructor", "idx": 75591, "Desc": "creates a sizerequirements object with the specified minimum , preferred , and maximum sizes and the specified alignment ."}{"node_name": "SizeSequence()", "type": "constructor", "idx": 75631, "Desc": "creates a new sizesequence object that contains no entries . to add entries , you can use insertentries or setsizes ."}{"node_name": "SizeSequence(int)", "type": "constructor", "idx": 75632, "Desc": "creates a new sizesequence object that contains the specified number of entries , all initialized to have size 0 ."}{"node_name": "SizeSequence(int,int)", "type": "constructor", "idx": 75634, "Desc": "creates a new sizesequence object that contains the specified number of entries , all initialized to have size value ."}{"node_name": "SizeSequence(int[])", "type": "constructor", "idx": 75637, "Desc": "creates a new sizesequence object that contains the specified sizes ."}{"node_name": "SortingFocusTraversalPolicy()", "type": "constructor", "idx": 75659, "Desc": "constructs a sortingfocustraversalpolicy without a comparator . subclasses must set the comparator using setcomparator before installing this focustraversalpolicy on a focus cycle root or keyboardfocusmanager ."}{"node_name": "SortingFocusTraversalPolicy(java.util.Comparator)", "type": "constructor", "idx": 75660, "Desc": "constructs a sortingfocustraversalpolicy with the specified comparator ."}{"node_name": "SpinnerDateModel(java.util.Date,java.lang.Comparable,java.lang.Comparable,int)", "type": "constructor", "idx": 75687, "Desc": "creates a spinnerdatemodel that represents a sequence of dates between start and end . the nextvalue and previousvalue methods compute elements of the sequence by advancing or reversing the current date value by the calendarfield time unit . for a precise description of what it means to increment or decrement a calendar field , see the add method in java.util.calendar . the start and end parameters can be null to indicate that the range doesn't have an upper or lower bound . if value or calendarfield is null , or if both start and end are specified and minimum > maximum then an illegalargumentexception is thrown . similarly if ( minimum <= value <= maximum ) is false , an illegalargumentexception is thrown ."}{"node_name": "SpinnerDateModel()", "type": "constructor", "idx": 75692, "Desc": "constructs a spinnerdatemodel whose initial value is the current date , calendarfield is equal to calendar.day_of_month , and for which there are no start / end limits ."}{"node_name": "SpinnerListModel(java.util.List)", "type": "constructor", "idx": 75709, "Desc": "constructs a spinnermodel whose sequence of values is defined by the specified list . the initial value ( current element ) of the model will be values.get ( 0 ) . if values is null or has zero size , an illegalarugmentexception is thrown ."}{"node_name": "SpinnerListModel(java.lang.Object[])", "type": "constructor", "idx": 75711, "Desc": "constructs a spinnermodel whose sequence of values is defined by the specified array . the initial value of the model will be values [ 0 ] . if values is null or has zero length , an illegalargumentexception is thrown ."}{"node_name": "SpinnerListModel()", "type": "constructor", "idx": 75713, "Desc": "constructs an effectively empty spinnerlistmodel . the model's list will contain a single \" empty \" string element ."}{"node_name": "SpinnerNumberModel(java.lang.Number,java.lang.Comparable,java.lang.Comparable,java.lang.Number)", "type": "constructor", "idx": 75733, "Desc": "constructs a spinnermodel that represents a closed sequence of numbers from minimum to maximum . the nextvalue and previousvalue methods compute elements of the sequence by adding or subtracting stepsize respectively . all of the parameters must be mutually comparable , value and stepsize must be instances of integer long , float , or double . the minimum and maximum parameters can be null to indicate that the range doesn't have an upper or lower bound . if value or stepsize is null , or if both minimum and maximum are specified and minimum > maximum then an illegalargumentexception is thrown . similarly if ( minimum <= value <= maximum ) is false , an illegalargumentexception is thrown ."}{"node_name": "SpinnerNumberModel(int,int,int,int)", "type": "constructor", "idx": 75738, "Desc": "constructs a spinnernumbermodel with the specified value , minimum / maximum bounds , and stepsize ."}{"node_name": "SpinnerNumberModel(double,double,double,double)", "type": "constructor", "idx": 75743, "Desc": "constructs a spinnernumbermodel with the specified value , minimum / maximum bounds , and stepsize ."}{"node_name": "SpinnerNumberModel()", "type": "constructor", "idx": 75748, "Desc": "constructs a spinnernumbermodel with no minimum or maximum value , stepsize equal to one , and an initial value of zero ."}{"node_name": "Spring()", "type": "constructor", "idx": 75766, "Desc": "used by factory methods to create a spring ."}{"node_name": "Constraints()", "type": "constructor", "idx": 75795, "Desc": "creates an empty constraints object ."}{"node_name": "Constraints(javax.swing.Spring,javax.swing.Spring)", "type": "constructor", "idx": 75796, "Desc": "creates a constraints object with the specified values for its x and y properties . the height and width springs have null values ."}{"node_name": "Constraints(javax.swing.Spring,javax.swing.Spring,javax.swing.Spring,javax.swing.Spring)", "type": "constructor", "idx": 75799, "Desc": "creates a constraints object with the specified values for its x , y , width , and height properties . note : if the springlayout class encounters null values in the constraints object of a given component , it replaces them with suitable defaults ."}{"node_name": "Constraints(java.awt.Component)", "type": "constructor", "idx": 75804, "Desc": "creates a constraints object with suitable x , y , width and height springs for component , c . the x and y springs are constant springs initialised with the component's location at the time this method is called . the width and height springs are special springs , created by the spring.width() and spring.height() methods , which track the size characteristics of the component when they change ."}{"node_name": "SpringLayout()", "type": "constructor", "idx": 75833, "Desc": "constructs a new springlayout ."}{"node_name": "SwingWorker()", "type": "constructor", "idx": 76043, "Desc": "constructs this swingworker ."}{"node_name": "AbstractTableModel()", "type": "constructor", "idx": 76075, "Desc": ""}{"node_name": "DefaultTableCellRenderer()", "type": "constructor", "idx": 76114, "Desc": "creates a default table cell renderer ."}{"node_name": "UIResource()", "type": "constructor", "idx": 76151, "Desc": ""}{"node_name": "DefaultTableColumnModel()", "type": "constructor", "idx": 76160, "Desc": "creates a default table column model ."}{"node_name": "DefaultTableModel()", "type": "constructor", "idx": 76213, "Desc": "constructs a default defaulttablemodel which is a table of zero columns and zero rows ."}{"node_name": "DefaultTableModel(int,int)", "type": "constructor", "idx": 76214, "Desc": "constructs a defaulttablemodel with rowcount and columncount of null object values ."}{"node_name": "DefaultTableModel(java.util.Vector,int)", "type": "constructor", "idx": 76217, "Desc": "constructs a defaulttablemodel with as many columns as there are elements in columnnames and rowcount of null object values . each column's name will be taken from the columnnames vector ."}{"node_name": "DefaultTableModel(java.lang.Object[],int)", "type": "constructor", "idx": 76220, "Desc": "constructs a defaulttablemodel with as many columns as there are elements in columnnames and rowcount of null object values . each column's name will be taken from the columnnames array ."}{"node_name": "DefaultTableModel(java.util.Vector,java.util.Vector)", "type": "constructor", "idx": 76223, "Desc": "constructs a defaulttablemodel and initializes the table by passing data and columnnames to the setdatavector method ."}{"node_name": "DefaultTableModel(java.lang.Object[][],java.lang.Object[])", "type": "constructor", "idx": 76226, "Desc": "constructs a defaulttablemodel and initializes the table by passing data and columnnames to the setdatavector method . the first index in the object [ ] [ ] array is the row index and the second is the column index ."}{"node_name": "AccessibleJTableHeaderEntry(int,javax.swing.table.JTableHeader,javax.swing.JTable)", "type": "constructor", "idx": 76295, "Desc": "constructs an accessibljtableheaaderentry"}{"node_name": "AccessibleJTableHeader()", "type": "constructor", "idx": 76302, "Desc": ""}{"node_name": "JTableHeader()", "type": "constructor", "idx": 76318, "Desc": "constructs a jtableheader with a default tablecolumnmodel ."}{"node_name": "JTableHeader(javax.swing.table.TableColumnModel)", "type": "constructor", "idx": 76319, "Desc": "constructs a jtableheader which is initialized with cm as the column model . if cm is null this method will initialize the table header with a default tablecolumnmodel ."}{"node_name": "TableColumn()", "type": "constructor", "idx": 76406, "Desc": "cover method , using a default model index of 0 , default width of 75 , a null renderer and a null editor . this method is intended for serialization ."}{"node_name": "TableColumn(int)", "type": "constructor", "idx": 76407, "Desc": "cover method , using a default width of 75 , a null renderer and a null editor ."}{"node_name": "TableColumn(int,int)", "type": "constructor", "idx": 76409, "Desc": "cover method , using a null renderer and a null editor ."}{"node_name": "TableColumn(int,int,javax.swing.table.TableCellRenderer,javax.swing.table.TableCellEditor)", "type": "constructor", "idx": 76412, "Desc": "creates and initializes an instance of tablecolumn with the specified model index , width , cell renderer , and cell editor ; all tablecolumn constructors delegate to this one . the value of width is used for both the initial and preferred width ; if width is negative , they're set to 0 . the minimum width is set to 15 unless the initial width is less , in which case the minimum width is set to the initial width . when the cellrenderer or celleditor parameter is null , a default value provided by the jtable getdefaultrenderer or getdefaulteditor method , respectively , is used to provide defaults based on the type of the data in this column . this column-centric rendering strategy can be circumvented by overriding the getcellrenderer methods in jtable ."}{"node_name": "TableRowSorter()", "type": "constructor", "idx": 76511, "Desc": "creates a tablerowsorter with an empty model ."}{"node_name": "TableRowSorter(javax.swing.table.TableModel)", "type": "constructor", "idx": 76512, "Desc": "creates a tablerowsorter using model as the underlying tablemodel ."}{"node_name": "TableStringConverter()", "type": "constructor", "idx": 76524, "Desc": ""}{"node_name": "AbstractElement(javax.swing.text.Element,javax.swing.text.AttributeSet)", "type": "constructor", "idx": 76530, "Desc": "creates a new abstractelement ."}{"node_name": "BranchElement(javax.swing.text.Element,javax.swing.text.AttributeSet)", "type": "constructor", "idx": 76605, "Desc": "constructs a composite element that initially contains no children ."}{"node_name": "DefaultDocumentEvent(int,int,javax.swing.event.DocumentEvent.EventType)", "type": "constructor", "idx": 76644, "Desc": "constructs a change record ."}{"node_name": "ElementEdit(javax.swing.text.Element,int,javax.swing.text.Element[],javax.swing.text.Element[])", "type": "constructor", "idx": 76664, "Desc": "constructs an edit record . this does not modify the element so it can safely be used to catch up a view to the current model state for views that just attached to a model ."}{"node_name": "AbstractDocument(javax.swing.text.AbstractDocument.Content)", "type": "constructor", "idx": 76683, "Desc": "constructs a new abstractdocument , wrapped around some specified content storage mechanism ."}{"node_name": "AbstractDocument(javax.swing.text.AbstractDocument.Content,javax.swing.text.AbstractDocument.AttributeContext)", "type": "constructor", "idx": 76685, "Desc": "constructs a new abstractdocument , wrapped around some specified content storage mechanism ."}{"node_name": "LeafElement(javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)", "type": "constructor", "idx": 76778, "Desc": "constructs an element that represents content within the document ( has no children ) ."}{"node_name": "AbstractWriter(java.io.Writer,javax.swing.text.Document)", "type": "constructor", "idx": 76797, "Desc": "creates a new abstractwriter . initializes the elementiterator with the default root of the document ."}{"node_name": "AbstractWriter(java.io.Writer,javax.swing.text.Document,int,int)", "type": "constructor", "idx": 76800, "Desc": "creates a new abstractwriter . initializes the elementiterator with the element passed in ."}{"node_name": "AbstractWriter(java.io.Writer,javax.swing.text.Element)", "type": "constructor", "idx": 76805, "Desc": "creates a new abstractwriter . initializes the elementiterator with the element passed in ."}{"node_name": "AbstractWriter(java.io.Writer,javax.swing.text.Element,int,int)", "type": "constructor", "idx": 76808, "Desc": "creates a new abstractwriter . initializes the elementiterator with the element passed in ."}{"node_name": "ChildLocator()", "type": "constructor", "idx": 76864, "Desc": "construct a child locator ."}{"node_name": "ChildState(javax.swing.text.View)", "type": "constructor", "idx": 76883, "Desc": "construct a child status . this needs to start out as fairly large so we don't falsely begin with the idea that all of the children are visible ."}{"node_name": "AsyncBoxView(javax.swing.text.Element,int)", "type": "constructor", "idx": 76899, "Desc": "construct a box view that does asynchronous layout ."}{"node_name": "BadLocationException(java.lang.String,int)", "type": "constructor", "idx": 77010, "Desc": "creates a new badlocationexception object ."}{"node_name": "BlockView(javax.swing.text.Element,int)", "type": "constructor", "idx": 77015, "Desc": "creates a new view that represents an html box . this can be used for a number of elements ."}{"node_name": "BoxView(javax.swing.text.Element,int)", "type": "constructor", "idx": 77048, "Desc": "constructs a boxview ."}{"node_name": "ChangedCharSetException(java.lang.String,boolean)", "type": "constructor", "idx": 77187, "Desc": "constructs a changedcharsetexception ."}{"node_name": "ComponentView(javax.swing.text.Element)", "type": "constructor", "idx": 77193, "Desc": "creates a new componentview object ."}{"node_name": "CompositeView(javax.swing.text.Element)", "type": "constructor", "idx": 77220, "Desc": "constructs a compositeview for the given element ."}{"node_name": "CSS()", "type": "constructor", "idx": 77374, "Desc": "constructs a css object ."}{"node_name": "DateFormatter()", "type": "constructor", "idx": 77379, "Desc": "this is shorthand for new dateformatter ( dateformat.getdateinstance() ) ."}{"node_name": "DateFormatter(java.text.DateFormat)", "type": "constructor", "idx": 77380, "Desc": "returns a dateformatter configured with the specified format instance ."}{"node_name": "DefaultCaret()", "type": "constructor", "idx": 77390, "Desc": "constructs a default caret ."}{"node_name": "BeepAction()", "type": "constructor", "idx": 77467, "Desc": "create this object with the appropriate identifier ."}{"node_name": "CopyAction()", "type": "constructor", "idx": 77471, "Desc": "create this object with the appropriate identifier ."}{"node_name": "CutAction()", "type": "constructor", "idx": 77475, "Desc": "create this object with the appropriate identifier ."}{"node_name": "DefaultKeyTypedAction()", "type": "constructor", "idx": 77479, "Desc": "creates this object with the appropriate identifier ."}{"node_name": "InsertBreakAction()", "type": "constructor", "idx": 77483, "Desc": "creates this object with the appropriate identifier ."}{"node_name": "InsertContentAction()", "type": "constructor", "idx": 77487, "Desc": "creates this object with the appropriate identifier ."}{"node_name": "InsertTabAction()", "type": "constructor", "idx": 77491, "Desc": "creates this object with the appropriate identifier ."}{"node_name": "DefaultEditorKit()", "type": "constructor", "idx": 77544, "Desc": "default constructor for defaulteditorkit"}{"node_name": "PasteAction()", "type": "constructor", "idx": 77569, "Desc": "create this object with the appropriate identifier ."}{"node_name": "DefaultFormatter()", "type": "constructor", "idx": 77573, "Desc": "creates a defaultformatter ."}{"node_name": "DefaultFormatterFactory()", "type": "constructor", "idx": 77596, "Desc": "constructs a defaultformatterfactory ."}{"node_name": "DefaultFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatter)", "type": "constructor", "idx": 77597, "Desc": "creates a defaultformatterfactory with the specified jformattedtextfield.abstractformatter ."}{"node_name": "DefaultFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatter,javax.swing.JFormattedTextField.AbstractFormatter)", "type": "constructor", "idx": 77599, "Desc": "creates a defaultformatterfactory with the specified jformattedtextfield.abstractformatters ."}{"node_name": "DefaultFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatter,javax.swing.JFormattedTextField.AbstractFormatter,javax.swing.JFormattedTextField.AbstractFormatter)", "type": "constructor", "idx": 77602, "Desc": "creates a defaultformatterfactory with the specified jformattedtextfield.abstractformatters ."}{"node_name": "DefaultFormatterFactory(javax.swing.JFormattedTextField.AbstractFormatter,javax.swing.JFormattedTextField.AbstractFormatter,javax.swing.JFormattedTextField.AbstractFormatter,javax.swing.JFormattedTextField.AbstractFormatter)", "type": "constructor", "idx": 77606, "Desc": "creates a defaultformatterfactory with the specified jformattedtextfield.abstractformatters ."}{"node_name": "DefaultHighlightPainter(java.awt.Color)", "type": "constructor", "idx": 77626, "Desc": "constructs a new highlight painter . if c is null , the jtextcomponent will be queried for its selection color ."}{"node_name": "DefaultHighlighter()", "type": "constructor", "idx": 77644, "Desc": "creates a new defaulthighlighther object ."}{"node_name": "AttributeUndoableEdit(javax.swing.text.Element,javax.swing.text.AttributeSet,boolean)", "type": "constructor", "idx": 77678, "Desc": "constructs an attributeundoableedit ."}{"node_name": "ElementBuffer(javax.swing.text.Element)", "type": "constructor", "idx": 77685, "Desc": "creates a new elementbuffer ."}{"node_name": "ElementSpec(javax.swing.text.AttributeSet,short)", "type": "constructor", "idx": 77716, "Desc": "constructor useful for markup when the markup will not be stored in the document ."}{"node_name": "ElementSpec(javax.swing.text.AttributeSet,short,int)", "type": "constructor", "idx": 77719, "Desc": "constructor for parsing inside the document when the data has already been added , but len information is needed ."}{"node_name": "ElementSpec(javax.swing.text.AttributeSet,short,char[],int,int)", "type": "constructor", "idx": 77723, "Desc": "constructor for creating a spec externally for batch input of content and markup into the document ."}{"node_name": "DefaultStyledDocument(javax.swing.text.AbstractDocument.Content,javax.swing.text.StyleContext)", "type": "constructor", "idx": 77743, "Desc": "constructs a styled document ."}{"node_name": "DefaultStyledDocument(javax.swing.text.StyleContext)", "type": "constructor", "idx": 77746, "Desc": "constructs a styled document with the default content storage implementation and a shared set of styles ."}{"node_name": "DefaultStyledDocument()", "type": "constructor", "idx": 77748, "Desc": "constructs a default styled document . this buffers input content by a size of buffer_size_default and has a style context that is scoped by the lifetime of the document and is not shared with other documents ."}{"node_name": "SectionElement()", "type": "constructor", "idx": 77803, "Desc": "creates a new sectionelement ."}{"node_name": "FilterBypass()", "type": "constructor", "idx": 77846, "Desc": ""}{"node_name": "DocumentFilter()", "type": "constructor", "idx": 77861, "Desc": ""}{"node_name": "EditorKit()", "type": "constructor", "idx": 77878, "Desc": "construct an editorkit ."}{"node_name": "ElementIterator(javax.swing.text.Document)", "type": "constructor", "idx": 77921, "Desc": "creates a new elementiterator . the root element is taken to get the default root element of the document ."}{"node_name": "ElementIterator(javax.swing.text.Element)", "type": "constructor", "idx": 77923, "Desc": "creates a new elementiterator ."}{"node_name": "FieldView(javax.swing.text.Element)", "type": "constructor", "idx": 77932, "Desc": "constructs a new fieldview wrapped on an element ."}{"node_name": "FlowStrategy()", "type": "constructor", "idx": 77962, "Desc": ""}{"node_name": "FlowView(javax.swing.text.Element,int)", "type": "constructor", "idx": 77997, "Desc": "constructs a flowview for the given element ."}{"node_name": "FormView(javax.swing.text.Element)", "type": "constructor", "idx": 78036, "Desc": "creates a new formview object ."}{"node_name": "MouseEventListener()", "type": "constructor", "idx": 78048, "Desc": ""}{"node_name": "GapContent()", "type": "constructor", "idx": 78050, "Desc": "creates a new gapcontent object . initial size defaults to 10 ."}{"node_name": "GapContent(int)", "type": "constructor", "idx": 78051, "Desc": "creates a new gapcontent object , with the initial size specified . the initial size will not be allowed to go below 2 , to give room for the implied break and the gap ."}{"node_name": "GlyphPainter()", "type": "constructor", "idx": 78092, "Desc": ""}{"node_name": "GlyphView(javax.swing.text.Element)", "type": "constructor", "idx": 78139, "Desc": "constructs a new view wrapped on an element ."}{"node_name": "HTML()", "type": "constructor", "idx": 78324, "Desc": ""}{"node_name": "Tag()", "type": "constructor", "idx": 78412, "Desc": ""}{"node_name": "Tag(java.lang.String)", "type": "constructor", "idx": 78413, "Desc": "creates a new tag with the specified id , and with causesbreak and isblock set to false ."}{"node_name": "Tag(java.lang.String,boolean,boolean)", "type": "constructor", "idx": 78415, "Desc": "creates a new tag with the specified id ; causesbreak and isblock are defined by the user ."}{"node_name": "UnknownTag(java.lang.String)", "type": "constructor", "idx": 78424, "Desc": "creates a new unknowntag with the specified id ."}{"node_name": "BlockElement(javax.swing.text.Element,javax.swing.text.AttributeSet)", "type": "constructor", "idx": 78430, "Desc": "constructs a composite element that initially contains no children ."}{"node_name": "BlockAction()", "type": "constructor", "idx": 78436, "Desc": ""}{"node_name": "CharacterAction()", "type": "constructor", "idx": 78438, "Desc": ""}{"node_name": "FormAction()", "type": "constructor", "idx": 78440, "Desc": ""}{"node_name": "HiddenAction()", "type": "constructor", "idx": 78442, "Desc": ""}{"node_name": "IsindexAction()", "type": "constructor", "idx": 78444, "Desc": ""}{"node_name": "HTMLReader(int)", "type": "constructor", "idx": 78448, "Desc": "constructs an htmlreader using default pop and push depth and no tag to insert ."}{"node_name": "HTMLReader(int,int,int,javax.swing.text.html.HTML.Tag)", "type": "constructor", "idx": 78450, "Desc": "constructs an htmlreader ."}{"node_name": "ParagraphAction()", "type": "constructor", "idx": 78499, "Desc": ""}{"node_name": "PreAction()", "type": "constructor", "idx": 78501, "Desc": ""}{"node_name": "SpecialAction()", "type": "constructor", "idx": 78503, "Desc": ""}{"node_name": "TagAction()", "type": "constructor", "idx": 78505, "Desc": ""}{"node_name": "Iterator()", "type": "constructor", "idx": 78512, "Desc": ""}{"node_name": "HTMLDocument()", "type": "constructor", "idx": 78521, "Desc": "constructs an html document using the default buffer size and a default stylesheet . this is a convenience method for <init>() htmldocument ( content , stylesheet ) ."}{"node_name": "HTMLDocument(javax.swing.text.html.StyleSheet)", "type": "constructor", "idx": 78522, "Desc": "constructs an html document with the default content storage implementation and the specified style / attribute storage mechanism . this is a convenience method for <init>(javax.swing.text.html.StyleSheet) htmldocument ( content , stylesheet ) ."}{"node_name": "HTMLDocument(javax.swing.text.AbstractDocument.Content,javax.swing.text.html.StyleSheet)", "type": "constructor", "idx": 78524, "Desc": "constructs an html document with the given content storage implementation and the given style / attribute storage mechanism ."}{"node_name": "RunElement(javax.swing.text.Element,javax.swing.text.AttributeSet,int,int)", "type": "constructor", "idx": 78602, "Desc": "constructs an element that represents content within the document ( has no children ) ."}{"node_name": "HTMLFactory()", "type": "constructor", "idx": 78610, "Desc": ""}{"node_name": "HTMLTextAction(java.lang.String)", "type": "constructor", "idx": 78614, "Desc": "creates a new htmltextaction from a string action name ."}{"node_name": "InsertHTMLTextAction(java.lang.String,java.lang.String,javax.swing.text.html.HTML.Tag,javax.swing.text.html.HTML.Tag)", "type": "constructor", "idx": 78637, "Desc": "creates a new inserthtmltextaction ."}{"node_name": "InsertHTMLTextAction(java.lang.String,java.lang.String,javax.swing.text.html.HTML.Tag,javax.swing.text.html.HTML.Tag,javax.swing.text.html.HTML.Tag,javax.swing.text.html.HTML.Tag)", "type": "constructor", "idx": 78642, "Desc": "creates a new inserthtmltextaction ."}{"node_name": "HTMLEditorKit()", "type": "constructor", "idx": 78681, "Desc": "constructs an htmleditorkit , creates a stylecontext , and loads the style sheet ."}{"node_name": "LinkController()", "type": "constructor", "idx": 78726, "Desc": ""}{"node_name": "Parser()", "type": "constructor", "idx": 78733, "Desc": ""}{"node_name": "ParserCallback()", "type": "constructor", "idx": 78740, "Desc": ""}{"node_name": "HTMLFrameHyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String)", "type": "constructor", "idx": 78765, "Desc": "creates a new object representing a html frame hypertext link event ."}{"node_name": "HTMLFrameHyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String,java.lang.String)", "type": "constructor", "idx": 78770, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "HTMLFrameHyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,javax.swing.text.Element,java.lang.String)", "type": "constructor", "idx": 78776, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "HTMLFrameHyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String,javax.swing.text.Element,java.lang.String)", "type": "constructor", "idx": 78782, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "HTMLFrameHyperlinkEvent(java.lang.Object,javax.swing.event.HyperlinkEvent.EventType,java.net.URL,java.lang.String,javax.swing.text.Element,java.awt.event.InputEvent,java.lang.String)", "type": "constructor", "idx": 78789, "Desc": "creates a new object representing a hypertext link event ."}{"node_name": "HTMLWriter(java.io.Writer,javax.swing.text.html.HTMLDocument)", "type": "constructor", "idx": 78799, "Desc": "creates a new htmlwriter ."}{"node_name": "HTMLWriter(java.io.Writer,javax.swing.text.html.HTMLDocument,int,int)", "type": "constructor", "idx": 78802, "Desc": "creates a new htmlwriter ."}{"node_name": "IconView(javax.swing.text.Element)", "type": "constructor", "idx": 78843, "Desc": "creates a new icon view that represents an element ."}{"node_name": "ImageView(javax.swing.text.Element)", "type": "constructor", "idx": 78862, "Desc": "creates a new view that represents an img element ."}{"node_name": "InlineView(javax.swing.text.Element)", "type": "constructor", "idx": 78905, "Desc": "constructs a new view wrapped on an element ."}{"node_name": "InternationalFormatter()", "type": "constructor", "idx": 78932, "Desc": "creates an internationalformatter with no format specified ."}{"node_name": "InternationalFormatter(java.text.Format)", "type": "constructor", "idx": 78933, "Desc": "creates an internationalformatter with the specified format instance ."}{"node_name": "AccessibleJTextComponent()", "type": "constructor", "idx": 78955, "Desc": "constructs an accessiblejtextcomponent . adds a listener to track caret change ."}{"node_name": "JTextComponent()", "type": "constructor", "idx": 79039, "Desc": "creates a new jtextcomponent . listeners for caret events are established , and the pluggable ui installed . the component is marked as editable . no layout manager is used , because layout is managed by the view subsystem of text . the document model is set to null ."}{"node_name": "KeyBinding(javax.swing.KeyStroke,java.lang.String)", "type": "constructor", "idx": 79177, "Desc": "creates a new key binding ."}{"node_name": "LabelView(javax.swing.text.Element)", "type": "constructor", "idx": 79203, "Desc": "constructs a new view wrapped on an element ."}{"node_name": "LayeredHighlighter()", "type": "constructor", "idx": 79228, "Desc": ""}{"node_name": "LayerPainter()", "type": "constructor", "idx": 79237, "Desc": ""}{"node_name": "LayoutQueue()", "type": "constructor", "idx": 79246, "Desc": "construct a layout queue ."}{"node_name": "ListView(javax.swing.text.Element)", "type": "constructor", "idx": 79254, "Desc": "creates a new view that represents a list element ."}{"node_name": "MaskFormatter()", "type": "constructor", "idx": 79266, "Desc": "creates a maskformatter with no mask ."}{"node_name": "MaskFormatter(java.lang.String)", "type": "constructor", "idx": 79267, "Desc": "creates a maskformatter with the specified mask . a parseexception will be thrown if mask is an invalid mask ."}{"node_name": "MinimalHTMLWriter(java.io.Writer,javax.swing.text.StyledDocument)", "type": "constructor", "idx": 79294, "Desc": "creates a new minimalhtmlwriter ."}{"node_name": "MinimalHTMLWriter(java.io.Writer,javax.swing.text.StyledDocument,int,int)", "type": "constructor", "idx": 79297, "Desc": "creates a new minimalhtmlwriter ."}{"node_name": "FilterBypass()", "type": "constructor", "idx": 79351, "Desc": ""}{"node_name": "NavigationFilter()", "type": "constructor", "idx": 79360, "Desc": ""}{"node_name": "NumberFormatter()", "type": "constructor", "idx": 79376, "Desc": "creates a numberformatter with the a default numberformat instance obtained from numberformat.getnumberinstance() ."}{"node_name": "NumberFormatter(java.text.NumberFormat)", "type": "constructor", "idx": 79377, "Desc": "creates a numberformatter with the specified format instance ."}{"node_name": "ObjectView(javax.swing.text.Element)", "type": "constructor", "idx": 79382, "Desc": "creates a new objectview object ."}{"node_name": "Option(javax.swing.text.AttributeSet)", "type": "constructor", "idx": 79386, "Desc": "creates a new option object ."}{"node_name": "ParagraphView(javax.swing.text.Element)", "type": "constructor", "idx": 79398, "Desc": "constructs a paragraphview for the given element ."}{"node_name": "AttributeList(java.lang.String)", "type": "constructor", "idx": 79425, "Desc": "create an attribute list element ."}{"node_name": "AttributeList(java.lang.String,int,int,java.lang.String,java.util.Vector,javax.swing.text.html.parser.AttributeList)", "type": "constructor", "idx": 79427, "Desc": "create an attribute list element ."}{"node_name": "ContentModel()", "type": "constructor", "idx": 79449, "Desc": "creates contentmodel"}{"node_name": "ContentModel(javax.swing.text.html.parser.Element)", "type": "constructor", "idx": 79450, "Desc": "create a content model for an element ."}{"node_name": "ContentModel(int,javax.swing.text.html.parser.ContentModel)", "type": "constructor", "idx": 79452, "Desc": "create a content model of a particular type ."}{"node_name": "ContentModel(int,java.lang.Object,javax.swing.text.html.parser.ContentModel)", "type": "constructor", "idx": 79455, "Desc": "create a content model of a particular type ."}{"node_name": "DocumentParser(javax.swing.text.html.parser.DTD)", "type": "constructor", "idx": 79467, "Desc": "creates document parser with the specified dtd ."}{"node_name": "DTD(java.lang.String)", "type": "constructor", "idx": 79498, "Desc": "creates a new dtd with the specified name ."}{"node_name": "Entity(java.lang.String,int,char[])", "type": "constructor", "idx": 79627, "Desc": "creates an entity ."}{"node_name": "Parser(javax.swing.text.html.parser.DTD)", "type": "constructor", "idx": 79642, "Desc": "creates parser with the specified dtd ."}{"node_name": "ParserDelegator()", "type": "constructor", "idx": 79695, "Desc": "creates parserdelegator with default dtd ."}{"node_name": "TagElement(javax.swing.text.html.parser.Element)", "type": "constructor", "idx": 79701, "Desc": "creates a generic html tagelement class with fictional equals to false ."}{"node_name": "TagElement(javax.swing.text.html.parser.Element,boolean)", "type": "constructor", "idx": 79703, "Desc": "creates a generic html tagelement class ."}{"node_name": "PasswordView(javax.swing.text.Element)", "type": "constructor", "idx": 79712, "Desc": "constructs a new view wrapped on an element ."}{"node_name": "PlainDocument()", "type": "constructor", "idx": 79733, "Desc": "constructs a plain text document . a default model using gapcontent is constructed and set ."}{"node_name": "PlainDocument(javax.swing.text.AbstractDocument.Content)", "type": "constructor", "idx": 79734, "Desc": "constructs a plain text document . a default root element is created , and the tab size set to 8 ."}{"node_name": "PlainView(javax.swing.text.Element)", "type": "constructor", "idx": 79751, "Desc": "constructs a new plainview wrapped on an element ."}{"node_name": "RTFEditorKit()", "type": "constructor", "idx": 79824, "Desc": "constructs an rtfeditorkit ."}{"node_name": "Segment()", "type": "constructor", "idx": 79848, "Desc": "creates a new segment ."}{"node_name": "Segment(char[],int,int)", "type": "constructor", "idx": 79849, "Desc": "creates a new segment referring to an existing array ."}{"node_name": "SimpleAttributeSet()", "type": "constructor", "idx": 79876, "Desc": "creates a new attribute set ."}{"node_name": "SimpleAttributeSet(javax.swing.text.AttributeSet)", "type": "constructor", "idx": 79877, "Desc": "creates a new attribute set based on a supplied set of attributes ."}{"node_name": "StringContent()", "type": "constructor", "idx": 79914, "Desc": "creates a new stringcontent object . initial size defaults to 10 ."}{"node_name": "StringContent(int)", "type": "constructor", "idx": 79915, "Desc": "creates a new stringcontent object , with the initial size specified . if the length is < 1 , a size of 1 is used ."}{"node_name": "StyleContext()", "type": "constructor", "idx": 80092, "Desc": "creates a new stylecontext object ."}{"node_name": "NamedStyle(java.lang.String,javax.swing.text.Style)", "type": "constructor", "idx": 80165, "Desc": "creates a new named style ."}{"node_name": "NamedStyle(javax.swing.text.Style)", "type": "constructor", "idx": 80168, "Desc": "creates a new named style ."}{"node_name": "NamedStyle()", "type": "constructor", "idx": 80170, "Desc": "creates a new named style , with a null name and parent ."}{"node_name": "SmallAttributeSet(java.lang.Object[])", "type": "constructor", "idx": 80212, "Desc": "constructs a smallattributeset ."}{"node_name": "SmallAttributeSet(javax.swing.text.AttributeSet)", "type": "constructor", "idx": 80214, "Desc": "constructs a smallattributeset ."}{"node_name": "AlignmentAction(java.lang.String,int)", "type": "constructor", "idx": 80270, "Desc": "creates a new alignmentaction ."}{"node_name": "BoldAction()", "type": "constructor", "idx": 80276, "Desc": "constructs a new boldaction ."}{"node_name": "FontFamilyAction(java.lang.String,java.lang.String)", "type": "constructor", "idx": 80280, "Desc": "creates a new fontfamilyaction ."}{"node_name": "FontSizeAction(java.lang.String,int)", "type": "constructor", "idx": 80286, "Desc": "creates a new fontsizeaction ."}{"node_name": "ForegroundAction(java.lang.String,java.awt.Color)", "type": "constructor", "idx": 80292, "Desc": "creates a new foregroundaction ."}{"node_name": "ItalicAction()", "type": "constructor", "idx": 80298, "Desc": "constructs a new italicaction ."}{"node_name": "StyledEditorKit()", "type": "constructor", "idx": 80302, "Desc": "creates a new editorkit used for styled documents ."}{"node_name": "StyledTextAction(java.lang.String)", "type": "constructor", "idx": 80317, "Desc": "creates a new styledtextaction from a string action name ."}{"node_name": "UnderlineAction()", "type": "constructor", "idx": 80334, "Desc": "constructs a new underlineaction ."}{"node_name": "StyleSheet()", "type": "constructor", "idx": 80349, "Desc": "construct a stylesheet"}{"node_name": "TableView(javax.swing.text.Element)", "type": "constructor", "idx": 80449, "Desc": "constructs a tableview for the given element ."}{"node_name": "TableRow(javax.swing.text.Element)", "type": "constructor", "idx": 80475, "Desc": "constructs a tableview for the given element ."}{"node_name": "TabSet(javax.swing.text.TabStop[])", "type": "constructor", "idx": 80497, "Desc": "creates and returns an instance of tabset . the array of tabs passed in must be sorted in ascending order ."}{"node_name": "TabStop(float)", "type": "constructor", "idx": 80524, "Desc": "creates a tab at position pos with a default alignment and default leader ."}{"node_name": "TabStop(float,int,int)", "type": "constructor", "idx": 80526, "Desc": "creates a tab with the specified position pos , alignment align and leader leader ."}{"node_name": "TextAction(java.lang.String)", "type": "constructor", "idx": 80537, "Desc": "creates a new jtextaction object ."}{"node_name": "Utilities()", "type": "constructor", "idx": 80546, "Desc": ""}{"node_name": "View(javax.swing.text.Element)", "type": "constructor", "idx": 80611, "Desc": "creates a new view object ."}{"node_name": "WrappedPlainView(javax.swing.text.Element)", "type": "constructor", "idx": 80741, "Desc": "creates a new wrappedplainview . lines will be wrapped on character boundaries ."}{"node_name": "WrappedPlainView(javax.swing.text.Element,boolean)", "type": "constructor", "idx": 80743, "Desc": "creates a new wrappedplainview . lines can be wrapped on either character or word boundaries depending upon the setting of the wordwrap parameter ."}{"node_name": "ZoneView(javax.swing.text.Element,int)", "type": "constructor", "idx": 80799, "Desc": "constructs a zoneview ."}{"node_name": "Timer(int,java.awt.event.ActionListener)", "type": "constructor", "idx": 80835, "Desc": "creates a timer and initializes both the initial delay and between-event delay to delay milliseconds . if delay is less than or equal to zero , the timer fires as soon as it is started . if listener is not null , it's registered as an action listener on the timer ."}{"node_name": "insideTimerAction()", "type": "constructor", "idx": 80870, "Desc": ""}{"node_name": "outsideTimerAction()", "type": "constructor", "idx": 80905, "Desc": ""}{"node_name": "stillInsideTimerAction()", "type": "constructor", "idx": 80907, "Desc": ""}{"node_name": "DropLocation(java.awt.Point)", "type": "constructor", "idx": 80909, "Desc": "constructs a drop location for the given point ."}{"node_name": "TransferHandler(java.lang.String)", "type": "constructor", "idx": 80919, "Desc": "constructs a transfer handler that can transfer a java bean property from one component to another via the clipboard or a drag and drop operation ."}{"node_name": "TransferHandler()", "type": "constructor", "idx": 80921, "Desc": "convenience constructor for subclasses ."}{"node_name": "TransferSupport(java.awt.Component,java.awt.datatransfer.Transferable)", "type": "constructor", "idx": 80960, "Desc": "create a transfersupport with isdrop() false for the given component and transferable ."}{"node_name": "AbstractLayoutCache()", "type": "constructor", "idx": 80983, "Desc": ""}{"node_name": "NodeDimensions()", "type": "constructor", "idx": 81045, "Desc": ""}{"node_name": "DefaultMutableTreeNode()", "type": "constructor", "idx": 81058, "Desc": "creates a tree node that has no parent and no children , but which allows children ."}{"node_name": "DefaultMutableTreeNode(java.lang.Object)", "type": "constructor", "idx": 81059, "Desc": "creates a tree node with no parent , no children , but which allows children , and initializes it with the specified user object ."}{"node_name": "DefaultMutableTreeNode(java.lang.Object,boolean)", "type": "constructor", "idx": 81061, "Desc": "creates a tree node with no parent , no children , initialized with the specified user object , and that allows children only if specified ."}{"node_name": "DefaultTextField(javax.swing.border.Border)", "type": "constructor", "idx": 81138, "Desc": "constructs a defaulttreecelleditor.defaulttextfield object ."}{"node_name": "EditorContainer()", "type": "constructor", "idx": 81145, "Desc": "constructs an editorcontainer object ."}{"node_name": "DefaultTreeCellEditor(javax.swing.JTree,javax.swing.tree.DefaultTreeCellRenderer)", "type": "constructor", "idx": 81165, "Desc": "constructs a defaulttreecelleditor object for a jtree using the specified renderer and a default editor . ( use <init>(javax.swing.JTree,javax.swing.tree.DefaultTreeCellRenderer) for normal editing . )"}{"node_name": "DefaultTreeCellEditor(javax.swing.JTree,javax.swing.tree.DefaultTreeCellRenderer,javax.swing.tree.TreeCellEditor)", "type": "constructor", "idx": 81168, "Desc": "constructs a defaulttreecelleditor object for a jtree using the specified renderer and the specified editor . ( use <init>(javax.swing.JTree,javax.swing.tree.DefaultTreeCellRenderer,javax.swing.tree.TreeCellEditor) for specialized editing . )"}{"node_name": "DefaultTreeCellRenderer()", "type": "constructor", "idx": 81232, "Desc": "creates a defaulttreecellrenderer . icons and text color are determined from the uimanager ."}{"node_name": "DefaultTreeModel(javax.swing.tree.TreeNode)", "type": "constructor", "idx": 81329, "Desc": "creates a tree in which any node can have children ."}{"node_name": "DefaultTreeModel(javax.swing.tree.TreeNode,boolean)", "type": "constructor", "idx": 81331, "Desc": "creates a tree specifying whether any node can have children , or whether only certain nodes can have children ."}{"node_name": "DefaultTreeSelectionModel()", "type": "constructor", "idx": 81419, "Desc": "creates a new instance of defaulttreeselectionmodel that is empty , with a selection mode of discontiguous_tree_selection ."}{"node_name": "ExpandVetoException(javax.swing.event.TreeExpansionEvent)", "type": "constructor", "idx": 81480, "Desc": "constructs an expandvetoexception object with no message ."}{"node_name": "ExpandVetoException(javax.swing.event.TreeExpansionEvent,java.lang.String)", "type": "constructor", "idx": 81482, "Desc": "constructs an expandvetoexception object with the specified message ."}{"node_name": "FixedHeightLayoutCache()", "type": "constructor", "idx": 81486, "Desc": "constructs a fixedheightlayoutcache ."}{"node_name": "TreePath(java.lang.Object[])", "type": "constructor", "idx": 81589, "Desc": "creates a treepath from an array . the array uniquely identifies the path to a node ."}{"node_name": "TreePath(java.lang.Object)", "type": "constructor", "idx": 81591, "Desc": "creates a treepath containing a single element . this is used to construct a treepath identifying the root ."}{"node_name": "TreePath(javax.swing.tree.TreePath,java.lang.Object)", "type": "constructor", "idx": 81593, "Desc": "creates a treepath with the specified parent and element ."}{"node_name": "TreePath(java.lang.Object[],int)", "type": "constructor", "idx": 81596, "Desc": "creates a treepath from an array . the returned treepath represents the elements of the array from 0 to length - 1 . <init>(java.lang.Object[],int) is used internally , and generally not useful outside of subclasses ."}{"node_name": "TreePath()", "type": "constructor", "idx": 81599, "Desc": "creates an empty treepath . this is provided for subclasses that represent paths in a different manner . subclasses that use <init>() must override getlastpathcomponent , and getparentpath ."}{"node_name": "VariableHeightLayoutCache()", "type": "constructor", "idx": 81660, "Desc": "constructs a variableheightlayoutcache ."}{"node_name": "UIDefaults()", "type": "constructor", "idx": 81710, "Desc": "creates an empty defaults table ."}{"node_name": "UIDefaults(int,float)", "type": "constructor", "idx": 81711, "Desc": "creates an empty defaults table with the specified initial capacity and load factor ."}{"node_name": "UIDefaults(java.lang.Object[])", "type": "constructor", "idx": 81714, "Desc": "creates a defaults table initialized with the specified key / value pairs . for example : object [ ] uidefaults = { \" font \" , new font ( \" dialog \" , font.bold , 12 ) , \" color \" , color.red , \" five \" , integer.valueof ( 5 ) } uidefaults mydefaults = new uidefaults ( uidefaults );"}{"node_name": "LazyInputMap(java.lang.Object[])", "type": "constructor", "idx": 81797, "Desc": "constructs a lazyinputmap ."}{"node_name": "ProxyLazyValue(java.lang.String)", "type": "constructor", "idx": 81805, "Desc": "creates a lazyvalue which will construct an instance when asked ."}{"node_name": "ProxyLazyValue(java.lang.String,java.lang.String)", "type": "constructor", "idx": 81807, "Desc": "creates a lazyvalue which will construct an instance when asked ."}{"node_name": "ProxyLazyValue(java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 81810, "Desc": "creates a lazyvalue which will construct an instance when asked ."}{"node_name": "ProxyLazyValue(java.lang.String,java.lang.String,java.lang.Object[])", "type": "constructor", "idx": 81813, "Desc": "creates a lazyvalue which will construct an instance when asked ."}{"node_name": "UIManager()", "type": "constructor", "idx": 81820, "Desc": ""}{"node_name": "LookAndFeelInfo(java.lang.String,java.lang.String)", "type": "constructor", "idx": 81906, "Desc": "constructs a uimanagers lookandfeelinfo object ."}{"node_name": "AbstractUndoableEdit()", "type": "constructor", "idx": 81915, "Desc": "creates an abstractundoableedit which defaults hasbeendone and alive to true ."}{"node_name": "CannotRedoException()", "type": "constructor", "idx": 81931, "Desc": ""}{"node_name": "CannotUndoException()", "type": "constructor", "idx": 81933, "Desc": ""}{"node_name": "CompoundEdit()", "type": "constructor", "idx": 81936, "Desc": "constructs a compoundedit ."}{"node_name": "StateEdit(javax.swing.undo.StateEditable)", "type": "constructor", "idx": 81958, "Desc": "create and return a new stateedit ."}{"node_name": "StateEdit(javax.swing.undo.StateEditable,java.lang.String)", "type": "constructor", "idx": 81960, "Desc": "create and return a new stateedit with a presentation name ."}{"node_name": "UndoableEditSupport()", "type": "constructor", "idx": 81996, "Desc": "constructs an undoableeditsupport object ."}{"node_name": "UndoableEditSupport(java.lang.Object)", "type": "constructor", "idx": 81997, "Desc": "constructs an undoableeditsupport object ."}{"node_name": "UndoManager()", "type": "constructor", "idx": 82014, "Desc": "creates a new undomanager ."}{"node_name": "UnsupportedLookAndFeelException(java.lang.String)", "type": "constructor", "idx": 82045, "Desc": "constructs an unsupportedlookandfeelexception object ."}{"node_name": "ViewportLayout()", "type": "constructor", "idx": 82048, "Desc": ""}{"node_name": "DiagnosticCollector()", "type": "constructor", "idx": 82082, "Desc": ""}{"node_name": "ForwardingFileObject(javax.tools.FileObject)", "type": "constructor", "idx": 82123, "Desc": "creates a new instance of forwardingfileobject ."}{"node_name": "ForwardingJavaFileManager(javax.tools.JavaFileManager)", "type": "constructor", "idx": 82134, "Desc": "creates a new instance of forwardingjavafilemanager ."}{"node_name": "ForwardingJavaFileObject(javax.tools.JavaFileObject)", "type": "constructor", "idx": 82187, "Desc": "creates a new instance of forwardingjavafileobject ."}{"node_name": "SimpleJavaFileObject(java.net.URI,javax.tools.JavaFileObject.Kind)", "type": "constructor", "idx": 82286, "Desc": "construct a simplejavafileobject of the given kind and with the given uri ."}{"node_name": "ToolProvider()", "type": "constructor", "idx": 82358, "Desc": ""}{"node_name": "XAException()", "type": "constructor", "idx": 82388, "Desc": "create an xaexception ."}{"node_name": "XAException(java.lang.String)", "type": "constructor", "idx": 82389, "Desc": "create an xaexception with a given string ."}{"node_name": "XAException(int)", "type": "constructor", "idx": 82391, "Desc": "create an xaexception with a given error code ."}{"node_name": "CatalogException(java.lang.String)", "type": "constructor", "idx": 82442, "Desc": "constructs a new catalogexception with the specified detail message . the cause is not initialized , and may subsequently be initialized by a call to throwable.initcause ( java.lang.throwable ) ."}{"node_name": "CatalogException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 82444, "Desc": "constructs a new catalogexception with the specified detail message and cause ."}{"node_name": "DOMCryptoContext()", "type": "constructor", "idx": 82495, "Desc": "default constructor . ( for invocation by subclass constructors ) ."}{"node_name": "DOMStructure(org.w3c.dom.Node)", "type": "constructor", "idx": 82522, "Desc": "creates a domstructure containing the specified node ."}{"node_name": "DOMSignContext(java.security.Key,org.w3c.dom.Node)", "type": "constructor", "idx": 82550, "Desc": "creates a domsigncontext with the specified signing key and parent node . the signing key is stored in a singleton keyselector that is returned by the getkeyselector method . the marshalled xmlsignature will be added as the last child element of the specified parent node unless a next sibling node is specified by invoking the setnextsibling method ."}{"node_name": "DOMSignContext(java.security.Key,org.w3c.dom.Node,org.w3c.dom.Node)", "type": "constructor", "idx": 82553, "Desc": "creates a domsigncontext with the specified signing key , parent and next sibling nodes . the signing key is stored in a singleton keyselector that is returned by the getkeyselector method . the marshalled xmlsignature will be inserted as a child element of the specified parent node and immediately before the specified next sibling node ."}{"node_name": "DOMSignContext(javax.xml.crypto.KeySelector,org.w3c.dom.Node)", "type": "constructor", "idx": 82557, "Desc": "creates a domsigncontext with the specified key selector and parent node . the marshalled xmlsignature will be added as the last child element of the specified parent node unless a next sibling node is specified by invoking the setnextsibling method ."}{"node_name": "DOMSignContext(javax.xml.crypto.KeySelector,org.w3c.dom.Node,org.w3c.dom.Node)", "type": "constructor", "idx": 82560, "Desc": "creates a domsigncontext with the specified key selector , parent and next sibling nodes . the marshalled xmlsignature will be inserted as a child element of the specified parent node and immediately before the specified next sibling node ."}{"node_name": "DOMValidateContext(javax.xml.crypto.KeySelector,org.w3c.dom.Node)", "type": "constructor", "idx": 82571, "Desc": "creates a domvalidatecontext containing the specified key selector and node ."}{"node_name": "DOMValidateContext(java.security.Key,org.w3c.dom.Node)", "type": "constructor", "idx": 82574, "Desc": "creates a domvalidatecontext containing the specified key and node . the validating key will be stored in a singleton keyselector that is returned when the getkeyselector method is called ."}{"node_name": "KeyInfoFactory()", "type": "constructor", "idx": 82587, "Desc": "default constructor , for invocation by subclasses ."}{"node_name": "ExcC14NParameterSpec()", "type": "constructor", "idx": 82713, "Desc": "creates a excc14nparameterspec with an empty prefix list ."}{"node_name": "ExcC14NParameterSpec(java.util.List)", "type": "constructor", "idx": 82714, "Desc": "creates a excc14nparameterspec with the specified list of prefixes . the list is copied to protect against subsequent modification ."}{"node_name": "HMACParameterSpec(int)", "type": "constructor", "idx": 82718, "Desc": "creates an hmacparameterspec with the specified truncation length ."}{"node_name": "XPathFilter2ParameterSpec(java.util.List)", "type": "constructor", "idx": 82724, "Desc": "creates an xpathfilter2parameterspec ."}{"node_name": "XPathFilterParameterSpec(java.lang.String)", "type": "constructor", "idx": 82728, "Desc": "creates an xpathfilterparameterspec with the specified xpath expression ."}{"node_name": "XPathFilterParameterSpec(java.lang.String,java.util.Map)", "type": "constructor", "idx": 82730, "Desc": "creates an xpathfilterparameterspec with the specified xpath expression and namespace map . the map is copied to protect against subsequent modification ."}{"node_name": "XPathType(java.lang.String,javax.xml.crypto.dsig.spec.XPathType.Filter)", "type": "constructor", "idx": 82741, "Desc": "creates an xpathtype instance with the specified xpath expression and filter ."}{"node_name": "XPathType(java.lang.String,javax.xml.crypto.dsig.spec.XPathType.Filter,java.util.Map)", "type": "constructor", "idx": 82744, "Desc": "creates an xpathtype instance with the specified xpath expression , filter , and namespace map . the map is copied to protect against subsequent modification ."}{"node_name": "XSLTTransformParameterSpec(javax.xml.crypto.XMLStructure)", "type": "constructor", "idx": 82752, "Desc": "creates an xslttransformparameterspec with the specified stylesheet ."}{"node_name": "TransformException()", "type": "constructor", "idx": 82770, "Desc": "constructs a new transformexception with null as its detail message ."}{"node_name": "TransformException(java.lang.String)", "type": "constructor", "idx": 82771, "Desc": "constructs a new transformexception with the specified detail message ."}{"node_name": "TransformException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 82773, "Desc": "constructs a new transformexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "TransformException(java.lang.Throwable)", "type": "constructor", "idx": 82776, "Desc": "constructs a new transformexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "TransformService()", "type": "constructor", "idx": 82785, "Desc": "default constructor , for invocation by subclasses ."}{"node_name": "XMLSignatureException()", "type": "constructor", "idx": 82832, "Desc": "constructs a new xmlsignatureexception with null as its detail message ."}{"node_name": "XMLSignatureException(java.lang.String)", "type": "constructor", "idx": 82833, "Desc": "constructs a new xmlsignatureexception with the specified detail message ."}{"node_name": "XMLSignatureException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 82835, "Desc": "constructs a new xmlsignatureexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "XMLSignatureException(java.lang.Throwable)", "type": "constructor", "idx": 82838, "Desc": "constructs a new xmlsignatureexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "XMLSignatureFactory()", "type": "constructor", "idx": 82847, "Desc": "default constructor , for invocation by subclasses ."}{"node_name": "KeySelector()", "type": "constructor", "idx": 82947, "Desc": "default no-args constructor ; intended for invocation by subclasses only ."}{"node_name": "KeySelectorException()", "type": "constructor", "idx": 82962, "Desc": "constructs a new keyselectorexception with null as its detail message ."}{"node_name": "KeySelectorException(java.lang.String)", "type": "constructor", "idx": 82963, "Desc": "constructs a new keyselectorexception with the specified detail message ."}{"node_name": "KeySelectorException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 82965, "Desc": "constructs a new keyselectorexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "KeySelectorException(java.lang.Throwable)", "type": "constructor", "idx": 82968, "Desc": "constructs a new keyselectorexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "MarshalException()", "type": "constructor", "idx": 82979, "Desc": "constructs a new marshalexception with null as its detail message ."}{"node_name": "MarshalException(java.lang.String)", "type": "constructor", "idx": 82980, "Desc": "constructs a new marshalexception with the specified detail message ."}{"node_name": "MarshalException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 82982, "Desc": "constructs a new marshalexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "MarshalException(java.lang.Throwable)", "type": "constructor", "idx": 82985, "Desc": "constructs a new marshalexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "NoSuchMechanismException()", "type": "constructor", "idx": 82996, "Desc": "constructs a new nosuchmechanismexception with null as its detail message ."}{"node_name": "NoSuchMechanismException(java.lang.String)", "type": "constructor", "idx": 82997, "Desc": "constructs a new nosuchmechanismexception with the specified detail message ."}{"node_name": "NoSuchMechanismException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 82999, "Desc": "constructs a new nosuchmechanismexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "NoSuchMechanismException(java.lang.Throwable)", "type": "constructor", "idx": 83002, "Desc": "constructs a new nosuchmechanismexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "OctetStreamData(java.io.InputStream)", "type": "constructor", "idx": 83011, "Desc": "creates a new octetstreamdata ."}{"node_name": "OctetStreamData(java.io.InputStream,java.lang.String,java.lang.String)", "type": "constructor", "idx": 83013, "Desc": "creates a new octetstreamdata ."}{"node_name": "URIReferenceException()", "type": "constructor", "idx": 83028, "Desc": "constructs a new urireferenceexception with null as its detail message ."}{"node_name": "URIReferenceException(java.lang.String)", "type": "constructor", "idx": 83029, "Desc": "constructs a new urireferenceexception with the specified detail message ."}{"node_name": "URIReferenceException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 83031, "Desc": "constructs a new urireferenceexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "URIReferenceException(java.lang.String,java.lang.Throwable,javax.xml.crypto.URIReference)", "type": "constructor", "idx": 83034, "Desc": "constructs a new urireferenceexception with the specified detail message , cause and urireference . note that the detail message associated with cause is not automatically incorporated in this exception's detail message ."}{"node_name": "URIReferenceException(java.lang.Throwable)", "type": "constructor", "idx": 83038, "Desc": "constructs a new urireferenceexception with the specified cause and a detail message of ( cause == null ? null : cause.tostring() ) ( which typically contains the class and detail message of cause ) ."}{"node_name": "DatatypeConfigurationException()", "type": "constructor", "idx": 83080, "Desc": "create a new datatypeconfigurationexception with no specified detail message and cause ."}{"node_name": "DatatypeConfigurationException(java.lang.String)", "type": "constructor", "idx": 83081, "Desc": "create a new datatypeconfigurationexception with the specified detail message ."}{"node_name": "DatatypeConfigurationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 83083, "Desc": "create a new datatypeconfigurationexception with the specified detail message and cause ."}{"node_name": "DatatypeConfigurationException(java.lang.Throwable)", "type": "constructor", "idx": 83086, "Desc": "create a new datatypeconfigurationexception with the specified cause ."}{"node_name": "DatatypeFactory()", "type": "constructor", "idx": 83131, "Desc": "protected constructor to prevent instantiation outside of package . use newinstance() to create a datatypefactory ."}{"node_name": "Duration()", "type": "constructor", "idx": 83231, "Desc": "default no-arg constructor . note : always use the datatypefactory to construct an instance of duration . <init>() on this class cannot be guaranteed to produce an object with a consistent state and may be removed in the future ."}{"node_name": "XMLGregorianCalendar()", "type": "constructor", "idx": 83274, "Desc": "default no-arg constructor . note : always use the datatypefactory to construct an instance of xmlgregoriancalendar . <init>() on this class cannot be guaranteed to produce an object with a consistent state and may be removed in the future ."}{"node_name": "QName(java.lang.String,java.lang.String)", "type": "constructor", "idx": 83350, "Desc": "qname constructor specifying the namespace uri and local part . if the namespace uri is null , it is set to xmlconstants.null_ns_uri . this value represents no explicitly defined namespace as defined by the namespaces in xml specification . this action preserves compatible behavior with qname 1.0 . explicitly providing the xmlconstants.null_ns_uri value is the preferred coding style . if the local part is null an illegalargumentexception is thrown . a local part of \"\" is allowed to preserve compatible behavior with qname 1.0 . when using <init>(java.lang.String,java.lang.String) , the prefix is set to xmlconstants.default_ns_prefix . the namespace uri is not validated as a uri reference . the local part is not validated as a ncname as specified in namespaces in xml ."}{"node_name": "QName(java.lang.String,java.lang.String,java.lang.String)", "type": "constructor", "idx": 83353, "Desc": "qname constructor specifying the namespace uri , local part and prefix . if the namespace uri is null , it is set to xmlconstants.null_ns_uri . this value represents no explicitly defined namespace as defined by the namespaces in xml specification . this action preserves compatible behavior with qname 1.0 . explicitly providing the xmlconstants.null_ns_uri value is the preferred coding style . if the local part is null an illegalargumentexception is thrown . a local part of \"\" is allowed to preserve compatible behavior with qname 1.0 . if the prefix is null , an illegalargumentexception is thrown . use xmlconstants.default_ns_prefix to explicitly indicate that no prefix is present or the prefix is not relevant . the namespace uri is not validated as a uri reference . the local part and prefix are not validated as a ncname as specified in namespaces in xml ."}{"node_name": "QName(java.lang.String)", "type": "constructor", "idx": 83357, "Desc": "qname constructor specifying the local part . if the local part is null an illegalargumentexception is thrown . a local part of \"\" is allowed to preserve compatible behavior with qname 1.0 . when using <init>(java.lang.String) , the namespace uri is set to xmlconstants.null_ns_uri and the prefix is set to xmlconstants.default_ns_prefix . in an xml context , all element and attribute names exist in the context of a namespace . making this explicit during the construction of a qname helps prevent hard to diagnosis xml validity errors . <init>(java.lang.String)s qname ( string namespaceuri , string localpart ) and qname ( string namespaceuri , string localpart , string prefix ) are preferred . the local part is not validated as a ncname as specified in namespaces in xml ."}{"node_name": "DocumentBuilder()", "type": "constructor", "idx": 83369, "Desc": "protected constructor"}{"node_name": "DocumentBuilderFactory()", "type": "constructor", "idx": 83393, "Desc": "protected constructor to prevent instantiation . use newinstance() ."}{"node_name": "FactoryConfigurationError()", "type": "constructor", "idx": 83440, "Desc": "create a new factoryconfigurationerror with no detail message ."}{"node_name": "FactoryConfigurationError(java.lang.String)", "type": "constructor", "idx": 83441, "Desc": "create a new factoryconfigurationerror with the string specified as an error message ."}{"node_name": "FactoryConfigurationError(java.lang.Exception)", "type": "constructor", "idx": 83443, "Desc": "create a new factoryconfigurationerror with a given exception base cause of the error ."}{"node_name": "FactoryConfigurationError(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 83445, "Desc": "create a new factoryconfigurationerror with the given exception base cause and detail message ."}{"node_name": "ParserConfigurationException()", "type": "constructor", "idx": 83452, "Desc": "create a new parserconfigurationexception with no detail message ."}{"node_name": "ParserConfigurationException(java.lang.String)", "type": "constructor", "idx": 83453, "Desc": "create a new parserconfigurationexception with the string specified as an error message ."}{"node_name": "SAXParser()", "type": "constructor", "idx": 83456, "Desc": "protected constructor to prevent instantiation . use saxparserfactory.newsaxparser() ."}{"node_name": "SAXParserFactory()", "type": "constructor", "idx": 83502, "Desc": "protected constructor to force use of newinstance() ."}{"node_name": "FactoryConfigurationError()", "type": "constructor", "idx": 83611, "Desc": "default constructor"}{"node_name": "FactoryConfigurationError(java.lang.Exception)", "type": "constructor", "idx": 83612, "Desc": "construct an exception with a nested inner exception"}{"node_name": "FactoryConfigurationError(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 83614, "Desc": "construct an exception with a nested inner exception and a message"}{"node_name": "FactoryConfigurationError(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 83617, "Desc": "construct an exception with a nested inner exception and a message"}{"node_name": "FactoryConfigurationError(java.lang.String)", "type": "constructor", "idx": 83620, "Desc": "construct an exception with associated message"}{"node_name": "EventReaderDelegate()", "type": "constructor", "idx": 83635, "Desc": "construct an empty filter with no parent ."}{"node_name": "EventReaderDelegate(javax.xml.stream.XMLEventReader)", "type": "constructor", "idx": 83636, "Desc": "construct an filter with the specified parent ."}{"node_name": "StreamReaderDelegate()", "type": "constructor", "idx": 83642, "Desc": "construct an empty filter with no parent ."}{"node_name": "StreamReaderDelegate(javax.xml.stream.XMLStreamReader)", "type": "constructor", "idx": 83643, "Desc": "construct an filter with the specified parent ."}{"node_name": "XMLEventFactory()", "type": "constructor", "idx": 83659, "Desc": ""}{"node_name": "XMLInputFactory()", "type": "constructor", "idx": 83782, "Desc": ""}{"node_name": "XMLOutputFactory()", "type": "constructor", "idx": 83845, "Desc": ""}{"node_name": "XMLStreamException()", "type": "constructor", "idx": 83908, "Desc": "default constructor"}{"node_name": "XMLStreamException(java.lang.String)", "type": "constructor", "idx": 83909, "Desc": "construct an exception with the assocated message ."}{"node_name": "XMLStreamException(java.lang.Throwable)", "type": "constructor", "idx": 83911, "Desc": "construct an exception with the assocated exception"}{"node_name": "XMLStreamException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 83913, "Desc": "construct an exception with the assocated message and exception"}{"node_name": "XMLStreamException(java.lang.String,javax.xml.stream.Location,java.lang.Throwable)", "type": "constructor", "idx": 83916, "Desc": "construct an exception with the assocated message , exception and location ."}{"node_name": "XMLStreamException(java.lang.String,javax.xml.stream.Location)", "type": "constructor", "idx": 83920, "Desc": "construct an exception with the assocated message , exception and location ."}{"node_name": "DOMResult()", "type": "constructor", "idx": 84071, "Desc": "zero-argument default constructor . node , siblingnode and systemid will be set to null ."}{"node_name": "DOMResult(org.w3c.dom.Node)", "type": "constructor", "idx": 84072, "Desc": "use a dom node to create a new output target . in practice , the node should be a document node , a documentfragment node , or a element node . in other words , a node that accepts children . siblingnode and systemid will be set to null ."}{"node_name": "DOMResult(org.w3c.dom.Node,java.lang.String)", "type": "constructor", "idx": 84074, "Desc": "use a dom node to create a new output target with the specified system id . in practice , the node should be a document node , a documentfragment node , or a element node . in other words , a node that accepts children . siblingnode will be set to null ."}{"node_name": "DOMResult(org.w3c.dom.Node,org.w3c.dom.Node)", "type": "constructor", "idx": 84077, "Desc": "use a dom node to create a new output target specifying the child node where the result nodes should be inserted before . in practice , node and nextsibling should be a document node , a documentfragment node , or a element node . in other words , a node that accepts children . use nextsibling to specify the child node where the result nodes should be inserted before . if nextsibling is not a sibling of node , then an illegalargumentexception is thrown . if node is null and nextsibling is not null , then an illegalargumentexception is thrown . if nextsibling is null , then the behavior is the same as calling domresult ( node node ) , i.e. append the result nodes as the last child of the specified node . systemid will be set to null ."}{"node_name": "DOMResult(org.w3c.dom.Node,org.w3c.dom.Node,java.lang.String)", "type": "constructor", "idx": 84080, "Desc": "use a dom node to create a new output target specifying the child node where the result nodes should be inserted before and the specified system id . in practice , node and nextsibling should be a document node , a documentfragment node , or a element node . in other words , a node that accepts children . use nextsibling to specify the child node where the result nodes should be inserted before . if nextsibling is not a sibling of node , then an illegalargumentexception is thrown . if node is null and nextsibling is not null , then an illegalargumentexception is thrown . if nextsibling is null , then the behavior is the same as calling domresult ( node node , string systemid ) , i.e. append the result nodes as the last child of the specified node and use the specified system id ."}{"node_name": "DOMSource()", "type": "constructor", "idx": 84095, "Desc": "zero-argument default constructor . if <init>() is used , and no dom source is set using setnode ( node node ) , then the transformer will create an empty source document using documentbuilder.newdocument() ."}{"node_name": "DOMSource(org.w3c.dom.Node)", "type": "constructor", "idx": 84096, "Desc": "create a new input source with a dom node . the operation will be applied to the subtree rooted at this node . in xslt , a \" / \" pattern still means the root of the tree ( not the subtree ) , and the evaluation of global variables and parameters is done from the root node also ."}{"node_name": "DOMSource(org.w3c.dom.Node,java.lang.String)", "type": "constructor", "idx": 84098, "Desc": "create a new input source with a dom node , and with the system id also passed in as the base uri ."}{"node_name": "SAXResult()", "type": "constructor", "idx": 84134, "Desc": "zero-argument default constructor ."}{"node_name": "SAXResult(org.xml.sax.ContentHandler)", "type": "constructor", "idx": 84135, "Desc": "create a saxresult that targets a sax2 contenthandler ."}{"node_name": "SAXSource()", "type": "constructor", "idx": 84148, "Desc": "zero-argument default constructor . if <init>() is used , and no sax source is set using setinputsource ( inputsource inputsource ) , then the transformer will create an empty source inputsource using new inputsource() ."}{"node_name": "SAXSource(org.xml.sax.XMLReader,org.xml.sax.InputSource)", "type": "constructor", "idx": 84149, "Desc": "create a saxsource , using an xmlreader and a sax inputsource . the transformer or saxtransformerfactory will set itself to be the reader's contenthandler , and then will call reader.parse ( inputsource ) ."}{"node_name": "SAXSource(org.xml.sax.InputSource)", "type": "constructor", "idx": 84152, "Desc": "create a saxsource , using a sax inputsource . the transformer or saxtransformerfactory creates a reader ( if setxmlreader is not used ) , sets itself as the reader's contenthandler , and calls reader.parse ( inputsource ) ."}{"node_name": "SAXTransformerFactory()", "type": "constructor", "idx": 84169, "Desc": "the default constructor is protected on purpose ."}{"node_name": "StAXResult(javax.xml.stream.XMLEventWriter)", "type": "constructor", "idx": 84204, "Desc": "creates a new instance of a staxresult by supplying an xmleventwriter . xmleventwriter must be a non-null reference ."}{"node_name": "StAXResult(javax.xml.stream.XMLStreamWriter)", "type": "constructor", "idx": 84206, "Desc": "creates a new instance of a staxresult by supplying an xmlstreamwriter . xmlstreamwriter must be a non-null reference ."}{"node_name": "StAXSource(javax.xml.stream.XMLEventReader)", "type": "constructor", "idx": 84215, "Desc": "creates a new instance of a staxsource by supplying an xmleventreader . xmleventreader must be a non-null reference . xmleventreader must be in xmlstreamconstants.start_document or xmlstreamconstants.start_element state ."}{"node_name": "StAXSource(javax.xml.stream.XMLStreamReader)", "type": "constructor", "idx": 84217, "Desc": "creates a new instance of a staxsource by supplying an xmlstreamreader . xmlstreamreader must be a non-null reference . xmlstreamreader must be in xmlstreamconstants.start_document or xmlstreamconstants.start_element state ."}{"node_name": "StreamResult()", "type": "constructor", "idx": 84227, "Desc": "zero-argument default constructor ."}{"node_name": "StreamResult(java.io.OutputStream)", "type": "constructor", "idx": 84228, "Desc": "construct a streamresult from a byte stream . normally , a stream should be used rather than a reader , so that the transformer may use instructions contained in the transformation instructions to control the encoding ."}{"node_name": "StreamResult(java.io.Writer)", "type": "constructor", "idx": 84230, "Desc": "construct a streamresult from a character stream . normally , a stream should be used rather than a reader , so that the transformer may use instructions contained in the transformation instructions to control the encoding . however , there are times when it is useful to write to a character stream , such as when using a stringwriter ."}{"node_name": "StreamResult(java.lang.String)", "type": "constructor", "idx": 84232, "Desc": "construct a streamresult from a url ."}{"node_name": "StreamResult(java.io.File)", "type": "constructor", "idx": 84234, "Desc": "construct a streamresult from a file ."}{"node_name": "StreamSource()", "type": "constructor", "idx": 84249, "Desc": "zero-argument default constructor . if <init>() is used , and no stream source is set using setinputstream ( java.io.inputstream inputstream ) or setreader ( java.io.reader reader ) , then the transformer will create an empty source inputstream using new inputstream() ."}{"node_name": "StreamSource(java.io.InputStream)", "type": "constructor", "idx": 84250, "Desc": "construct a streamsource from a byte stream . normally , a stream should be used rather than a reader , so the xml parser can resolve character encoding specified by the xml declaration . if <init>(java.io.InputStream) is used to process a stylesheet , normally setsystemid should also be called , so that relative uri references can be resolved ."}{"node_name": "StreamSource(java.io.InputStream,java.lang.String)", "type": "constructor", "idx": 84252, "Desc": "construct a streamsource from a byte stream . normally , a stream should be used rather than a reader , so that the xml parser can resolve character encoding specified by the xml declaration . <init>(java.io.InputStream,java.lang.String) allows the systemid to be set in addition to the input stream , which allows relative uris to be processed ."}{"node_name": "StreamSource(java.io.Reader)", "type": "constructor", "idx": 84255, "Desc": "construct a streamsource from a character reader . normally , a stream should be used rather than a reader , so that the xml parser can resolve character encoding specified by the xml declaration . however , in many cases the encoding of the input stream is already resolved , as in the case of reading xml from a stringreader ."}{"node_name": "StreamSource(java.io.Reader,java.lang.String)", "type": "constructor", "idx": 84257, "Desc": "construct a streamsource from a character reader . normally , a stream should be used rather than a reader , so that the xml parser may resolve character encoding specified by the xml declaration . however , in many cases the encoding of the input stream is already resolved , as in the case of reading xml from a stringreader ."}{"node_name": "StreamSource(java.lang.String)", "type": "constructor", "idx": 84260, "Desc": "construct a streamsource from a url ."}{"node_name": "StreamSource(java.io.File)", "type": "constructor", "idx": 84262, "Desc": "construct a streamsource from a file ."}{"node_name": "Transformer()", "type": "constructor", "idx": 84283, "Desc": "default constructor is protected on purpose ."}{"node_name": "TransformerConfigurationException()", "type": "constructor", "idx": 84309, "Desc": "create a new transformerconfigurationexception with no detail message ."}{"node_name": "TransformerConfigurationException(java.lang.String)", "type": "constructor", "idx": 84310, "Desc": "create a new transformerconfigurationexception with the string specified as an error message ."}{"node_name": "TransformerConfigurationException(java.lang.Throwable)", "type": "constructor", "idx": 84312, "Desc": "create a new transformerconfigurationexception with a given exception base cause of the error ."}{"node_name": "TransformerConfigurationException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 84314, "Desc": "create a new transformerconfigurationexception with the given exception base cause and detail message ."}{"node_name": "TransformerConfigurationException(java.lang.String,javax.xml.transform.SourceLocator)", "type": "constructor", "idx": 84317, "Desc": "create a new transformerconfigurationexception from a message and a locator . <init>(java.lang.String,javax.xml.transform.SourceLocator) is especially useful when an application is creating its own exception from within a documenthandler callback ."}{"node_name": "TransformerConfigurationException(java.lang.String,javax.xml.transform.SourceLocator,java.lang.Throwable)", "type": "constructor", "idx": 84320, "Desc": "wrap an existing exception in a transformerconfigurationexception ."}{"node_name": "TransformerException(java.lang.String)", "type": "constructor", "idx": 84325, "Desc": "create a new transformerexception ."}{"node_name": "TransformerException(java.lang.Throwable)", "type": "constructor", "idx": 84327, "Desc": "create a new transformerexception wrapping an existing exception ."}{"node_name": "TransformerException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 84329, "Desc": "wrap an existing exception in a transformerexception . this is used for throwing processor exceptions before the processing has started ."}{"node_name": "TransformerException(java.lang.String,javax.xml.transform.SourceLocator)", "type": "constructor", "idx": 84332, "Desc": "create a new transformerexception from a message and a locator . <init>(java.lang.String,javax.xml.transform.SourceLocator) is especially useful when an application is creating its own exception from within a documenthandler callback ."}{"node_name": "TransformerException(java.lang.String,javax.xml.transform.SourceLocator,java.lang.Throwable)", "type": "constructor", "idx": 84335, "Desc": "wrap an existing exception in a transformerexception ."}{"node_name": "TransformerFactory()", "type": "constructor", "idx": 84354, "Desc": "default constructor is protected on purpose ."}{"node_name": "TransformerFactoryConfigurationError()", "type": "constructor", "idx": 84387, "Desc": "create a new transformerfactoryconfigurationerror with no detail message ."}{"node_name": "TransformerFactoryConfigurationError(java.lang.String)", "type": "constructor", "idx": 84388, "Desc": "create a new transformerfactoryconfigurationerror with the string specified as an error message ."}{"node_name": "TransformerFactoryConfigurationError(java.lang.Exception)", "type": "constructor", "idx": 84390, "Desc": "create a new transformerfactoryconfigurationerror with a given exception base cause of the error ."}{"node_name": "TransformerFactoryConfigurationError(java.lang.Exception,java.lang.String)", "type": "constructor", "idx": 84392, "Desc": "create a new transformerfactoryconfigurationerror with the given exception base cause and detail message ."}{"node_name": "Schema()", "type": "constructor", "idx": 84403, "Desc": "constructor for the derived class . <init>() does nothing ."}{"node_name": "SchemaFactory()", "type": "constructor", "idx": 84407, "Desc": "constructor for derived classes . <init>() does nothing . derived classes must create schemafactory objects that have null errorhandler and null lsresourceresolver ."}{"node_name": "SchemaFactoryConfigurationError()", "type": "constructor", "idx": 84443, "Desc": "create a new schemafactoryconfigurationerror with no detail message ."}{"node_name": "SchemaFactoryConfigurationError(java.lang.String)", "type": "constructor", "idx": 84444, "Desc": "create a new schemafactoryconfigurationerror with the string specified as an error message ."}{"node_name": "SchemaFactoryConfigurationError(java.lang.Throwable)", "type": "constructor", "idx": 84446, "Desc": "create a new schemafactoryconfigurationerror with the given throwable base cause ."}{"node_name": "SchemaFactoryConfigurationError(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 84448, "Desc": "create a new schemafactoryconfigurationerror with the given throwable base cause and detail message ."}{"node_name": "SchemaFactoryLoader()", "type": "constructor", "idx": 84452, "Desc": "a do-nothing constructor ."}{"node_name": "TypeInfoProvider()", "type": "constructor", "idx": 84456, "Desc": "constructor for the derived class . <init>() does nothing ."}{"node_name": "Validator()", "type": "constructor", "idx": 84465, "Desc": "constructor for derived classes . <init>() does nothing . derived classes must create validator objects that have null errorhandler and null lsresourceresolver ."}{"node_name": "ValidatorHandler()", "type": "constructor", "idx": 84489, "Desc": "constructor for derived classes . <init>() does nothing . derived classes must create validatorhandler objects that have null errorhandler and null lsresourceresolver ."}{"node_name": "XPathException(java.lang.String)", "type": "constructor", "idx": 84585, "Desc": "constructs a new xpathexception with the specified detail message . the cause is not initialized . if message is null , then a nullpointerexception is thrown ."}{"node_name": "XPathException(java.lang.Throwable)", "type": "constructor", "idx": 84587, "Desc": "constructs a new xpathexception with the specified cause . if cause is null , then a nullpointerexception is thrown ."}{"node_name": "XPathExpressionException(java.lang.String)", "type": "constructor", "idx": 84617, "Desc": "constructs a new xpathexpressionexception with the specified detail message . the cause is not initialized . if message is null , then a nullpointerexception is thrown ."}{"node_name": "XPathExpressionException(java.lang.Throwable)", "type": "constructor", "idx": 84619, "Desc": "constructs a new xpathexpressionexception with the specified cause . if cause is null , then a nullpointerexception is thrown ."}{"node_name": "XPathFactory()", "type": "constructor", "idx": 84624, "Desc": "protected constructor as newinstance() or newinstance ( string uri ) or newinstance ( string uri , string factoryclassname , classloader classloader ) should be used to create a new instance of an xpathfactory ."}{"node_name": "XPathFactoryConfigurationException(java.lang.String)", "type": "constructor", "idx": 84646, "Desc": "constructs a new xpathfactoryconfigurationexception with the specified detail message . the cause is not initialized . if message is null , then a nullpointerexception is thrown ."}{"node_name": "XPathFactoryConfigurationException(java.lang.Throwable)", "type": "constructor", "idx": 84648, "Desc": "constructs a new xpathfactoryconfigurationexception with the specified cause . if cause is null , then a nullpointerexception is thrown ."}{"node_name": "XPathFunctionException(java.lang.String)", "type": "constructor", "idx": 84654, "Desc": "constructs a new xpathfunctionexception with the specified detail message . the cause is not initialized . if message is null , then a nullpointerexception is thrown ."}{"node_name": "XPathFunctionException(java.lang.Throwable)", "type": "constructor", "idx": 84656, "Desc": "constructs a new xpathfunctionexception with the specified cause . if cause is null , then a nullpointerexception is thrown ."}{"node_name": "BeansLinker()", "type": "constructor", "idx": 84671, "Desc": "creates a new beans linker . equivalent to beanslinker ( missingmemberhandlerfactory ) with null passed as the missing member handler factory , resulting in the default behavior for linking and evaluating missing members ."}{"node_name": "BeansLinker(jdk.dynalink.beans.MissingMemberHandlerFactory)", "type": "constructor", "idx": 84672, "Desc": "creates a new beans linker with the specified factory for creating missing member handlers . the passed factory can be null if the default behavior is adequate . see missingmemberhandlerfactory for details ."}{"node_name": "CallSiteDescriptor(java.lang.invoke.MethodHandles.Lookup,jdk.dynalink.Operation,java.lang.invoke.MethodType)", "type": "constructor", "idx": 84704, "Desc": "creates a new call site descriptor ."}{"node_name": "DynamicLinkerFactory()", "type": "constructor", "idx": 84728, "Desc": "creates a new dynamic linker factory with default configuration . upon creation , the factory can be configured using various setxxx() methods and used to create one or more dynamic linkers according to its current configuration using createlinker() ."}{"node_name": "GuardedInvocation(java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 84763, "Desc": "creates a new unconditional guarded invocation . it is unconditional as it has no invalidations ."}{"node_name": "GuardedInvocation(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 84765, "Desc": "creates a new guarded invocation , with a guard method handle ."}{"node_name": "GuardedInvocation(java.lang.invoke.MethodHandle,java.lang.invoke.SwitchPoint)", "type": "constructor", "idx": 84768, "Desc": "creates a new guarded invocation that can be invalidated by a switch point ."}{"node_name": "GuardedInvocation(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.SwitchPoint)", "type": "constructor", "idx": 84771, "Desc": "creates a new guarded invocation , with both a guard method handle and a switch point that can be used to invalidate it ."}{"node_name": "GuardedInvocation(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.SwitchPoint,java.lang.Class)", "type": "constructor", "idx": 84775, "Desc": "creates a new guarded invocation , with a guard method handle , a switch point that can be used to invalidate it , and an exception that if thrown when invoked also invalidates it ."}{"node_name": "GuardedInvocation(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle,java.lang.invoke.SwitchPoint[],java.lang.Class)", "type": "constructor", "idx": 84780, "Desc": "creates a new guarded invocation , with a guard method handle , any number of switch points that can be used to invalidate it , and an exception that if thrown when invoked also invalidates it ."}{"node_name": "GuardingDynamicLinkerExporter()", "type": "constructor", "idx": 84831, "Desc": "creates a new linker exporter . if there is a security manager installed checks for the runtimepermission ( \" dynalink.exportlinkersautomatically \") runtime permission . this ensures only language runtimes granted this permission will be allowed to export their linkers for automatic loading ."}{"node_name": "CompositeGuardingDynamicLinker(java.lang.Iterable)", "type": "constructor", "idx": 84877, "Desc": "creates a new composite linker ."}{"node_name": "CompositeTypeBasedGuardingDynamicLinker(java.lang.Iterable)", "type": "constructor", "idx": 84883, "Desc": "creates a new composite type-based linker ."}{"node_name": "DefaultInternalObjectFilter(java.lang.invoke.MethodHandle,java.lang.invoke.MethodHandle)", "type": "constructor", "idx": 84890, "Desc": "creates a new filter ."}{"node_name": "Lookup(java.lang.invoke.MethodHandles.Lookup)", "type": "constructor", "idx": 84924, "Desc": "creates a new instance , bound to an instance of methodhandles.lookup ."}{"node_name": "SimpleLinkRequest(jdk.dynalink.CallSiteDescriptor,boolean,java.lang.Object...)", "type": "constructor", "idx": 84975, "Desc": "creates a new link request ."}{"node_name": "NamedOperation(jdk.dynalink.Operation,java.lang.Object)", "type": "constructor", "idx": 85001, "Desc": "creates a new named operation ."}{"node_name": "NamespaceOperation(jdk.dynalink.Operation,jdk.dynalink.Namespace...)", "type": "constructor", "idx": 85018, "Desc": "constructs a new namespace operation ."}{"node_name": "NoSuchDynamicMethodException(java.lang.String)", "type": "constructor", "idx": 85041, "Desc": "creates a new nosuchdynamicmethodexception"}{"node_name": "SecureLookupSupplier(java.lang.invoke.MethodHandles.Lookup)", "type": "constructor", "idx": 85062, "Desc": "creates a new secure lookup supplier , securing the passed lookup ."}{"node_name": "AbstractRelinkableCallSite(jdk.dynalink.CallSiteDescriptor)", "type": "constructor", "idx": 85077, "Desc": "creates a new abstract relinkable call site ."}{"node_name": "ChainedCallSite(jdk.dynalink.CallSiteDescriptor)", "type": "constructor", "idx": 85080, "Desc": "creates a new chained call site ."}{"node_name": "SimpleRelinkableCallSite(jdk.dynalink.CallSiteDescriptor)", "type": "constructor", "idx": 85084, "Desc": "creates a new call site with monomorphic inline caching strategy ."}{"node_name": "Event()", "type": "constructor", "idx": 85087, "Desc": "sole constructor , for invocation by subclass constructors , typically implicit ."}{"node_name": "StandardDoclet()", "type": "constructor", "idx": 85150, "Desc": ""}{"node_name": "AnnotationElement(java.lang.Class,java.util.Map)", "type": "constructor", "idx": 85167, "Desc": "creates an annotation element to use for dynamically defined events . supported value types are byte , int , short , long , double , float , boolean , char , and string . enums , arrays and classes , are not supported . if annotationtype has annotations ( directly present , indirectly present , or associated ) , then those annotation are recursively included . however , both the annotationtype and any annotation found recursively must have the metadatadefinition annotation . to statically define events , see event class ."}{"node_name": "AnnotationElement(java.lang.Class,java.lang.Object)", "type": "constructor", "idx": 85170, "Desc": "creates an annotation element to use for dynamically defined events . supported value types are byte , int , short , long , double , float , boolean , char , and string . enums , arrays , and classes are not supported . if annotationtype has annotations ( directly present , indirectly present , or associated ) , then those annotations are recursively included . however , both annotationtype and any annotation found recursively must have the metadatadefinition annotation . to statically define events , see event class ."}{"node_name": "AnnotationElement(java.lang.Class)", "type": "constructor", "idx": 85173, "Desc": "creates an annotation element to use for dynamically defined events . supported value types are byte , short , int , long , double , float , boolean , char , and string . enums , arrays , and classes are not supported . if annotationtype has annotations ( directly present , indirectly present or associated ) , then those annotation are recursively included . however , both annotationtype and any annotation found recursively must have the metadatadefinition annotation . to statically define events , see event class ."}{"node_name": "RecordingFile(java.nio.file.Path)", "type": "constructor", "idx": 85278, "Desc": "creates a recording file ."}{"node_name": "Event()", "type": "constructor", "idx": 85294, "Desc": "sole constructor , for invocation by subclass constructors , typically implicit ."}{"node_name": "FlightRecorderPermission(java.lang.String)", "type": "constructor", "idx": 85364, "Desc": "constructs a flightrecorderpermission with the specified name ."}{"node_name": "Control()", "type": "constructor", "idx": 85368, "Desc": "constructor for invocation by subclass constructors ."}{"node_name": "Recording(java.util.Map)", "type": "constructor", "idx": 85382, "Desc": ""}{"node_name": "Recording()", "type": "constructor", "idx": 85383, "Desc": "creates a recording without any settings . a newly created recording is in the recordingstate.new state . to start the recording , invoke the start() method ."}{"node_name": "Recording(jdk.jfr.Configuration)", "type": "constructor", "idx": 85384, "Desc": "creates a recording with settings from a configuration . the following example shows how create a recording that uses a predefined configuration . recording r = new recording ( configuration.getconfiguration ( \" default \")) ; the newly created recording is in the recordingstate.new state . to start the recording , invoke the start() method ."}{"node_name": "SettingControl()", "type": "constructor", "idx": 85442, "Desc": "constructor for invocation by subclass constructors ."}{"node_name": "ValueDescriptor(java.lang.Class,java.lang.String)", "type": "constructor", "idx": 85477, "Desc": "constructs a value descriptor , useful for dynamically creating event types and annotations . the following types are supported : byte.class short.class int.class long.class char.class float.class double.class boolean.class string.class class.class thread.class the name must be a valid java identifier ( for example , \" maxthroughput \") . see 3.8 java language specification for more information ."}{"node_name": "ValueDescriptor(java.lang.Class,java.lang.String,java.util.List)", "type": "constructor", "idx": 85480, "Desc": "constructs a value descriptor , useful for dynamically creating event types and annotations . the following types are supported : byte.class short.class int.class long.class char.class float.class double.class boolean.class string.class class.class thread.class the name must be a valid java identifier ( for example , \" maxthroughput \") . see 3.8 java language specification for more information ."}{"node_name": "DirectExecutionControl(jdk.jshell.execution.LoaderDelegate)", "type": "constructor", "idx": 85511, "Desc": "creates an instance , delegating loader operations to the specified delegate ."}{"node_name": "DirectExecutionControl()", "type": "constructor", "idx": 85513, "Desc": "create an instance using the default class loading ."}{"node_name": "FailOverExecutionControlProvider()", "type": "constructor", "idx": 85530, "Desc": "create an instance . the instance can be used to start and return an executioncontrol instance by attempting to start a series of executioncontrol specs , until one is successful ."}{"node_name": "JdiExecutionControl(java.io.ObjectOutput,java.io.ObjectInput)", "type": "constructor", "idx": 85539, "Desc": "create an instance ."}{"node_name": "JdiExecutionControlProvider()", "type": "constructor", "idx": 85553, "Desc": "create an instance . an instance can be used to generate an executioncontrol instance that uses the java debug interface as part of the control of a remote process ."}{"node_name": "JdiInitiator(int,java.util.List,java.lang.String,boolean,java.lang.String,int,java.util.Map)", "type": "constructor", "idx": 85557, "Desc": "start the remote agent and establish a jdi connection to it ."}{"node_name": "LocalExecutionControl(jdk.jshell.execution.LoaderDelegate)", "type": "constructor", "idx": 85577, "Desc": "creates an instance , delegating loader operations to the specified delegate ."}{"node_name": "LocalExecutionControl()", "type": "constructor", "idx": 85579, "Desc": "create an instance using the default class loading ."}{"node_name": "LocalExecutionControlProvider()", "type": "constructor", "idx": 85581, "Desc": "create an instance . an instance can be used to generate an executioncontrol instance that executes code in the same process ."}{"node_name": "RemoteExecutionControl(jdk.jshell.execution.LoaderDelegate)", "type": "constructor", "idx": 85588, "Desc": "creates an instance , delegating loader operations to the specified delegate ."}{"node_name": "RemoteExecutionControl()", "type": "constructor", "idx": 85590, "Desc": "create an instance using the default class loading ."}{"node_name": "StreamingExecutionControl(java.io.ObjectOutput,java.io.ObjectInput)", "type": "constructor", "idx": 85596, "Desc": "creates an instance ."}{"node_name": "ClassBytecodes(java.lang.String,byte[])", "type": "constructor", "idx": 85775, "Desc": "creates a name / bytecode pair ."}{"node_name": "ClassInstallException(java.lang.String,boolean[])", "type": "constructor", "idx": 85781, "Desc": ""}{"node_name": "EngineTerminationException(java.lang.String)", "type": "constructor", "idx": 85784, "Desc": ""}{"node_name": "ExecutionControlException(java.lang.String)", "type": "constructor", "idx": 85786, "Desc": ""}{"node_name": "InternalException(java.lang.String)", "type": "constructor", "idx": 85788, "Desc": ""}{"node_name": "NotImplementedException(java.lang.String)", "type": "constructor", "idx": 85815, "Desc": ""}{"node_name": "ResolutionException(int,java.lang.StackTraceElement[])", "type": "constructor", "idx": 85817, "Desc": "constructs an exception indicating that a declarationsnippet with unresolved references has been encountered ."}{"node_name": "StoppedException()", "type": "constructor", "idx": 85823, "Desc": ""}{"node_name": "UserException(java.lang.String,java.lang.String,java.lang.StackTraceElement[])", "type": "constructor", "idx": 85825, "Desc": ""}{"node_name": "SPIResolutionException(int)", "type": "constructor", "idx": 85840, "Desc": "constructs an spi layer exception indicating that a declarationsnippet with unresolved references has been encountered . the throw of this exception is generated into the body of a recoverable_defined method ."}{"node_name": "NetworkPermission(java.lang.String)", "type": "constructor", "idx": 86050, "Desc": "creates a networkpermission with the given target name ."}{"node_name": "NetworkPermission(java.lang.String,java.lang.String)", "type": "constructor", "idx": 86052, "Desc": "creates a networkpermission with the given target name ."}{"node_name": "Builder(java.security.KeyStore.PrivateKeyEntry)", "type": "constructor", "idx": 86103, "Desc": "creates a jarsigner.builder object with a keystore.privatekeyentry object ."}{"node_name": "Builder(java.security.PrivateKey,java.security.cert.CertPath)", "type": "constructor", "idx": 86105, "Desc": "creates a jarsigner.builder object with a private key and a certification path ."}{"node_name": "JarSignerException(java.lang.String,java.lang.Throwable)", "type": "constructor", "idx": 86142, "Desc": "constructs a new jarsignerexception with the specified detail message and cause . note that the detail message associated with cause is not automatically incorporated in this jarsignerexception's detail message ."}{"node_name": "JSException()", "type": "constructor", "idx": 86146, "Desc": "constructs a new javascript exception with null as it's detail message ."}{"node_name": "JSException(java.lang.String)", "type": "constructor", "idx": 86147, "Desc": "construct a new javascript exception with the specified detail message ."}{"node_name": "JSException(java.lang.Throwable)", "type": "constructor", "idx": 86149, "Desc": "construct a new javascript exception with the specified cause ."}{"node_name": "JSObject()", "type": "constructor", "idx": 86152, "Desc": "constructs a new jsobject . users should neither call this method nor subclass jsobject ."}{"node_name": "ChannelBinding(java.net.InetAddress,java.net.InetAddress,byte[])", "type": "constructor", "idx": 86171, "Desc": "create a channelbinding object with user supplied address information and data . null values can be used for any fields which the application does not want to specify ."}{"node_name": "ChannelBinding(byte[])", "type": "constructor", "idx": 86175, "Desc": "creates a channelbinding object without any addressing information ."}{"node_name": "GSSException(int)", "type": "constructor", "idx": 86308, "Desc": "creates a gssexception object with a specified major code ."}{"node_name": "GSSException(int,int,java.lang.String)", "type": "constructor", "idx": 86310, "Desc": "creates a gssexception object with the specified major code , minor code , and minor code textual explanation . <init>(int,int,java.lang.String) is to be used when the exception is originating from the underlying mechanism level . it allows the setting of both the gss code and the mechanism code ."}{"node_name": "GSSManager()", "type": "constructor", "idx": 86324, "Desc": ""}{"node_name": "MessageProp(boolean)", "type": "constructor", "idx": 86392, "Desc": "constructor which sets the desired privacy state . the qop value used is 0 ."}{"node_name": "MessageProp(int,boolean)", "type": "constructor", "idx": 86394, "Desc": "constructor which sets the values for the qop and privacy state ."}{"node_name": "Oid(java.lang.String)", "type": "constructor", "idx": 86417, "Desc": "constructs an oid object from a string representation of its integer components ."}{"node_name": "Oid(java.io.InputStream)", "type": "constructor", "idx": 86419, "Desc": "creates an oid object from its asn.1 der encoding . this refers to the full encoding including tag and length . the structure and encoding of oids is defined in isoiec-8824 and isoiec-8825 . this method is identical in functionality to its byte array counterpart ."}{"node_name": "Oid(byte[])", "type": "constructor", "idx": 86421, "Desc": "creates an oid object from its asn.1 der encoding . this refers to the full encoding including tag and length . the structure and encoding of oids is defined in isoiec-8824 and isoiec-8825 . this method is identical in functionality to its inputstream conterpart ."}{"node_name": "DOMException(short,java.lang.String)", "type": "constructor", "idx": 86963, "Desc": ""}{"node_name": "EventException(short,java.lang.String)", "type": "constructor", "idx": 87089, "Desc": ""}{"node_name": "LSException(short,java.lang.String)", "type": "constructor", "idx": 87823, "Desc": ""}{"node_name": "RangeException(short,java.lang.String)", "type": "constructor", "idx": 88077, "Desc": ""}{"node_name": "XPathException(short,java.lang.String)", "type": "constructor", "idx": 88207, "Desc": ""}{"node_name": "Attributes2Impl()", "type": "constructor", "idx": 88338, "Desc": "construct a new , empty attributes2impl object ."}{"node_name": "Attributes2Impl(org.xml.sax.Attributes)", "type": "constructor", "idx": 88339, "Desc": "copy an existing attributes or attributes2 object . if the object implements attributes2 , values of the specified and declared flags for each attribute are copied . otherwise the flag values are defaulted to assume no dtd was used , unless there is evidence to the contrary ( such as attributes with type other than cdata , which must have been declared ) . <init>(org.xml.sax.Attributes) is especially useful inside a startelement event ."}{"node_name": "DefaultHandler2()", "type": "constructor", "idx": 88387, "Desc": "constructs a handler which ignores all parsing events ."}{"node_name": "Locator2Impl()", "type": "constructor", "idx": 88428, "Desc": "construct a new , empty locator2impl object . this will not normally be useful , since the main purpose of this class is to make a snapshot of an existing locator ."}{"node_name": "Locator2Impl(org.xml.sax.Locator)", "type": "constructor", "idx": 88429, "Desc": "copy an existing locator or locator2 object . if the object implements locator2 , values of the encoding and versionstrings are copied , otherwise they set to null ."}{"node_name": "AttributesImpl()", "type": "constructor", "idx": 88440, "Desc": "construct a new , empty attributesimpl object ."}{"node_name": "AttributesImpl(org.xml.sax.Attributes)", "type": "constructor", "idx": 88441, "Desc": "copy an existing attributes object . <init>(org.xml.sax.Attributes) is especially useful inside a startelement event ."}{"node_name": "DefaultHandler()", "type": "constructor", "idx": 88503, "Desc": ""}{"node_name": "LocatorImpl()", "type": "constructor", "idx": 88554, "Desc": "zero-argument constructor . this will not normally be useful , since the main purpose of this class is to make a snapshot of an existing locator ."}{"node_name": "LocatorImpl(org.xml.sax.Locator)", "type": "constructor", "idx": 88555, "Desc": "copy constructor . create a persistent copy of the current state of a locator . when the original locator changes , this copy will still keep the original values ( and it can be used outside the scope of documenthandler methods ) ."}{"node_name": "NamespaceSupport()", "type": "constructor", "idx": 88572, "Desc": "create a new namespace support object ."}{"node_name": "ParserAdapter()", "type": "constructor", "idx": 88591, "Desc": "construct a new parser adapter . use the \" org.xml.sax.parser \" property to locate the embedded sax1 driver ."}{"node_name": "ParserAdapter(org.xml.sax.Parser)", "type": "constructor", "idx": 88592, "Desc": "construct a new parser adapter . note that the embedded parser cannot be changed once the adapter is created ; to embed a different parser , allocate a new parseradapter ."}{"node_name": "XMLFilterImpl()", "type": "constructor", "idx": 88642, "Desc": "construct an empty xml filter , with no parent . this filter will have no parent : you must assign a parent before you start a parse or do any configuration with setfeature or setproperty , unless you use this as a pure event consumer rather than as an xmlreader ."}{"node_name": "XMLFilterImpl(org.xml.sax.XMLReader)", "type": "constructor", "idx": 88643, "Desc": "construct an xml filter with the specified parent ."}{"node_name": "XMLReaderAdapter()", "type": "constructor", "idx": 88723, "Desc": "create a new adapter . use the \" org.xml.sax.driver \" property to locate the sax2 driver to embed ."}{"node_name": "XMLReaderAdapter(org.xml.sax.XMLReader)", "type": "constructor", "idx": 88724, "Desc": "create a new adapter . create a new adapter , wrapped around a sax2 xmlreader . the adapter will make the xmlreader act like a sax1 parser ."}{"node_name": "InputSource()", "type": "constructor", "idx": 88773, "Desc": "zero-argument default constructor ."}{"node_name": "InputSource(java.lang.String)", "type": "constructor", "idx": 88774, "Desc": "create a new input source with a system identifier . applications may use setpublicid to include a public identifier as well , or setencoding to specify the character encoding , if known . if the system identifier is a url , it must be fully resolved ( it may not be a relative url ) ."}{"node_name": "InputSource(java.io.InputStream)", "type": "constructor", "idx": 88776, "Desc": "create a new input source with a byte stream . application writers should use setsystemid() to provide a base for resolving relative uris , may use setpublicid to include a public identifier , and may use setencoding to specify the object's character encoding ."}{"node_name": "InputSource(java.io.Reader)", "type": "constructor", "idx": 88778, "Desc": "create a new input source with a character stream . application writers should use setsystemid() to provide a base for resolving relative uris , and may use setpublicid to include a public identifier . the character stream shall not include a byte order mark ."}{"node_name": "SAXException()", "type": "constructor", "idx": 88802, "Desc": "create a new saxexception ."}{"node_name": "SAXException(java.lang.String)", "type": "constructor", "idx": 88803, "Desc": "create a new saxexception ."}{"node_name": "SAXException(java.lang.Exception)", "type": "constructor", "idx": 88805, "Desc": "create a new saxexception wrapping an existing exception . the existing exception will be embedded in the new one , and its message will become the default message for the saxexception ."}{"node_name": "SAXException(java.lang.String,java.lang.Exception)", "type": "constructor", "idx": 88807, "Desc": "create a new saxexception from an existing exception . the existing exception will be embedded in the new one , but the new exception will have its own message ."}{"node_name": "SAXNotRecognizedException()", "type": "constructor", "idx": 88815, "Desc": "default constructor ."}{"node_name": "SAXNotRecognizedException(java.lang.String)", "type": "constructor", "idx": 88816, "Desc": "construct a new exception with the given message ."}{"node_name": "SAXNotSupportedException()", "type": "constructor", "idx": 88819, "Desc": "construct a new exception with no message ."}{"node_name": "SAXNotSupportedException(java.lang.String)", "type": "constructor", "idx": 88820, "Desc": "construct a new exception with the given message ."}{"node_name": "SAXParseException(java.lang.String,org.xml.sax.Locator)", "type": "constructor", "idx": 88823, "Desc": "create a new saxparseexception from a message and a locator . <init>(java.lang.String,org.xml.sax.Locator) is especially useful when an application is creating its own exception from within a contenthandler callback ."}{"node_name": "SAXParseException(java.lang.String,org.xml.sax.Locator,java.lang.Exception)", "type": "constructor", "idx": 88826, "Desc": "wrap an existing exception in a saxparseexception . <init>(java.lang.String,org.xml.sax.Locator,java.lang.Exception) is especially useful when an application is creating its own exception from within a contenthandler callback , and needs to wrap an existing exception that is not a subclass of saxexception ."}{"node_name": "SAXParseException(java.lang.String,java.lang.String,java.lang.String,int,int)", "type": "constructor", "idx": 88830, "Desc": "create a new saxparseexception . <init>(java.lang.String,java.lang.String,java.lang.String,int,int) is most useful for parser writers . all parameters except the message are as if they were provided by a locator . for example , if the system identifier is a url ( including relative filename ) , the caller must resolve it fully before creating the exception ."}{"node_name": "SAXParseException(java.lang.String,java.lang.String,java.lang.String,int,int,java.lang.Exception)", "type": "constructor", "idx": 88836, "Desc": "create a new saxparseexception with an embedded exception . <init>(java.lang.String,java.lang.String,java.lang.String,int,int,java.lang.Exception) is most useful for parser writers who need to wrap an exception that is not a subclass of saxexception . all parameters except the message and exception are as if they were provided by a locator . for example , if the system identifier is a url ( including relative filename ) , the caller must resolve it fully before creating the exception ."}